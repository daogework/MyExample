/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.CLPF = (function() {

    /**
     * Namespace CLPF.
     * @exports CLPF
     * @namespace
     */
    var CLPF = {};

    CLPF.LogoutReq = (function() {

        /**
         * Properties of a LogoutReq.
         * @memberof CLPF
         * @interface ILogoutReq
         */

        /**
         * Constructs a new LogoutReq.
         * @memberof CLPF
         * @classdesc Represents a LogoutReq.
         * @implements ILogoutReq
         * @constructor
         * @param {CLPF.ILogoutReq=} [properties] Properties to set
         */
        function LogoutReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LogoutReq instance using the specified properties.
         * @function create
         * @memberof CLPF.LogoutReq
         * @static
         * @param {CLPF.ILogoutReq=} [properties] Properties to set
         * @returns {CLPF.LogoutReq} LogoutReq instance
         */
        LogoutReq.create = function create(properties) {
            return new LogoutReq(properties);
        };

        /**
         * Encodes the specified LogoutReq message. Does not implicitly {@link CLPF.LogoutReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LogoutReq
         * @static
         * @param {CLPF.ILogoutReq} message LogoutReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LogoutReq message, length delimited. Does not implicitly {@link CLPF.LogoutReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LogoutReq
         * @static
         * @param {CLPF.ILogoutReq} message LogoutReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogoutReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LogoutReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LogoutReq} LogoutReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LogoutReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogoutReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LogoutReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LogoutReq} LogoutReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogoutReq message.
         * @function verify
         * @memberof CLPF.LogoutReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogoutReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LogoutReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LogoutReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LogoutReq} LogoutReq
         */
        LogoutReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LogoutReq)
                return object;
            return new $root.CLPF.LogoutReq();
        };

        /**
         * Creates a plain object from a LogoutReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LogoutReq
         * @static
         * @param {CLPF.LogoutReq} message LogoutReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogoutReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LogoutReq to JSON.
         * @function toJSON
         * @memberof CLPF.LogoutReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogoutReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LogoutReq;
    })();

    CLPF.LogoutAck = (function() {

        /**
         * Properties of a LogoutAck.
         * @memberof CLPF
         * @interface ILogoutAck
         * @property {number|null} [errcode] LogoutAck errcode
         */

        /**
         * Constructs a new LogoutAck.
         * @memberof CLPF
         * @classdesc Represents a LogoutAck.
         * @implements ILogoutAck
         * @constructor
         * @param {CLPF.ILogoutAck=} [properties] Properties to set
         */
        function LogoutAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogoutAck errcode.
         * @member {number} errcode
         * @memberof CLPF.LogoutAck
         * @instance
         */
        LogoutAck.prototype.errcode = 0;

        /**
         * Creates a new LogoutAck instance using the specified properties.
         * @function create
         * @memberof CLPF.LogoutAck
         * @static
         * @param {CLPF.ILogoutAck=} [properties] Properties to set
         * @returns {CLPF.LogoutAck} LogoutAck instance
         */
        LogoutAck.create = function create(properties) {
            return new LogoutAck(properties);
        };

        /**
         * Encodes the specified LogoutAck message. Does not implicitly {@link CLPF.LogoutAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LogoutAck
         * @static
         * @param {CLPF.ILogoutAck} message LogoutAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified LogoutAck message, length delimited. Does not implicitly {@link CLPF.LogoutAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LogoutAck
         * @static
         * @param {CLPF.ILogoutAck} message LogoutAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogoutAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LogoutAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LogoutAck} LogoutAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LogoutAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogoutAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LogoutAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LogoutAck} LogoutAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogoutAck message.
         * @function verify
         * @memberof CLPF.LogoutAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogoutAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a LogoutAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LogoutAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LogoutAck} LogoutAck
         */
        LogoutAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LogoutAck)
                return object;
            var message = new $root.CLPF.LogoutAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a LogoutAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LogoutAck
         * @static
         * @param {CLPF.LogoutAck} message LogoutAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogoutAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this LogoutAck to JSON.
         * @function toJSON
         * @memberof CLPF.LogoutAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogoutAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LogoutAck;
    })();

    CLPF.ResSyncNtf = (function() {

        /**
         * Properties of a ResSyncNtf.
         * @memberof CLPF
         * @interface IResSyncNtf
         * @property {number|Long|null} [diamond] ResSyncNtf diamond
         * @property {number|Long|null} [currency] ResSyncNtf currency
         * @property {number|Long|null} [integral] ResSyncNtf integral
         */

        /**
         * Constructs a new ResSyncNtf.
         * @memberof CLPF
         * @classdesc Represents a ResSyncNtf.
         * @implements IResSyncNtf
         * @constructor
         * @param {CLPF.IResSyncNtf=} [properties] Properties to set
         */
        function ResSyncNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResSyncNtf diamond.
         * @member {number|Long} diamond
         * @memberof CLPF.ResSyncNtf
         * @instance
         */
        ResSyncNtf.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResSyncNtf currency.
         * @member {number|Long} currency
         * @memberof CLPF.ResSyncNtf
         * @instance
         */
        ResSyncNtf.prototype.currency = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResSyncNtf integral.
         * @member {number|Long} integral
         * @memberof CLPF.ResSyncNtf
         * @instance
         */
        ResSyncNtf.prototype.integral = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ResSyncNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {CLPF.IResSyncNtf=} [properties] Properties to set
         * @returns {CLPF.ResSyncNtf} ResSyncNtf instance
         */
        ResSyncNtf.create = function create(properties) {
            return new ResSyncNtf(properties);
        };

        /**
         * Encodes the specified ResSyncNtf message. Does not implicitly {@link CLPF.ResSyncNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {CLPF.IResSyncNtf} message ResSyncNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResSyncNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.diamond != null && Object.hasOwnProperty.call(message, "diamond"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.diamond);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.currency);
            if (message.integral != null && Object.hasOwnProperty.call(message, "integral"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.integral);
            return writer;
        };

        /**
         * Encodes the specified ResSyncNtf message, length delimited. Does not implicitly {@link CLPF.ResSyncNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {CLPF.IResSyncNtf} message ResSyncNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResSyncNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResSyncNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ResSyncNtf} ResSyncNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResSyncNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ResSyncNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.diamond = reader.int64();
                    break;
                case 2:
                    message.currency = reader.int64();
                    break;
                case 3:
                    message.integral = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResSyncNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ResSyncNtf} ResSyncNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResSyncNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResSyncNtf message.
         * @function verify
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResSyncNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency) && !(message.currency && $util.isInteger(message.currency.low) && $util.isInteger(message.currency.high)))
                    return "currency: integer|Long expected";
            if (message.integral != null && message.hasOwnProperty("integral"))
                if (!$util.isInteger(message.integral) && !(message.integral && $util.isInteger(message.integral.low) && $util.isInteger(message.integral.high)))
                    return "integral: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResSyncNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ResSyncNtf} ResSyncNtf
         */
        ResSyncNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ResSyncNtf)
                return object;
            var message = new $root.CLPF.ResSyncNtf();
            if (object.diamond != null)
                if ($util.Long)
                    (message.diamond = $util.Long.fromValue(object.diamond)).unsigned = false;
                else if (typeof object.diamond === "string")
                    message.diamond = parseInt(object.diamond, 10);
                else if (typeof object.diamond === "number")
                    message.diamond = object.diamond;
                else if (typeof object.diamond === "object")
                    message.diamond = new $util.LongBits(object.diamond.low >>> 0, object.diamond.high >>> 0).toNumber();
            if (object.currency != null)
                if ($util.Long)
                    (message.currency = $util.Long.fromValue(object.currency)).unsigned = false;
                else if (typeof object.currency === "string")
                    message.currency = parseInt(object.currency, 10);
                else if (typeof object.currency === "number")
                    message.currency = object.currency;
                else if (typeof object.currency === "object")
                    message.currency = new $util.LongBits(object.currency.low >>> 0, object.currency.high >>> 0).toNumber();
            if (object.integral != null)
                if ($util.Long)
                    (message.integral = $util.Long.fromValue(object.integral)).unsigned = false;
                else if (typeof object.integral === "string")
                    message.integral = parseInt(object.integral, 10);
                else if (typeof object.integral === "number")
                    message.integral = object.integral;
                else if (typeof object.integral === "object")
                    message.integral = new $util.LongBits(object.integral.low >>> 0, object.integral.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ResSyncNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ResSyncNtf
         * @static
         * @param {CLPF.ResSyncNtf} message ResSyncNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResSyncNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.diamond = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.diamond = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.currency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.currency = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.integral = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.integral = options.longs === String ? "0" : 0;
            }
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (typeof message.diamond === "number")
                    object.diamond = options.longs === String ? String(message.diamond) : message.diamond;
                else
                    object.diamond = options.longs === String ? $util.Long.prototype.toString.call(message.diamond) : options.longs === Number ? new $util.LongBits(message.diamond.low >>> 0, message.diamond.high >>> 0).toNumber() : message.diamond;
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (typeof message.currency === "number")
                    object.currency = options.longs === String ? String(message.currency) : message.currency;
                else
                    object.currency = options.longs === String ? $util.Long.prototype.toString.call(message.currency) : options.longs === Number ? new $util.LongBits(message.currency.low >>> 0, message.currency.high >>> 0).toNumber() : message.currency;
            if (message.integral != null && message.hasOwnProperty("integral"))
                if (typeof message.integral === "number")
                    object.integral = options.longs === String ? String(message.integral) : message.integral;
                else
                    object.integral = options.longs === String ? $util.Long.prototype.toString.call(message.integral) : options.longs === Number ? new $util.LongBits(message.integral.low >>> 0, message.integral.high >>> 0).toNumber() : message.integral;
            return object;
        };

        /**
         * Converts this ResSyncNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ResSyncNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResSyncNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResSyncNtf;
    })();

    CLPF.ResChangedNtf = (function() {

        /**
         * Properties of a ResChangedNtf.
         * @memberof CLPF
         * @interface IResChangedNtf
         * @property {number|null} [resType] ResChangedNtf resType
         * @property {number|Long|null} [resValue] ResChangedNtf resValue
         * @property {number|Long|null} [resDelta] ResChangedNtf resDelta
         * @property {number|Long|null} [resId] ResChangedNtf resId
         * @property {number|null} [reason] ResChangedNtf reason
         */

        /**
         * Constructs a new ResChangedNtf.
         * @memberof CLPF
         * @classdesc Represents a ResChangedNtf.
         * @implements IResChangedNtf
         * @constructor
         * @param {CLPF.IResChangedNtf=} [properties] Properties to set
         */
        function ResChangedNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResChangedNtf resType.
         * @member {number} resType
         * @memberof CLPF.ResChangedNtf
         * @instance
         */
        ResChangedNtf.prototype.resType = 0;

        /**
         * ResChangedNtf resValue.
         * @member {number|Long} resValue
         * @memberof CLPF.ResChangedNtf
         * @instance
         */
        ResChangedNtf.prototype.resValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResChangedNtf resDelta.
         * @member {number|Long} resDelta
         * @memberof CLPF.ResChangedNtf
         * @instance
         */
        ResChangedNtf.prototype.resDelta = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResChangedNtf resId.
         * @member {number|Long} resId
         * @memberof CLPF.ResChangedNtf
         * @instance
         */
        ResChangedNtf.prototype.resId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResChangedNtf reason.
         * @member {number} reason
         * @memberof CLPF.ResChangedNtf
         * @instance
         */
        ResChangedNtf.prototype.reason = 0;

        /**
         * Creates a new ResChangedNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {CLPF.IResChangedNtf=} [properties] Properties to set
         * @returns {CLPF.ResChangedNtf} ResChangedNtf instance
         */
        ResChangedNtf.create = function create(properties) {
            return new ResChangedNtf(properties);
        };

        /**
         * Encodes the specified ResChangedNtf message. Does not implicitly {@link CLPF.ResChangedNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {CLPF.IResChangedNtf} message ResChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResChangedNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resType != null && Object.hasOwnProperty.call(message, "resType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resType);
            if (message.resValue != null && Object.hasOwnProperty.call(message, "resValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.resValue);
            if (message.resDelta != null && Object.hasOwnProperty.call(message, "resDelta"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.resDelta);
            if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.resId);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ResChangedNtf message, length delimited. Does not implicitly {@link CLPF.ResChangedNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {CLPF.IResChangedNtf} message ResChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResChangedNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResChangedNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ResChangedNtf} ResChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResChangedNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ResChangedNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resType = reader.int32();
                    break;
                case 2:
                    message.resValue = reader.int64();
                    break;
                case 3:
                    message.resDelta = reader.int64();
                    break;
                case 4:
                    message.resId = reader.int64();
                    break;
                case 5:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResChangedNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ResChangedNtf} ResChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResChangedNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResChangedNtf message.
         * @function verify
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResChangedNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resType != null && message.hasOwnProperty("resType"))
                if (!$util.isInteger(message.resType))
                    return "resType: integer expected";
            if (message.resValue != null && message.hasOwnProperty("resValue"))
                if (!$util.isInteger(message.resValue) && !(message.resValue && $util.isInteger(message.resValue.low) && $util.isInteger(message.resValue.high)))
                    return "resValue: integer|Long expected";
            if (message.resDelta != null && message.hasOwnProperty("resDelta"))
                if (!$util.isInteger(message.resDelta) && !(message.resDelta && $util.isInteger(message.resDelta.low) && $util.isInteger(message.resDelta.high)))
                    return "resDelta: integer|Long expected";
            if (message.resId != null && message.hasOwnProperty("resId"))
                if (!$util.isInteger(message.resId) && !(message.resId && $util.isInteger(message.resId.low) && $util.isInteger(message.resId.high)))
                    return "resId: integer|Long expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            return null;
        };

        /**
         * Creates a ResChangedNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ResChangedNtf} ResChangedNtf
         */
        ResChangedNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ResChangedNtf)
                return object;
            var message = new $root.CLPF.ResChangedNtf();
            if (object.resType != null)
                message.resType = object.resType | 0;
            if (object.resValue != null)
                if ($util.Long)
                    (message.resValue = $util.Long.fromValue(object.resValue)).unsigned = false;
                else if (typeof object.resValue === "string")
                    message.resValue = parseInt(object.resValue, 10);
                else if (typeof object.resValue === "number")
                    message.resValue = object.resValue;
                else if (typeof object.resValue === "object")
                    message.resValue = new $util.LongBits(object.resValue.low >>> 0, object.resValue.high >>> 0).toNumber();
            if (object.resDelta != null)
                if ($util.Long)
                    (message.resDelta = $util.Long.fromValue(object.resDelta)).unsigned = false;
                else if (typeof object.resDelta === "string")
                    message.resDelta = parseInt(object.resDelta, 10);
                else if (typeof object.resDelta === "number")
                    message.resDelta = object.resDelta;
                else if (typeof object.resDelta === "object")
                    message.resDelta = new $util.LongBits(object.resDelta.low >>> 0, object.resDelta.high >>> 0).toNumber();
            if (object.resId != null)
                if ($util.Long)
                    (message.resId = $util.Long.fromValue(object.resId)).unsigned = false;
                else if (typeof object.resId === "string")
                    message.resId = parseInt(object.resId, 10);
                else if (typeof object.resId === "number")
                    message.resId = object.resId;
                else if (typeof object.resId === "object")
                    message.resId = new $util.LongBits(object.resId.low >>> 0, object.resId.high >>> 0).toNumber();
            if (object.reason != null)
                message.reason = object.reason | 0;
            return message;
        };

        /**
         * Creates a plain object from a ResChangedNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ResChangedNtf
         * @static
         * @param {CLPF.ResChangedNtf} message ResChangedNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResChangedNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resType = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.resValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.resDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resDelta = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.resId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resId = options.longs === String ? "0" : 0;
                object.reason = 0;
            }
            if (message.resType != null && message.hasOwnProperty("resType"))
                object.resType = message.resType;
            if (message.resValue != null && message.hasOwnProperty("resValue"))
                if (typeof message.resValue === "number")
                    object.resValue = options.longs === String ? String(message.resValue) : message.resValue;
                else
                    object.resValue = options.longs === String ? $util.Long.prototype.toString.call(message.resValue) : options.longs === Number ? new $util.LongBits(message.resValue.low >>> 0, message.resValue.high >>> 0).toNumber() : message.resValue;
            if (message.resDelta != null && message.hasOwnProperty("resDelta"))
                if (typeof message.resDelta === "number")
                    object.resDelta = options.longs === String ? String(message.resDelta) : message.resDelta;
                else
                    object.resDelta = options.longs === String ? $util.Long.prototype.toString.call(message.resDelta) : options.longs === Number ? new $util.LongBits(message.resDelta.low >>> 0, message.resDelta.high >>> 0).toNumber() : message.resDelta;
            if (message.resId != null && message.hasOwnProperty("resId"))
                if (typeof message.resId === "number")
                    object.resId = options.longs === String ? String(message.resId) : message.resId;
                else
                    object.resId = options.longs === String ? $util.Long.prototype.toString.call(message.resId) : options.longs === Number ? new $util.LongBits(message.resId.low >>> 0, message.resId.high >>> 0).toNumber() : message.resId;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ResChangedNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ResChangedNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResChangedNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResChangedNtf;
    })();

    CLPF.ResQueryReq = (function() {

        /**
         * Properties of a ResQueryReq.
         * @memberof CLPF
         * @interface IResQueryReq
         */

        /**
         * Constructs a new ResQueryReq.
         * @memberof CLPF
         * @classdesc Represents a ResQueryReq.
         * @implements IResQueryReq
         * @constructor
         * @param {CLPF.IResQueryReq=} [properties] Properties to set
         */
        function ResQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ResQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {CLPF.IResQueryReq=} [properties] Properties to set
         * @returns {CLPF.ResQueryReq} ResQueryReq instance
         */
        ResQueryReq.create = function create(properties) {
            return new ResQueryReq(properties);
        };

        /**
         * Encodes the specified ResQueryReq message. Does not implicitly {@link CLPF.ResQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {CLPF.IResQueryReq} message ResQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ResQueryReq message, length delimited. Does not implicitly {@link CLPF.ResQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {CLPF.IResQueryReq} message ResQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ResQueryReq} ResQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ResQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ResQueryReq} ResQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResQueryReq message.
         * @function verify
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ResQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ResQueryReq} ResQueryReq
         */
        ResQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ResQueryReq)
                return object;
            return new $root.CLPF.ResQueryReq();
        };

        /**
         * Creates a plain object from a ResQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ResQueryReq
         * @static
         * @param {CLPF.ResQueryReq} message ResQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ResQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.ResQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResQueryReq;
    })();

    CLPF.ResQueryAck = (function() {

        /**
         * Properties of a ResQueryAck.
         * @memberof CLPF
         * @interface IResQueryAck
         * @property {number|null} [errcode] ResQueryAck errcode
         * @property {number|Long|null} [diamond] ResQueryAck diamond
         * @property {number|Long|null} [currency] ResQueryAck currency
         * @property {number|Long|null} [bankCurrency] ResQueryAck bankCurrency
         */

        /**
         * Constructs a new ResQueryAck.
         * @memberof CLPF
         * @classdesc Represents a ResQueryAck.
         * @implements IResQueryAck
         * @constructor
         * @param {CLPF.IResQueryAck=} [properties] Properties to set
         */
        function ResQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ResQueryAck
         * @instance
         */
        ResQueryAck.prototype.errcode = 0;

        /**
         * ResQueryAck diamond.
         * @member {number|Long} diamond
         * @memberof CLPF.ResQueryAck
         * @instance
         */
        ResQueryAck.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResQueryAck currency.
         * @member {number|Long} currency
         * @memberof CLPF.ResQueryAck
         * @instance
         */
        ResQueryAck.prototype.currency = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResQueryAck bankCurrency.
         * @member {number|Long} bankCurrency
         * @memberof CLPF.ResQueryAck
         * @instance
         */
        ResQueryAck.prototype.bankCurrency = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ResQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {CLPF.IResQueryAck=} [properties] Properties to set
         * @returns {CLPF.ResQueryAck} ResQueryAck instance
         */
        ResQueryAck.create = function create(properties) {
            return new ResQueryAck(properties);
        };

        /**
         * Encodes the specified ResQueryAck message. Does not implicitly {@link CLPF.ResQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {CLPF.IResQueryAck} message ResQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.diamond != null && Object.hasOwnProperty.call(message, "diamond"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.diamond);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.currency);
            if (message.bankCurrency != null && Object.hasOwnProperty.call(message, "bankCurrency"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.bankCurrency);
            return writer;
        };

        /**
         * Encodes the specified ResQueryAck message, length delimited. Does not implicitly {@link CLPF.ResQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {CLPF.IResQueryAck} message ResQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ResQueryAck} ResQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ResQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.diamond = reader.int64();
                    break;
                case 3:
                    message.currency = reader.int64();
                    break;
                case 4:
                    message.bankCurrency = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ResQueryAck} ResQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResQueryAck message.
         * @function verify
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency) && !(message.currency && $util.isInteger(message.currency.low) && $util.isInteger(message.currency.high)))
                    return "currency: integer|Long expected";
            if (message.bankCurrency != null && message.hasOwnProperty("bankCurrency"))
                if (!$util.isInteger(message.bankCurrency) && !(message.bankCurrency && $util.isInteger(message.bankCurrency.low) && $util.isInteger(message.bankCurrency.high)))
                    return "bankCurrency: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ResQueryAck} ResQueryAck
         */
        ResQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ResQueryAck)
                return object;
            var message = new $root.CLPF.ResQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.diamond != null)
                if ($util.Long)
                    (message.diamond = $util.Long.fromValue(object.diamond)).unsigned = false;
                else if (typeof object.diamond === "string")
                    message.diamond = parseInt(object.diamond, 10);
                else if (typeof object.diamond === "number")
                    message.diamond = object.diamond;
                else if (typeof object.diamond === "object")
                    message.diamond = new $util.LongBits(object.diamond.low >>> 0, object.diamond.high >>> 0).toNumber();
            if (object.currency != null)
                if ($util.Long)
                    (message.currency = $util.Long.fromValue(object.currency)).unsigned = false;
                else if (typeof object.currency === "string")
                    message.currency = parseInt(object.currency, 10);
                else if (typeof object.currency === "number")
                    message.currency = object.currency;
                else if (typeof object.currency === "object")
                    message.currency = new $util.LongBits(object.currency.low >>> 0, object.currency.high >>> 0).toNumber();
            if (object.bankCurrency != null)
                if ($util.Long)
                    (message.bankCurrency = $util.Long.fromValue(object.bankCurrency)).unsigned = false;
                else if (typeof object.bankCurrency === "string")
                    message.bankCurrency = parseInt(object.bankCurrency, 10);
                else if (typeof object.bankCurrency === "number")
                    message.bankCurrency = object.bankCurrency;
                else if (typeof object.bankCurrency === "object")
                    message.bankCurrency = new $util.LongBits(object.bankCurrency.low >>> 0, object.bankCurrency.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ResQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ResQueryAck
         * @static
         * @param {CLPF.ResQueryAck} message ResQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.diamond = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.diamond = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.currency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.currency = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bankCurrency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bankCurrency = options.longs === String ? "0" : 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (typeof message.diamond === "number")
                    object.diamond = options.longs === String ? String(message.diamond) : message.diamond;
                else
                    object.diamond = options.longs === String ? $util.Long.prototype.toString.call(message.diamond) : options.longs === Number ? new $util.LongBits(message.diamond.low >>> 0, message.diamond.high >>> 0).toNumber() : message.diamond;
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (typeof message.currency === "number")
                    object.currency = options.longs === String ? String(message.currency) : message.currency;
                else
                    object.currency = options.longs === String ? $util.Long.prototype.toString.call(message.currency) : options.longs === Number ? new $util.LongBits(message.currency.low >>> 0, message.currency.high >>> 0).toNumber() : message.currency;
            if (message.bankCurrency != null && message.hasOwnProperty("bankCurrency"))
                if (typeof message.bankCurrency === "number")
                    object.bankCurrency = options.longs === String ? String(message.bankCurrency) : message.bankCurrency;
                else
                    object.bankCurrency = options.longs === String ? $util.Long.prototype.toString.call(message.bankCurrency) : options.longs === Number ? new $util.LongBits(message.bankCurrency.low >>> 0, message.bankCurrency.high >>> 0).toNumber() : message.bankCurrency;
            return object;
        };

        /**
         * Converts this ResQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.ResQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResQueryAck;
    })();

    CLPF.ItemInfo = (function() {

        /**
         * Properties of an ItemInfo.
         * @memberof CLPF
         * @interface IItemInfo
         * @property {number|null} [itemId] ItemInfo itemId
         * @property {number|null} [itemSubId] ItemInfo itemSubId
         * @property {number|Long|null} [itemCount] ItemInfo itemCount
         */

        /**
         * Constructs a new ItemInfo.
         * @memberof CLPF
         * @classdesc Represents an ItemInfo.
         * @implements IItemInfo
         * @constructor
         * @param {CLPF.IItemInfo=} [properties] Properties to set
         */
        function ItemInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemInfo itemId.
         * @member {number} itemId
         * @memberof CLPF.ItemInfo
         * @instance
         */
        ItemInfo.prototype.itemId = 0;

        /**
         * ItemInfo itemSubId.
         * @member {number} itemSubId
         * @memberof CLPF.ItemInfo
         * @instance
         */
        ItemInfo.prototype.itemSubId = 0;

        /**
         * ItemInfo itemCount.
         * @member {number|Long} itemCount
         * @memberof CLPF.ItemInfo
         * @instance
         */
        ItemInfo.prototype.itemCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ItemInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemInfo
         * @static
         * @param {CLPF.IItemInfo=} [properties] Properties to set
         * @returns {CLPF.ItemInfo} ItemInfo instance
         */
        ItemInfo.create = function create(properties) {
            return new ItemInfo(properties);
        };

        /**
         * Encodes the specified ItemInfo message. Does not implicitly {@link CLPF.ItemInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemInfo
         * @static
         * @param {CLPF.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.itemSubId != null && Object.hasOwnProperty.call(message, "itemSubId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemSubId);
            if (message.itemCount != null && Object.hasOwnProperty.call(message, "itemCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.itemCount);
            return writer;
        };

        /**
         * Encodes the specified ItemInfo message, length delimited. Does not implicitly {@link CLPF.ItemInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemInfo
         * @static
         * @param {CLPF.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.itemSubId = reader.int32();
                    break;
                case 3:
                    message.itemCount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemInfo message.
         * @function verify
         * @memberof CLPF.ItemInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemSubId != null && message.hasOwnProperty("itemSubId"))
                if (!$util.isInteger(message.itemSubId))
                    return "itemSubId: integer expected";
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                if (!$util.isInteger(message.itemCount) && !(message.itemCount && $util.isInteger(message.itemCount.low) && $util.isInteger(message.itemCount.high)))
                    return "itemCount: integer|Long expected";
            return null;
        };

        /**
         * Creates an ItemInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemInfo} ItemInfo
         */
        ItemInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemInfo)
                return object;
            var message = new $root.CLPF.ItemInfo();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            if (object.itemSubId != null)
                message.itemSubId = object.itemSubId | 0;
            if (object.itemCount != null)
                if ($util.Long)
                    (message.itemCount = $util.Long.fromValue(object.itemCount)).unsigned = false;
                else if (typeof object.itemCount === "string")
                    message.itemCount = parseInt(object.itemCount, 10);
                else if (typeof object.itemCount === "number")
                    message.itemCount = object.itemCount;
                else if (typeof object.itemCount === "object")
                    message.itemCount = new $util.LongBits(object.itemCount.low >>> 0, object.itemCount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ItemInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemInfo
         * @static
         * @param {CLPF.ItemInfo} message ItemInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.itemSubId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.itemCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.itemCount = options.longs === String ? "0" : 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemSubId != null && message.hasOwnProperty("itemSubId"))
                object.itemSubId = message.itemSubId;
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                if (typeof message.itemCount === "number")
                    object.itemCount = options.longs === String ? String(message.itemCount) : message.itemCount;
                else
                    object.itemCount = options.longs === String ? $util.Long.prototype.toString.call(message.itemCount) : options.longs === Number ? new $util.LongBits(message.itemCount.low >>> 0, message.itemCount.high >>> 0).toNumber() : message.itemCount;
            return object;
        };

        /**
         * Converts this ItemInfo to JSON.
         * @function toJSON
         * @memberof CLPF.ItemInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemInfo;
    })();

    CLPF.ItemUseReq = (function() {

        /**
         * Properties of an ItemUseReq.
         * @memberof CLPF
         * @interface IItemUseReq
         * @property {CLPF.IItemInfo|null} [item] ItemUseReq item
         * @property {number|null} [gameId] ItemUseReq gameId
         * @property {boolean|null} [autoBuy] ItemUseReq autoBuy
         */

        /**
         * Constructs a new ItemUseReq.
         * @memberof CLPF
         * @classdesc Represents an ItemUseReq.
         * @implements IItemUseReq
         * @constructor
         * @param {CLPF.IItemUseReq=} [properties] Properties to set
         */
        function ItemUseReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemUseReq item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.ItemUseReq
         * @instance
         */
        ItemUseReq.prototype.item = null;

        /**
         * ItemUseReq gameId.
         * @member {number} gameId
         * @memberof CLPF.ItemUseReq
         * @instance
         */
        ItemUseReq.prototype.gameId = 0;

        /**
         * ItemUseReq autoBuy.
         * @member {boolean} autoBuy
         * @memberof CLPF.ItemUseReq
         * @instance
         */
        ItemUseReq.prototype.autoBuy = false;

        /**
         * Creates a new ItemUseReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {CLPF.IItemUseReq=} [properties] Properties to set
         * @returns {CLPF.ItemUseReq} ItemUseReq instance
         */
        ItemUseReq.create = function create(properties) {
            return new ItemUseReq(properties);
        };

        /**
         * Encodes the specified ItemUseReq message. Does not implicitly {@link CLPF.ItemUseReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {CLPF.IItemUseReq} message ItemUseReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemUseReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.autoBuy != null && Object.hasOwnProperty.call(message, "autoBuy"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoBuy);
            return writer;
        };

        /**
         * Encodes the specified ItemUseReq message, length delimited. Does not implicitly {@link CLPF.ItemUseReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {CLPF.IItemUseReq} message ItemUseReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemUseReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemUseReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemUseReq} ItemUseReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemUseReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemUseReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    message.autoBuy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemUseReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemUseReq} ItemUseReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemUseReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemUseReq message.
         * @function verify
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemUseReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.autoBuy != null && message.hasOwnProperty("autoBuy"))
                if (typeof message.autoBuy !== "boolean")
                    return "autoBuy: boolean expected";
            return null;
        };

        /**
         * Creates an ItemUseReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemUseReq} ItemUseReq
         */
        ItemUseReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemUseReq)
                return object;
            var message = new $root.CLPF.ItemUseReq();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.ItemUseReq.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.autoBuy != null)
                message.autoBuy = Boolean(object.autoBuy);
            return message;
        };

        /**
         * Creates a plain object from an ItemUseReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemUseReq
         * @static
         * @param {CLPF.ItemUseReq} message ItemUseReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemUseReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item = null;
                object.gameId = 0;
                object.autoBuy = false;
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.autoBuy != null && message.hasOwnProperty("autoBuy"))
                object.autoBuy = message.autoBuy;
            return object;
        };

        /**
         * Converts this ItemUseReq to JSON.
         * @function toJSON
         * @memberof CLPF.ItemUseReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemUseReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemUseReq;
    })();

    CLPF.ItemUseAck = (function() {

        /**
         * Properties of an ItemUseAck.
         * @memberof CLPF
         * @interface IItemUseAck
         * @property {number|null} [errcode] ItemUseAck errcode
         */

        /**
         * Constructs a new ItemUseAck.
         * @memberof CLPF
         * @classdesc Represents an ItemUseAck.
         * @implements IItemUseAck
         * @constructor
         * @param {CLPF.IItemUseAck=} [properties] Properties to set
         */
        function ItemUseAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemUseAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ItemUseAck
         * @instance
         */
        ItemUseAck.prototype.errcode = 0;

        /**
         * Creates a new ItemUseAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {CLPF.IItemUseAck=} [properties] Properties to set
         * @returns {CLPF.ItemUseAck} ItemUseAck instance
         */
        ItemUseAck.create = function create(properties) {
            return new ItemUseAck(properties);
        };

        /**
         * Encodes the specified ItemUseAck message. Does not implicitly {@link CLPF.ItemUseAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {CLPF.IItemUseAck} message ItemUseAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemUseAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ItemUseAck message, length delimited. Does not implicitly {@link CLPF.ItemUseAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {CLPF.IItemUseAck} message ItemUseAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemUseAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemUseAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemUseAck} ItemUseAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemUseAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemUseAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemUseAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemUseAck} ItemUseAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemUseAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemUseAck message.
         * @function verify
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemUseAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates an ItemUseAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemUseAck} ItemUseAck
         */
        ItemUseAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemUseAck)
                return object;
            var message = new $root.CLPF.ItemUseAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from an ItemUseAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemUseAck
         * @static
         * @param {CLPF.ItemUseAck} message ItemUseAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemUseAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ItemUseAck to JSON.
         * @function toJSON
         * @memberof CLPF.ItemUseAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemUseAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemUseAck;
    })();

    CLPF.ItemCountChangeNtf = (function() {

        /**
         * Properties of an ItemCountChangeNtf.
         * @memberof CLPF
         * @interface IItemCountChangeNtf
         * @property {Array.<CLPF.IItemInfo>|null} [items] ItemCountChangeNtf items
         */

        /**
         * Constructs a new ItemCountChangeNtf.
         * @memberof CLPF
         * @classdesc Represents an ItemCountChangeNtf.
         * @implements IItemCountChangeNtf
         * @constructor
         * @param {CLPF.IItemCountChangeNtf=} [properties] Properties to set
         */
        function ItemCountChangeNtf(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemCountChangeNtf items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.ItemCountChangeNtf
         * @instance
         */
        ItemCountChangeNtf.prototype.items = $util.emptyArray;

        /**
         * Creates a new ItemCountChangeNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {CLPF.IItemCountChangeNtf=} [properties] Properties to set
         * @returns {CLPF.ItemCountChangeNtf} ItemCountChangeNtf instance
         */
        ItemCountChangeNtf.create = function create(properties) {
            return new ItemCountChangeNtf(properties);
        };

        /**
         * Encodes the specified ItemCountChangeNtf message. Does not implicitly {@link CLPF.ItemCountChangeNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {CLPF.IItemCountChangeNtf} message ItemCountChangeNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemCountChangeNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemCountChangeNtf message, length delimited. Does not implicitly {@link CLPF.ItemCountChangeNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {CLPF.IItemCountChangeNtf} message ItemCountChangeNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemCountChangeNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemCountChangeNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemCountChangeNtf} ItemCountChangeNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemCountChangeNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemCountChangeNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemCountChangeNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemCountChangeNtf} ItemCountChangeNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemCountChangeNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemCountChangeNtf message.
         * @function verify
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemCountChangeNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ItemCountChangeNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemCountChangeNtf} ItemCountChangeNtf
         */
        ItemCountChangeNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemCountChangeNtf)
                return object;
            var message = new $root.CLPF.ItemCountChangeNtf();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.ItemCountChangeNtf.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.ItemCountChangeNtf.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ItemCountChangeNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemCountChangeNtf
         * @static
         * @param {CLPF.ItemCountChangeNtf} message ItemCountChangeNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemCountChangeNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this ItemCountChangeNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ItemCountChangeNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemCountChangeNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemCountChangeNtf;
    })();

    CLPF.ItemBuyReq = (function() {

        /**
         * Properties of an ItemBuyReq.
         * @memberof CLPF
         * @interface IItemBuyReq
         * @property {CLPF.IItemInfo|null} [item] ItemBuyReq item
         */

        /**
         * Constructs a new ItemBuyReq.
         * @memberof CLPF
         * @classdesc Represents an ItemBuyReq.
         * @implements IItemBuyReq
         * @constructor
         * @param {CLPF.IItemBuyReq=} [properties] Properties to set
         */
        function ItemBuyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemBuyReq item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.ItemBuyReq
         * @instance
         */
        ItemBuyReq.prototype.item = null;

        /**
         * Creates a new ItemBuyReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {CLPF.IItemBuyReq=} [properties] Properties to set
         * @returns {CLPF.ItemBuyReq} ItemBuyReq instance
         */
        ItemBuyReq.create = function create(properties) {
            return new ItemBuyReq(properties);
        };

        /**
         * Encodes the specified ItemBuyReq message. Does not implicitly {@link CLPF.ItemBuyReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {CLPF.IItemBuyReq} message ItemBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemBuyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemBuyReq message, length delimited. Does not implicitly {@link CLPF.ItemBuyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {CLPF.IItemBuyReq} message ItemBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemBuyReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemBuyReq} ItemBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemBuyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemBuyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemBuyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemBuyReq} ItemBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemBuyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemBuyReq message.
         * @function verify
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemBuyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an ItemBuyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemBuyReq} ItemBuyReq
         */
        ItemBuyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemBuyReq)
                return object;
            var message = new $root.CLPF.ItemBuyReq();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.ItemBuyReq.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an ItemBuyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemBuyReq
         * @static
         * @param {CLPF.ItemBuyReq} message ItemBuyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemBuyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this ItemBuyReq to JSON.
         * @function toJSON
         * @memberof CLPF.ItemBuyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemBuyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemBuyReq;
    })();

    CLPF.ItemBuyAck = (function() {

        /**
         * Properties of an ItemBuyAck.
         * @memberof CLPF
         * @interface IItemBuyAck
         * @property {number|null} [errcode] ItemBuyAck errcode
         * @property {CLPF.IItemInfo|null} [item] ItemBuyAck item
         */

        /**
         * Constructs a new ItemBuyAck.
         * @memberof CLPF
         * @classdesc Represents an ItemBuyAck.
         * @implements IItemBuyAck
         * @constructor
         * @param {CLPF.IItemBuyAck=} [properties] Properties to set
         */
        function ItemBuyAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemBuyAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ItemBuyAck
         * @instance
         */
        ItemBuyAck.prototype.errcode = 0;

        /**
         * ItemBuyAck item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.ItemBuyAck
         * @instance
         */
        ItemBuyAck.prototype.item = null;

        /**
         * Creates a new ItemBuyAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {CLPF.IItemBuyAck=} [properties] Properties to set
         * @returns {CLPF.ItemBuyAck} ItemBuyAck instance
         */
        ItemBuyAck.create = function create(properties) {
            return new ItemBuyAck(properties);
        };

        /**
         * Encodes the specified ItemBuyAck message. Does not implicitly {@link CLPF.ItemBuyAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {CLPF.IItemBuyAck} message ItemBuyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemBuyAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemBuyAck message, length delimited. Does not implicitly {@link CLPF.ItemBuyAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {CLPF.IItemBuyAck} message ItemBuyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemBuyAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemBuyAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ItemBuyAck} ItemBuyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemBuyAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ItemBuyAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemBuyAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ItemBuyAck} ItemBuyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemBuyAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemBuyAck message.
         * @function verify
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemBuyAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an ItemBuyAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ItemBuyAck} ItemBuyAck
         */
        ItemBuyAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ItemBuyAck)
                return object;
            var message = new $root.CLPF.ItemBuyAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.ItemBuyAck.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an ItemBuyAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ItemBuyAck
         * @static
         * @param {CLPF.ItemBuyAck} message ItemBuyAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemBuyAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.item = null;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this ItemBuyAck to JSON.
         * @function toJSON
         * @memberof CLPF.ItemBuyAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemBuyAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemBuyAck;
    })();

    CLPF.RechargeReq = (function() {

        /**
         * Properties of a RechargeReq.
         * @memberof CLPF
         * @interface IRechargeReq
         * @property {number|null} [contentType] RechargeReq contentType
         * @property {number|null} [contentId] RechargeReq contentId
         * @property {number|null} [payMode] RechargeReq payMode
         * @property {string|null} [extraData] RechargeReq extraData
         * @property {string|null} [productName] RechargeReq productName
         */

        /**
         * Constructs a new RechargeReq.
         * @memberof CLPF
         * @classdesc Represents a RechargeReq.
         * @implements IRechargeReq
         * @constructor
         * @param {CLPF.IRechargeReq=} [properties] Properties to set
         */
        function RechargeReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeReq contentType.
         * @member {number} contentType
         * @memberof CLPF.RechargeReq
         * @instance
         */
        RechargeReq.prototype.contentType = 0;

        /**
         * RechargeReq contentId.
         * @member {number} contentId
         * @memberof CLPF.RechargeReq
         * @instance
         */
        RechargeReq.prototype.contentId = 0;

        /**
         * RechargeReq payMode.
         * @member {number} payMode
         * @memberof CLPF.RechargeReq
         * @instance
         */
        RechargeReq.prototype.payMode = 0;

        /**
         * RechargeReq extraData.
         * @member {string} extraData
         * @memberof CLPF.RechargeReq
         * @instance
         */
        RechargeReq.prototype.extraData = "";

        /**
         * RechargeReq productName.
         * @member {string} productName
         * @memberof CLPF.RechargeReq
         * @instance
         */
        RechargeReq.prototype.productName = "";

        /**
         * Creates a new RechargeReq instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeReq
         * @static
         * @param {CLPF.IRechargeReq=} [properties] Properties to set
         * @returns {CLPF.RechargeReq} RechargeReq instance
         */
        RechargeReq.create = function create(properties) {
            return new RechargeReq(properties);
        };

        /**
         * Encodes the specified RechargeReq message. Does not implicitly {@link CLPF.RechargeReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeReq
         * @static
         * @param {CLPF.IRechargeReq} message RechargeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contentType);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contentId);
            if (message.payMode != null && Object.hasOwnProperty.call(message, "payMode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.payMode);
            if (message.extraData != null && Object.hasOwnProperty.call(message, "extraData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.extraData);
            if (message.productName != null && Object.hasOwnProperty.call(message, "productName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.productName);
            return writer;
        };

        /**
         * Encodes the specified RechargeReq message, length delimited. Does not implicitly {@link CLPF.RechargeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeReq
         * @static
         * @param {CLPF.IRechargeReq} message RechargeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeReq} RechargeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contentType = reader.int32();
                    break;
                case 2:
                    message.contentId = reader.int32();
                    break;
                case 3:
                    message.payMode = reader.int32();
                    break;
                case 4:
                    message.extraData = reader.string();
                    break;
                case 5:
                    message.productName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeReq} RechargeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeReq message.
         * @function verify
         * @memberof CLPF.RechargeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isInteger(message.contentType))
                    return "contentType: integer expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isInteger(message.contentId))
                    return "contentId: integer expected";
            if (message.payMode != null && message.hasOwnProperty("payMode"))
                if (!$util.isInteger(message.payMode))
                    return "payMode: integer expected";
            if (message.extraData != null && message.hasOwnProperty("extraData"))
                if (!$util.isString(message.extraData))
                    return "extraData: string expected";
            if (message.productName != null && message.hasOwnProperty("productName"))
                if (!$util.isString(message.productName))
                    return "productName: string expected";
            return null;
        };

        /**
         * Creates a RechargeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeReq} RechargeReq
         */
        RechargeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeReq)
                return object;
            var message = new $root.CLPF.RechargeReq();
            if (object.contentType != null)
                message.contentType = object.contentType | 0;
            if (object.contentId != null)
                message.contentId = object.contentId | 0;
            if (object.payMode != null)
                message.payMode = object.payMode | 0;
            if (object.extraData != null)
                message.extraData = String(object.extraData);
            if (object.productName != null)
                message.productName = String(object.productName);
            return message;
        };

        /**
         * Creates a plain object from a RechargeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeReq
         * @static
         * @param {CLPF.RechargeReq} message RechargeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contentType = 0;
                object.contentId = 0;
                object.payMode = 0;
                object.extraData = "";
                object.productName = "";
            }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.payMode != null && message.hasOwnProperty("payMode"))
                object.payMode = message.payMode;
            if (message.extraData != null && message.hasOwnProperty("extraData"))
                object.extraData = message.extraData;
            if (message.productName != null && message.hasOwnProperty("productName"))
                object.productName = message.productName;
            return object;
        };

        /**
         * Converts this RechargeReq to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeReq;
    })();

    CLPF.RechargeAck = (function() {

        /**
         * Properties of a RechargeAck.
         * @memberof CLPF
         * @interface IRechargeAck
         * @property {number|null} [errcode] RechargeAck errcode
         * @property {string|null} [errmessage] RechargeAck errmessage
         * @property {string|null} [payEnvir] RechargeAck payEnvir
         */

        /**
         * Constructs a new RechargeAck.
         * @memberof CLPF
         * @classdesc Represents a RechargeAck.
         * @implements IRechargeAck
         * @constructor
         * @param {CLPF.IRechargeAck=} [properties] Properties to set
         */
        function RechargeAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeAck errcode.
         * @member {number} errcode
         * @memberof CLPF.RechargeAck
         * @instance
         */
        RechargeAck.prototype.errcode = 0;

        /**
         * RechargeAck errmessage.
         * @member {string} errmessage
         * @memberof CLPF.RechargeAck
         * @instance
         */
        RechargeAck.prototype.errmessage = "";

        /**
         * RechargeAck payEnvir.
         * @member {string} payEnvir
         * @memberof CLPF.RechargeAck
         * @instance
         */
        RechargeAck.prototype.payEnvir = "";

        /**
         * Creates a new RechargeAck instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeAck
         * @static
         * @param {CLPF.IRechargeAck=} [properties] Properties to set
         * @returns {CLPF.RechargeAck} RechargeAck instance
         */
        RechargeAck.create = function create(properties) {
            return new RechargeAck(properties);
        };

        /**
         * Encodes the specified RechargeAck message. Does not implicitly {@link CLPF.RechargeAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeAck
         * @static
         * @param {CLPF.IRechargeAck} message RechargeAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.payEnvir != null && Object.hasOwnProperty.call(message, "payEnvir"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.payEnvir);
            if (message.errmessage != null && Object.hasOwnProperty.call(message, "errmessage"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.errmessage);
            return writer;
        };

        /**
         * Encodes the specified RechargeAck message, length delimited. Does not implicitly {@link CLPF.RechargeAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeAck
         * @static
         * @param {CLPF.IRechargeAck} message RechargeAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeAck} RechargeAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 3:
                    message.errmessage = reader.string();
                    break;
                case 2:
                    message.payEnvir = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeAck} RechargeAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeAck message.
         * @function verify
         * @memberof CLPF.RechargeAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                if (!$util.isString(message.errmessage))
                    return "errmessage: string expected";
            if (message.payEnvir != null && message.hasOwnProperty("payEnvir"))
                if (!$util.isString(message.payEnvir))
                    return "payEnvir: string expected";
            return null;
        };

        /**
         * Creates a RechargeAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeAck} RechargeAck
         */
        RechargeAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeAck)
                return object;
            var message = new $root.CLPF.RechargeAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.errmessage != null)
                message.errmessage = String(object.errmessage);
            if (object.payEnvir != null)
                message.payEnvir = String(object.payEnvir);
            return message;
        };

        /**
         * Creates a plain object from a RechargeAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeAck
         * @static
         * @param {CLPF.RechargeAck} message RechargeAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.payEnvir = "";
                object.errmessage = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.payEnvir != null && message.hasOwnProperty("payEnvir"))
                object.payEnvir = message.payEnvir;
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                object.errmessage = message.errmessage;
            return object;
        };

        /**
         * Converts this RechargeAck to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeAck;
    })();

    CLPF.RechargeSuccessNtf = (function() {

        /**
         * Properties of a RechargeSuccessNtf.
         * @memberof CLPF
         * @interface IRechargeSuccessNtf
         * @property {number|null} [contentType] RechargeSuccessNtf contentType
         * @property {number|null} [contentId] RechargeSuccessNtf contentId
         * @property {Array.<CLPF.IItemInfo>|null} [items] RechargeSuccessNtf items
         */

        /**
         * Constructs a new RechargeSuccessNtf.
         * @memberof CLPF
         * @classdesc Represents a RechargeSuccessNtf.
         * @implements IRechargeSuccessNtf
         * @constructor
         * @param {CLPF.IRechargeSuccessNtf=} [properties] Properties to set
         */
        function RechargeSuccessNtf(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeSuccessNtf contentType.
         * @member {number} contentType
         * @memberof CLPF.RechargeSuccessNtf
         * @instance
         */
        RechargeSuccessNtf.prototype.contentType = 0;

        /**
         * RechargeSuccessNtf contentId.
         * @member {number} contentId
         * @memberof CLPF.RechargeSuccessNtf
         * @instance
         */
        RechargeSuccessNtf.prototype.contentId = 0;

        /**
         * RechargeSuccessNtf items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.RechargeSuccessNtf
         * @instance
         */
        RechargeSuccessNtf.prototype.items = $util.emptyArray;

        /**
         * Creates a new RechargeSuccessNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {CLPF.IRechargeSuccessNtf=} [properties] Properties to set
         * @returns {CLPF.RechargeSuccessNtf} RechargeSuccessNtf instance
         */
        RechargeSuccessNtf.create = function create(properties) {
            return new RechargeSuccessNtf(properties);
        };

        /**
         * Encodes the specified RechargeSuccessNtf message. Does not implicitly {@link CLPF.RechargeSuccessNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {CLPF.IRechargeSuccessNtf} message RechargeSuccessNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeSuccessNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contentType);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contentId);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RechargeSuccessNtf message, length delimited. Does not implicitly {@link CLPF.RechargeSuccessNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {CLPF.IRechargeSuccessNtf} message RechargeSuccessNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeSuccessNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeSuccessNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeSuccessNtf} RechargeSuccessNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeSuccessNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeSuccessNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contentType = reader.int32();
                    break;
                case 2:
                    message.contentId = reader.int32();
                    break;
                case 3:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeSuccessNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeSuccessNtf} RechargeSuccessNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeSuccessNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeSuccessNtf message.
         * @function verify
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeSuccessNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isInteger(message.contentType))
                    return "contentType: integer expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isInteger(message.contentId))
                    return "contentId: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RechargeSuccessNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeSuccessNtf} RechargeSuccessNtf
         */
        RechargeSuccessNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeSuccessNtf)
                return object;
            var message = new $root.CLPF.RechargeSuccessNtf();
            if (object.contentType != null)
                message.contentType = object.contentType | 0;
            if (object.contentId != null)
                message.contentId = object.contentId | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.RechargeSuccessNtf.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.RechargeSuccessNtf.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RechargeSuccessNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeSuccessNtf
         * @static
         * @param {CLPF.RechargeSuccessNtf} message RechargeSuccessNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeSuccessNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.contentType = 0;
                object.contentId = 0;
            }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this RechargeSuccessNtf to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeSuccessNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeSuccessNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeSuccessNtf;
    })();

    CLPF.RechargeOrder = (function() {

        /**
         * Properties of a RechargeOrder.
         * @memberof CLPF
         * @interface IRechargeOrder
         * @property {string|null} [orderNo] RechargeOrder orderNo
         * @property {number|null} [orderType] RechargeOrder orderType
         * @property {number|null} [orderAmount] RechargeOrder orderAmount
         * @property {number|null} [contentType] RechargeOrder contentType
         * @property {number|null} [contentId] RechargeOrder contentId
         * @property {number|null} [orderState] RechargeOrder orderState
         * @property {number|null} [createTime] RechargeOrder createTime
         * @property {number|null} [finishTime] RechargeOrder finishTime
         * @property {number|null} [evaluateStar] RechargeOrder evaluateStar
         */

        /**
         * Constructs a new RechargeOrder.
         * @memberof CLPF
         * @classdesc Represents a RechargeOrder.
         * @implements IRechargeOrder
         * @constructor
         * @param {CLPF.IRechargeOrder=} [properties] Properties to set
         */
        function RechargeOrder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeOrder orderNo.
         * @member {string} orderNo
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.orderNo = "";

        /**
         * RechargeOrder orderType.
         * @member {number} orderType
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.orderType = 0;

        /**
         * RechargeOrder orderAmount.
         * @member {number} orderAmount
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.orderAmount = 0;

        /**
         * RechargeOrder contentType.
         * @member {number} contentType
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.contentType = 0;

        /**
         * RechargeOrder contentId.
         * @member {number} contentId
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.contentId = 0;

        /**
         * RechargeOrder orderState.
         * @member {number} orderState
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.orderState = 0;

        /**
         * RechargeOrder createTime.
         * @member {number} createTime
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.createTime = 0;

        /**
         * RechargeOrder finishTime.
         * @member {number} finishTime
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.finishTime = 0;

        /**
         * RechargeOrder evaluateStar.
         * @member {number} evaluateStar
         * @memberof CLPF.RechargeOrder
         * @instance
         */
        RechargeOrder.prototype.evaluateStar = 0;

        /**
         * Creates a new RechargeOrder instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {CLPF.IRechargeOrder=} [properties] Properties to set
         * @returns {CLPF.RechargeOrder} RechargeOrder instance
         */
        RechargeOrder.create = function create(properties) {
            return new RechargeOrder(properties);
        };

        /**
         * Encodes the specified RechargeOrder message. Does not implicitly {@link CLPF.RechargeOrder.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {CLPF.IRechargeOrder} message RechargeOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderNo != null && Object.hasOwnProperty.call(message, "orderNo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderNo);
            if (message.orderType != null && Object.hasOwnProperty.call(message, "orderType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            if (message.orderAmount != null && Object.hasOwnProperty.call(message, "orderAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orderAmount);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentType);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.contentId);
            if (message.orderState != null && Object.hasOwnProperty.call(message, "orderState"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.orderState);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.createTime);
            if (message.finishTime != null && Object.hasOwnProperty.call(message, "finishTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.finishTime);
            if (message.evaluateStar != null && Object.hasOwnProperty.call(message, "evaluateStar"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.evaluateStar);
            return writer;
        };

        /**
         * Encodes the specified RechargeOrder message, length delimited. Does not implicitly {@link CLPF.RechargeOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {CLPF.IRechargeOrder} message RechargeOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeOrder message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeOrder} RechargeOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderNo = reader.string();
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.orderAmount = reader.int32();
                    break;
                case 4:
                    message.contentType = reader.int32();
                    break;
                case 5:
                    message.contentId = reader.int32();
                    break;
                case 6:
                    message.orderState = reader.int32();
                    break;
                case 7:
                    message.createTime = reader.uint32();
                    break;
                case 8:
                    message.finishTime = reader.uint32();
                    break;
                case 9:
                    message.evaluateStar = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeOrder} RechargeOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeOrder message.
         * @function verify
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderNo != null && message.hasOwnProperty("orderNo"))
                if (!$util.isString(message.orderNo))
                    return "orderNo: string expected";
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                if (!$util.isInteger(message.orderType))
                    return "orderType: integer expected";
            if (message.orderAmount != null && message.hasOwnProperty("orderAmount"))
                if (!$util.isInteger(message.orderAmount))
                    return "orderAmount: integer expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isInteger(message.contentType))
                    return "contentType: integer expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isInteger(message.contentId))
                    return "contentId: integer expected";
            if (message.orderState != null && message.hasOwnProperty("orderState"))
                if (!$util.isInteger(message.orderState))
                    return "orderState: integer expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime))
                    return "createTime: integer expected";
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                if (!$util.isInteger(message.finishTime))
                    return "finishTime: integer expected";
            if (message.evaluateStar != null && message.hasOwnProperty("evaluateStar"))
                if (!$util.isInteger(message.evaluateStar))
                    return "evaluateStar: integer expected";
            return null;
        };

        /**
         * Creates a RechargeOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeOrder} RechargeOrder
         */
        RechargeOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeOrder)
                return object;
            var message = new $root.CLPF.RechargeOrder();
            if (object.orderNo != null)
                message.orderNo = String(object.orderNo);
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.orderAmount != null)
                message.orderAmount = object.orderAmount | 0;
            if (object.contentType != null)
                message.contentType = object.contentType | 0;
            if (object.contentId != null)
                message.contentId = object.contentId | 0;
            if (object.orderState != null)
                message.orderState = object.orderState | 0;
            if (object.createTime != null)
                message.createTime = object.createTime >>> 0;
            if (object.finishTime != null)
                message.finishTime = object.finishTime >>> 0;
            if (object.evaluateStar != null)
                message.evaluateStar = object.evaluateStar | 0;
            return message;
        };

        /**
         * Creates a plain object from a RechargeOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeOrder
         * @static
         * @param {CLPF.RechargeOrder} message RechargeOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.orderNo = "";
                object.orderType = 0;
                object.orderAmount = 0;
                object.contentType = 0;
                object.contentId = 0;
                object.orderState = 0;
                object.createTime = 0;
                object.finishTime = 0;
                object.evaluateStar = 0;
            }
            if (message.orderNo != null && message.hasOwnProperty("orderNo"))
                object.orderNo = message.orderNo;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.orderAmount != null && message.hasOwnProperty("orderAmount"))
                object.orderAmount = message.orderAmount;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.orderState != null && message.hasOwnProperty("orderState"))
                object.orderState = message.orderState;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                object.finishTime = message.finishTime;
            if (message.evaluateStar != null && message.hasOwnProperty("evaluateStar"))
                object.evaluateStar = message.evaluateStar;
            return object;
        };

        /**
         * Converts this RechargeOrder to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeOrder;
    })();

    CLPF.RechargeOrderQueryListReq = (function() {

        /**
         * Properties of a RechargeOrderQueryListReq.
         * @memberof CLPF
         * @interface IRechargeOrderQueryListReq
         */

        /**
         * Constructs a new RechargeOrderQueryListReq.
         * @memberof CLPF
         * @classdesc Represents a RechargeOrderQueryListReq.
         * @implements IRechargeOrderQueryListReq
         * @constructor
         * @param {CLPF.IRechargeOrderQueryListReq=} [properties] Properties to set
         */
        function RechargeOrderQueryListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RechargeOrderQueryListReq instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {CLPF.IRechargeOrderQueryListReq=} [properties] Properties to set
         * @returns {CLPF.RechargeOrderQueryListReq} RechargeOrderQueryListReq instance
         */
        RechargeOrderQueryListReq.create = function create(properties) {
            return new RechargeOrderQueryListReq(properties);
        };

        /**
         * Encodes the specified RechargeOrderQueryListReq message. Does not implicitly {@link CLPF.RechargeOrderQueryListReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {CLPF.IRechargeOrderQueryListReq} message RechargeOrderQueryListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderQueryListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RechargeOrderQueryListReq message, length delimited. Does not implicitly {@link CLPF.RechargeOrderQueryListReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {CLPF.IRechargeOrderQueryListReq} message RechargeOrderQueryListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderQueryListReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeOrderQueryListReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeOrderQueryListReq} RechargeOrderQueryListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderQueryListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeOrderQueryListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeOrderQueryListReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeOrderQueryListReq} RechargeOrderQueryListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderQueryListReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeOrderQueryListReq message.
         * @function verify
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeOrderQueryListReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RechargeOrderQueryListReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeOrderQueryListReq} RechargeOrderQueryListReq
         */
        RechargeOrderQueryListReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeOrderQueryListReq)
                return object;
            return new $root.CLPF.RechargeOrderQueryListReq();
        };

        /**
         * Creates a plain object from a RechargeOrderQueryListReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeOrderQueryListReq
         * @static
         * @param {CLPF.RechargeOrderQueryListReq} message RechargeOrderQueryListReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeOrderQueryListReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RechargeOrderQueryListReq to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeOrderQueryListReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeOrderQueryListReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeOrderQueryListReq;
    })();

    CLPF.RechargeOrderQueryListAck = (function() {

        /**
         * Properties of a RechargeOrderQueryListAck.
         * @memberof CLPF
         * @interface IRechargeOrderQueryListAck
         * @property {number|null} [errcode] RechargeOrderQueryListAck errcode
         * @property {Array.<CLPF.IRechargeOrder>|null} [orders] RechargeOrderQueryListAck orders
         */

        /**
         * Constructs a new RechargeOrderQueryListAck.
         * @memberof CLPF
         * @classdesc Represents a RechargeOrderQueryListAck.
         * @implements IRechargeOrderQueryListAck
         * @constructor
         * @param {CLPF.IRechargeOrderQueryListAck=} [properties] Properties to set
         */
        function RechargeOrderQueryListAck(properties) {
            this.orders = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeOrderQueryListAck errcode.
         * @member {number} errcode
         * @memberof CLPF.RechargeOrderQueryListAck
         * @instance
         */
        RechargeOrderQueryListAck.prototype.errcode = 0;

        /**
         * RechargeOrderQueryListAck orders.
         * @member {Array.<CLPF.IRechargeOrder>} orders
         * @memberof CLPF.RechargeOrderQueryListAck
         * @instance
         */
        RechargeOrderQueryListAck.prototype.orders = $util.emptyArray;

        /**
         * Creates a new RechargeOrderQueryListAck instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {CLPF.IRechargeOrderQueryListAck=} [properties] Properties to set
         * @returns {CLPF.RechargeOrderQueryListAck} RechargeOrderQueryListAck instance
         */
        RechargeOrderQueryListAck.create = function create(properties) {
            return new RechargeOrderQueryListAck(properties);
        };

        /**
         * Encodes the specified RechargeOrderQueryListAck message. Does not implicitly {@link CLPF.RechargeOrderQueryListAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {CLPF.IRechargeOrderQueryListAck} message RechargeOrderQueryListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderQueryListAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.orders != null && message.orders.length)
                for (var i = 0; i < message.orders.length; ++i)
                    $root.CLPF.RechargeOrder.encode(message.orders[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RechargeOrderQueryListAck message, length delimited. Does not implicitly {@link CLPF.RechargeOrderQueryListAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {CLPF.IRechargeOrderQueryListAck} message RechargeOrderQueryListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderQueryListAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeOrderQueryListAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeOrderQueryListAck} RechargeOrderQueryListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderQueryListAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeOrderQueryListAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.orders && message.orders.length))
                        message.orders = [];
                    message.orders.push($root.CLPF.RechargeOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeOrderQueryListAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeOrderQueryListAck} RechargeOrderQueryListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderQueryListAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeOrderQueryListAck message.
         * @function verify
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeOrderQueryListAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.orders != null && message.hasOwnProperty("orders")) {
                if (!Array.isArray(message.orders))
                    return "orders: array expected";
                for (var i = 0; i < message.orders.length; ++i) {
                    var error = $root.CLPF.RechargeOrder.verify(message.orders[i]);
                    if (error)
                        return "orders." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RechargeOrderQueryListAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeOrderQueryListAck} RechargeOrderQueryListAck
         */
        RechargeOrderQueryListAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeOrderQueryListAck)
                return object;
            var message = new $root.CLPF.RechargeOrderQueryListAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.orders) {
                if (!Array.isArray(object.orders))
                    throw TypeError(".CLPF.RechargeOrderQueryListAck.orders: array expected");
                message.orders = [];
                for (var i = 0; i < object.orders.length; ++i) {
                    if (typeof object.orders[i] !== "object")
                        throw TypeError(".CLPF.RechargeOrderQueryListAck.orders: object expected");
                    message.orders[i] = $root.CLPF.RechargeOrder.fromObject(object.orders[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RechargeOrderQueryListAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeOrderQueryListAck
         * @static
         * @param {CLPF.RechargeOrderQueryListAck} message RechargeOrderQueryListAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeOrderQueryListAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orders = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.orders && message.orders.length) {
                object.orders = [];
                for (var j = 0; j < message.orders.length; ++j)
                    object.orders[j] = $root.CLPF.RechargeOrder.toObject(message.orders[j], options);
            }
            return object;
        };

        /**
         * Converts this RechargeOrderQueryListAck to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeOrderQueryListAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeOrderQueryListAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeOrderQueryListAck;
    })();

    CLPF.RechargeOrderEvaluateReq = (function() {

        /**
         * Properties of a RechargeOrderEvaluateReq.
         * @memberof CLPF
         * @interface IRechargeOrderEvaluateReq
         * @property {string|null} [orderNo] RechargeOrderEvaluateReq orderNo
         * @property {number|null} [star] RechargeOrderEvaluateReq star
         * @property {string|null} [content] RechargeOrderEvaluateReq content
         */

        /**
         * Constructs a new RechargeOrderEvaluateReq.
         * @memberof CLPF
         * @classdesc Represents a RechargeOrderEvaluateReq.
         * @implements IRechargeOrderEvaluateReq
         * @constructor
         * @param {CLPF.IRechargeOrderEvaluateReq=} [properties] Properties to set
         */
        function RechargeOrderEvaluateReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeOrderEvaluateReq orderNo.
         * @member {string} orderNo
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @instance
         */
        RechargeOrderEvaluateReq.prototype.orderNo = "";

        /**
         * RechargeOrderEvaluateReq star.
         * @member {number} star
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @instance
         */
        RechargeOrderEvaluateReq.prototype.star = 0;

        /**
         * RechargeOrderEvaluateReq content.
         * @member {string} content
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @instance
         */
        RechargeOrderEvaluateReq.prototype.content = "";

        /**
         * Creates a new RechargeOrderEvaluateReq instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {CLPF.IRechargeOrderEvaluateReq=} [properties] Properties to set
         * @returns {CLPF.RechargeOrderEvaluateReq} RechargeOrderEvaluateReq instance
         */
        RechargeOrderEvaluateReq.create = function create(properties) {
            return new RechargeOrderEvaluateReq(properties);
        };

        /**
         * Encodes the specified RechargeOrderEvaluateReq message. Does not implicitly {@link CLPF.RechargeOrderEvaluateReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {CLPF.IRechargeOrderEvaluateReq} message RechargeOrderEvaluateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderEvaluateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderNo != null && Object.hasOwnProperty.call(message, "orderNo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderNo);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.star);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified RechargeOrderEvaluateReq message, length delimited. Does not implicitly {@link CLPF.RechargeOrderEvaluateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {CLPF.IRechargeOrderEvaluateReq} message RechargeOrderEvaluateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderEvaluateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeOrderEvaluateReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeOrderEvaluateReq} RechargeOrderEvaluateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderEvaluateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeOrderEvaluateReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderNo = reader.string();
                    break;
                case 2:
                    message.star = reader.int32();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeOrderEvaluateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeOrderEvaluateReq} RechargeOrderEvaluateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderEvaluateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeOrderEvaluateReq message.
         * @function verify
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeOrderEvaluateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderNo != null && message.hasOwnProperty("orderNo"))
                if (!$util.isString(message.orderNo))
                    return "orderNo: string expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a RechargeOrderEvaluateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeOrderEvaluateReq} RechargeOrderEvaluateReq
         */
        RechargeOrderEvaluateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeOrderEvaluateReq)
                return object;
            var message = new $root.CLPF.RechargeOrderEvaluateReq();
            if (object.orderNo != null)
                message.orderNo = String(object.orderNo);
            if (object.star != null)
                message.star = object.star | 0;
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a RechargeOrderEvaluateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @static
         * @param {CLPF.RechargeOrderEvaluateReq} message RechargeOrderEvaluateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeOrderEvaluateReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.orderNo = "";
                object.star = 0;
                object.content = "";
            }
            if (message.orderNo != null && message.hasOwnProperty("orderNo"))
                object.orderNo = message.orderNo;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this RechargeOrderEvaluateReq to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeOrderEvaluateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeOrderEvaluateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeOrderEvaluateReq;
    })();

    CLPF.RechargeOrderEvaluateAck = (function() {

        /**
         * Properties of a RechargeOrderEvaluateAck.
         * @memberof CLPF
         * @interface IRechargeOrderEvaluateAck
         * @property {number|null} [errcode] RechargeOrderEvaluateAck errcode
         */

        /**
         * Constructs a new RechargeOrderEvaluateAck.
         * @memberof CLPF
         * @classdesc Represents a RechargeOrderEvaluateAck.
         * @implements IRechargeOrderEvaluateAck
         * @constructor
         * @param {CLPF.IRechargeOrderEvaluateAck=} [properties] Properties to set
         */
        function RechargeOrderEvaluateAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeOrderEvaluateAck errcode.
         * @member {number} errcode
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @instance
         */
        RechargeOrderEvaluateAck.prototype.errcode = 0;

        /**
         * Creates a new RechargeOrderEvaluateAck instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {CLPF.IRechargeOrderEvaluateAck=} [properties] Properties to set
         * @returns {CLPF.RechargeOrderEvaluateAck} RechargeOrderEvaluateAck instance
         */
        RechargeOrderEvaluateAck.create = function create(properties) {
            return new RechargeOrderEvaluateAck(properties);
        };

        /**
         * Encodes the specified RechargeOrderEvaluateAck message. Does not implicitly {@link CLPF.RechargeOrderEvaluateAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {CLPF.IRechargeOrderEvaluateAck} message RechargeOrderEvaluateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderEvaluateAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified RechargeOrderEvaluateAck message, length delimited. Does not implicitly {@link CLPF.RechargeOrderEvaluateAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {CLPF.IRechargeOrderEvaluateAck} message RechargeOrderEvaluateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeOrderEvaluateAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeOrderEvaluateAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeOrderEvaluateAck} RechargeOrderEvaluateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderEvaluateAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeOrderEvaluateAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeOrderEvaluateAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeOrderEvaluateAck} RechargeOrderEvaluateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeOrderEvaluateAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeOrderEvaluateAck message.
         * @function verify
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeOrderEvaluateAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a RechargeOrderEvaluateAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeOrderEvaluateAck} RechargeOrderEvaluateAck
         */
        RechargeOrderEvaluateAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeOrderEvaluateAck)
                return object;
            var message = new $root.CLPF.RechargeOrderEvaluateAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a RechargeOrderEvaluateAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @static
         * @param {CLPF.RechargeOrderEvaluateAck} message RechargeOrderEvaluateAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeOrderEvaluateAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this RechargeOrderEvaluateAck to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeOrderEvaluateAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeOrderEvaluateAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeOrderEvaluateAck;
    })();

    CLPF.RechargeAgentComplainReq = (function() {

        /**
         * Properties of a RechargeAgentComplainReq.
         * @memberof CLPF
         * @interface IRechargeAgentComplainReq
         * @property {string|null} [agentInfo] RechargeAgentComplainReq agentInfo
         * @property {string|null} [content] RechargeAgentComplainReq content
         */

        /**
         * Constructs a new RechargeAgentComplainReq.
         * @memberof CLPF
         * @classdesc Represents a RechargeAgentComplainReq.
         * @implements IRechargeAgentComplainReq
         * @constructor
         * @param {CLPF.IRechargeAgentComplainReq=} [properties] Properties to set
         */
        function RechargeAgentComplainReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeAgentComplainReq agentInfo.
         * @member {string} agentInfo
         * @memberof CLPF.RechargeAgentComplainReq
         * @instance
         */
        RechargeAgentComplainReq.prototype.agentInfo = "";

        /**
         * RechargeAgentComplainReq content.
         * @member {string} content
         * @memberof CLPF.RechargeAgentComplainReq
         * @instance
         */
        RechargeAgentComplainReq.prototype.content = "";

        /**
         * Creates a new RechargeAgentComplainReq instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {CLPF.IRechargeAgentComplainReq=} [properties] Properties to set
         * @returns {CLPF.RechargeAgentComplainReq} RechargeAgentComplainReq instance
         */
        RechargeAgentComplainReq.create = function create(properties) {
            return new RechargeAgentComplainReq(properties);
        };

        /**
         * Encodes the specified RechargeAgentComplainReq message. Does not implicitly {@link CLPF.RechargeAgentComplainReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {CLPF.IRechargeAgentComplainReq} message RechargeAgentComplainReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAgentComplainReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.agentInfo != null && Object.hasOwnProperty.call(message, "agentInfo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.agentInfo);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified RechargeAgentComplainReq message, length delimited. Does not implicitly {@link CLPF.RechargeAgentComplainReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {CLPF.IRechargeAgentComplainReq} message RechargeAgentComplainReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAgentComplainReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeAgentComplainReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeAgentComplainReq} RechargeAgentComplainReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAgentComplainReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeAgentComplainReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.agentInfo = reader.string();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeAgentComplainReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeAgentComplainReq} RechargeAgentComplainReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAgentComplainReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeAgentComplainReq message.
         * @function verify
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeAgentComplainReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.agentInfo != null && message.hasOwnProperty("agentInfo"))
                if (!$util.isString(message.agentInfo))
                    return "agentInfo: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a RechargeAgentComplainReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeAgentComplainReq} RechargeAgentComplainReq
         */
        RechargeAgentComplainReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeAgentComplainReq)
                return object;
            var message = new $root.CLPF.RechargeAgentComplainReq();
            if (object.agentInfo != null)
                message.agentInfo = String(object.agentInfo);
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a RechargeAgentComplainReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeAgentComplainReq
         * @static
         * @param {CLPF.RechargeAgentComplainReq} message RechargeAgentComplainReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeAgentComplainReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.agentInfo = "";
                object.content = "";
            }
            if (message.agentInfo != null && message.hasOwnProperty("agentInfo"))
                object.agentInfo = message.agentInfo;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this RechargeAgentComplainReq to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeAgentComplainReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeAgentComplainReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeAgentComplainReq;
    })();

    CLPF.RechargeAgentComplainAck = (function() {

        /**
         * Properties of a RechargeAgentComplainAck.
         * @memberof CLPF
         * @interface IRechargeAgentComplainAck
         * @property {number|null} [errcode] RechargeAgentComplainAck errcode
         */

        /**
         * Constructs a new RechargeAgentComplainAck.
         * @memberof CLPF
         * @classdesc Represents a RechargeAgentComplainAck.
         * @implements IRechargeAgentComplainAck
         * @constructor
         * @param {CLPF.IRechargeAgentComplainAck=} [properties] Properties to set
         */
        function RechargeAgentComplainAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeAgentComplainAck errcode.
         * @member {number} errcode
         * @memberof CLPF.RechargeAgentComplainAck
         * @instance
         */
        RechargeAgentComplainAck.prototype.errcode = 0;

        /**
         * Creates a new RechargeAgentComplainAck instance using the specified properties.
         * @function create
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {CLPF.IRechargeAgentComplainAck=} [properties] Properties to set
         * @returns {CLPF.RechargeAgentComplainAck} RechargeAgentComplainAck instance
         */
        RechargeAgentComplainAck.create = function create(properties) {
            return new RechargeAgentComplainAck(properties);
        };

        /**
         * Encodes the specified RechargeAgentComplainAck message. Does not implicitly {@link CLPF.RechargeAgentComplainAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {CLPF.IRechargeAgentComplainAck} message RechargeAgentComplainAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAgentComplainAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified RechargeAgentComplainAck message, length delimited. Does not implicitly {@link CLPF.RechargeAgentComplainAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {CLPF.IRechargeAgentComplainAck} message RechargeAgentComplainAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeAgentComplainAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeAgentComplainAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RechargeAgentComplainAck} RechargeAgentComplainAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAgentComplainAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RechargeAgentComplainAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeAgentComplainAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RechargeAgentComplainAck} RechargeAgentComplainAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeAgentComplainAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeAgentComplainAck message.
         * @function verify
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeAgentComplainAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a RechargeAgentComplainAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RechargeAgentComplainAck} RechargeAgentComplainAck
         */
        RechargeAgentComplainAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RechargeAgentComplainAck)
                return object;
            var message = new $root.CLPF.RechargeAgentComplainAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a RechargeAgentComplainAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RechargeAgentComplainAck
         * @static
         * @param {CLPF.RechargeAgentComplainAck} message RechargeAgentComplainAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeAgentComplainAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this RechargeAgentComplainAck to JSON.
         * @function toJSON
         * @memberof CLPF.RechargeAgentComplainAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeAgentComplainAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeAgentComplainAck;
    })();

    CLPF.RankPlayerInfo = (function() {

        /**
         * Properties of a RankPlayerInfo.
         * @memberof CLPF
         * @interface IRankPlayerInfo
         * @property {string|null} [userGuid] RankPlayerInfo userGuid
         * @property {number|null} [userId] RankPlayerInfo userId
         * @property {string|null} [nickname] RankPlayerInfo nickname
         * @property {number|null} [gender] RankPlayerInfo gender
         * @property {number|null} [head] RankPlayerInfo head
         * @property {number|null} [headFrame] RankPlayerInfo headFrame
         * @property {number|null} [level] RankPlayerInfo level
         * @property {number|null} [vipLevel] RankPlayerInfo vipLevel
         * @property {number|Long|null} [rankValue] RankPlayerInfo rankValue
         */

        /**
         * Constructs a new RankPlayerInfo.
         * @memberof CLPF
         * @classdesc Represents a RankPlayerInfo.
         * @implements IRankPlayerInfo
         * @constructor
         * @param {CLPF.IRankPlayerInfo=} [properties] Properties to set
         */
        function RankPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankPlayerInfo userGuid.
         * @member {string} userGuid
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.userGuid = "";

        /**
         * RankPlayerInfo userId.
         * @member {number} userId
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.userId = 0;

        /**
         * RankPlayerInfo nickname.
         * @member {string} nickname
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.nickname = "";

        /**
         * RankPlayerInfo gender.
         * @member {number} gender
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.gender = 0;

        /**
         * RankPlayerInfo head.
         * @member {number} head
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.head = 0;

        /**
         * RankPlayerInfo headFrame.
         * @member {number} headFrame
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.headFrame = 0;

        /**
         * RankPlayerInfo level.
         * @member {number} level
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.level = 0;

        /**
         * RankPlayerInfo vipLevel.
         * @member {number} vipLevel
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.vipLevel = 0;

        /**
         * RankPlayerInfo rankValue.
         * @member {number|Long} rankValue
         * @memberof CLPF.RankPlayerInfo
         * @instance
         */
        RankPlayerInfo.prototype.rankValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RankPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {CLPF.IRankPlayerInfo=} [properties] Properties to set
         * @returns {CLPF.RankPlayerInfo} RankPlayerInfo instance
         */
        RankPlayerInfo.create = function create(properties) {
            return new RankPlayerInfo(properties);
        };

        /**
         * Encodes the specified RankPlayerInfo message. Does not implicitly {@link CLPF.RankPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {CLPF.IRankPlayerInfo} message RankPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userGuid != null && Object.hasOwnProperty.call(message, "userGuid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userGuid);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.gender);
            if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.head);
            if (message.headFrame != null && Object.hasOwnProperty.call(message, "headFrame"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.headFrame);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.level);
            if (message.vipLevel != null && Object.hasOwnProperty.call(message, "vipLevel"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.vipLevel);
            if (message.rankValue != null && Object.hasOwnProperty.call(message, "rankValue"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.rankValue);
            return writer;
        };

        /**
         * Encodes the specified RankPlayerInfo message, length delimited. Does not implicitly {@link CLPF.RankPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {CLPF.IRankPlayerInfo} message RankPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RankPlayerInfo} RankPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RankPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userGuid = reader.string();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                case 3:
                    message.nickname = reader.string();
                    break;
                case 4:
                    message.gender = reader.int32();
                    break;
                case 5:
                    message.head = reader.int32();
                    break;
                case 6:
                    message.headFrame = reader.int32();
                    break;
                case 7:
                    message.level = reader.int32();
                    break;
                case 8:
                    message.vipLevel = reader.int32();
                    break;
                case 9:
                    message.rankValue = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RankPlayerInfo} RankPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankPlayerInfo message.
         * @function verify
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userGuid != null && message.hasOwnProperty("userGuid"))
                if (!$util.isString(message.userGuid))
                    return "userGuid: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.head != null && message.hasOwnProperty("head"))
                if (!$util.isInteger(message.head))
                    return "head: integer expected";
            if (message.headFrame != null && message.hasOwnProperty("headFrame"))
                if (!$util.isInteger(message.headFrame))
                    return "headFrame: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                if (!$util.isInteger(message.vipLevel))
                    return "vipLevel: integer expected";
            if (message.rankValue != null && message.hasOwnProperty("rankValue"))
                if (!$util.isInteger(message.rankValue) && !(message.rankValue && $util.isInteger(message.rankValue.low) && $util.isInteger(message.rankValue.high)))
                    return "rankValue: integer|Long expected";
            return null;
        };

        /**
         * Creates a RankPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RankPlayerInfo} RankPlayerInfo
         */
        RankPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RankPlayerInfo)
                return object;
            var message = new $root.CLPF.RankPlayerInfo();
            if (object.userGuid != null)
                message.userGuid = String(object.userGuid);
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.gender != null)
                message.gender = object.gender | 0;
            if (object.head != null)
                message.head = object.head | 0;
            if (object.headFrame != null)
                message.headFrame = object.headFrame | 0;
            if (object.level != null)
                message.level = object.level | 0;
            if (object.vipLevel != null)
                message.vipLevel = object.vipLevel | 0;
            if (object.rankValue != null)
                if ($util.Long)
                    (message.rankValue = $util.Long.fromValue(object.rankValue)).unsigned = false;
                else if (typeof object.rankValue === "string")
                    message.rankValue = parseInt(object.rankValue, 10);
                else if (typeof object.rankValue === "number")
                    message.rankValue = object.rankValue;
                else if (typeof object.rankValue === "object")
                    message.rankValue = new $util.LongBits(object.rankValue.low >>> 0, object.rankValue.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RankPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RankPlayerInfo
         * @static
         * @param {CLPF.RankPlayerInfo} message RankPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RankPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.userGuid = "";
                object.userId = 0;
                object.nickname = "";
                object.gender = 0;
                object.head = 0;
                object.headFrame = 0;
                object.level = 0;
                object.vipLevel = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rankValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rankValue = options.longs === String ? "0" : 0;
            }
            if (message.userGuid != null && message.hasOwnProperty("userGuid"))
                object.userGuid = message.userGuid;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.head != null && message.hasOwnProperty("head"))
                object.head = message.head;
            if (message.headFrame != null && message.hasOwnProperty("headFrame"))
                object.headFrame = message.headFrame;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                object.vipLevel = message.vipLevel;
            if (message.rankValue != null && message.hasOwnProperty("rankValue"))
                if (typeof message.rankValue === "number")
                    object.rankValue = options.longs === String ? String(message.rankValue) : message.rankValue;
                else
                    object.rankValue = options.longs === String ? $util.Long.prototype.toString.call(message.rankValue) : options.longs === Number ? new $util.LongBits(message.rankValue.low >>> 0, message.rankValue.high >>> 0).toNumber() : message.rankValue;
            return object;
        };

        /**
         * Converts this RankPlayerInfo to JSON.
         * @function toJSON
         * @memberof CLPF.RankPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RankPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RankPlayerInfo;
    })();

    CLPF.GetRankListReq = (function() {

        /**
         * Properties of a GetRankListReq.
         * @memberof CLPF
         * @interface IGetRankListReq
         * @property {number|null} [rankType] GetRankListReq rankType
         */

        /**
         * Constructs a new GetRankListReq.
         * @memberof CLPF
         * @classdesc Represents a GetRankListReq.
         * @implements IGetRankListReq
         * @constructor
         * @param {CLPF.IGetRankListReq=} [properties] Properties to set
         */
        function GetRankListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankListReq rankType.
         * @member {number} rankType
         * @memberof CLPF.GetRankListReq
         * @instance
         */
        GetRankListReq.prototype.rankType = 0;

        /**
         * Creates a new GetRankListReq instance using the specified properties.
         * @function create
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {CLPF.IGetRankListReq=} [properties] Properties to set
         * @returns {CLPF.GetRankListReq} GetRankListReq instance
         */
        GetRankListReq.create = function create(properties) {
            return new GetRankListReq(properties);
        };

        /**
         * Encodes the specified GetRankListReq message. Does not implicitly {@link CLPF.GetRankListReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {CLPF.IGetRankListReq} message GetRankListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && Object.hasOwnProperty.call(message, "rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Encodes the specified GetRankListReq message, length delimited. Does not implicitly {@link CLPF.GetRankListReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {CLPF.IGetRankListReq} message GetRankListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankListReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GetRankListReq} GetRankListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GetRankListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankListReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GetRankListReq} GetRankListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankListReq message.
         * @function verify
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankListReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                if (!$util.isInteger(message.rankType))
                    return "rankType: integer expected";
            return null;
        };

        /**
         * Creates a GetRankListReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GetRankListReq} GetRankListReq
         */
        GetRankListReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GetRankListReq)
                return object;
            var message = new $root.CLPF.GetRankListReq();
            if (object.rankType != null)
                message.rankType = object.rankType | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetRankListReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GetRankListReq
         * @static
         * @param {CLPF.GetRankListReq} message GetRankListReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRankListReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rankType = 0;
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = message.rankType;
            return object;
        };

        /**
         * Converts this GetRankListReq to JSON.
         * @function toJSON
         * @memberof CLPF.GetRankListReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRankListReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRankListReq;
    })();

    CLPF.GetRankListAck = (function() {

        /**
         * Properties of a GetRankListAck.
         * @memberof CLPF
         * @interface IGetRankListAck
         * @property {number|null} [errcode] GetRankListAck errcode
         * @property {Array.<CLPF.IRankPlayerInfo>|null} [rankRows] GetRankListAck rankRows
         * @property {number|null} [myLastdayRank] GetRankListAck myLastdayRank
         * @property {boolean|null} [fetchedLastdayReward] GetRankListAck fetchedLastdayReward
         */

        /**
         * Constructs a new GetRankListAck.
         * @memberof CLPF
         * @classdesc Represents a GetRankListAck.
         * @implements IGetRankListAck
         * @constructor
         * @param {CLPF.IGetRankListAck=} [properties] Properties to set
         */
        function GetRankListAck(properties) {
            this.rankRows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankListAck errcode.
         * @member {number} errcode
         * @memberof CLPF.GetRankListAck
         * @instance
         */
        GetRankListAck.prototype.errcode = 0;

        /**
         * GetRankListAck rankRows.
         * @member {Array.<CLPF.IRankPlayerInfo>} rankRows
         * @memberof CLPF.GetRankListAck
         * @instance
         */
        GetRankListAck.prototype.rankRows = $util.emptyArray;

        /**
         * GetRankListAck myLastdayRank.
         * @member {number} myLastdayRank
         * @memberof CLPF.GetRankListAck
         * @instance
         */
        GetRankListAck.prototype.myLastdayRank = 0;

        /**
         * GetRankListAck fetchedLastdayReward.
         * @member {boolean} fetchedLastdayReward
         * @memberof CLPF.GetRankListAck
         * @instance
         */
        GetRankListAck.prototype.fetchedLastdayReward = false;

        /**
         * Creates a new GetRankListAck instance using the specified properties.
         * @function create
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {CLPF.IGetRankListAck=} [properties] Properties to set
         * @returns {CLPF.GetRankListAck} GetRankListAck instance
         */
        GetRankListAck.create = function create(properties) {
            return new GetRankListAck(properties);
        };

        /**
         * Encodes the specified GetRankListAck message. Does not implicitly {@link CLPF.GetRankListAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {CLPF.IGetRankListAck} message GetRankListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.rankRows != null && message.rankRows.length)
                for (var i = 0; i < message.rankRows.length; ++i)
                    $root.CLPF.RankPlayerInfo.encode(message.rankRows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.myLastdayRank != null && Object.hasOwnProperty.call(message, "myLastdayRank"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.myLastdayRank);
            if (message.fetchedLastdayReward != null && Object.hasOwnProperty.call(message, "fetchedLastdayReward"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.fetchedLastdayReward);
            return writer;
        };

        /**
         * Encodes the specified GetRankListAck message, length delimited. Does not implicitly {@link CLPF.GetRankListAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {CLPF.IGetRankListAck} message GetRankListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankListAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GetRankListAck} GetRankListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GetRankListAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.rankRows && message.rankRows.length))
                        message.rankRows = [];
                    message.rankRows.push($root.CLPF.RankPlayerInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.myLastdayRank = reader.int32();
                    break;
                case 4:
                    message.fetchedLastdayReward = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankListAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GetRankListAck} GetRankListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankListAck message.
         * @function verify
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankListAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.rankRows != null && message.hasOwnProperty("rankRows")) {
                if (!Array.isArray(message.rankRows))
                    return "rankRows: array expected";
                for (var i = 0; i < message.rankRows.length; ++i) {
                    var error = $root.CLPF.RankPlayerInfo.verify(message.rankRows[i]);
                    if (error)
                        return "rankRows." + error;
                }
            }
            if (message.myLastdayRank != null && message.hasOwnProperty("myLastdayRank"))
                if (!$util.isInteger(message.myLastdayRank))
                    return "myLastdayRank: integer expected";
            if (message.fetchedLastdayReward != null && message.hasOwnProperty("fetchedLastdayReward"))
                if (typeof message.fetchedLastdayReward !== "boolean")
                    return "fetchedLastdayReward: boolean expected";
            return null;
        };

        /**
         * Creates a GetRankListAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GetRankListAck} GetRankListAck
         */
        GetRankListAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GetRankListAck)
                return object;
            var message = new $root.CLPF.GetRankListAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.rankRows) {
                if (!Array.isArray(object.rankRows))
                    throw TypeError(".CLPF.GetRankListAck.rankRows: array expected");
                message.rankRows = [];
                for (var i = 0; i < object.rankRows.length; ++i) {
                    if (typeof object.rankRows[i] !== "object")
                        throw TypeError(".CLPF.GetRankListAck.rankRows: object expected");
                    message.rankRows[i] = $root.CLPF.RankPlayerInfo.fromObject(object.rankRows[i]);
                }
            }
            if (object.myLastdayRank != null)
                message.myLastdayRank = object.myLastdayRank | 0;
            if (object.fetchedLastdayReward != null)
                message.fetchedLastdayReward = Boolean(object.fetchedLastdayReward);
            return message;
        };

        /**
         * Creates a plain object from a GetRankListAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GetRankListAck
         * @static
         * @param {CLPF.GetRankListAck} message GetRankListAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRankListAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rankRows = [];
            if (options.defaults) {
                object.errcode = 0;
                object.myLastdayRank = 0;
                object.fetchedLastdayReward = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.rankRows && message.rankRows.length) {
                object.rankRows = [];
                for (var j = 0; j < message.rankRows.length; ++j)
                    object.rankRows[j] = $root.CLPF.RankPlayerInfo.toObject(message.rankRows[j], options);
            }
            if (message.myLastdayRank != null && message.hasOwnProperty("myLastdayRank"))
                object.myLastdayRank = message.myLastdayRank;
            if (message.fetchedLastdayReward != null && message.hasOwnProperty("fetchedLastdayReward"))
                object.fetchedLastdayReward = message.fetchedLastdayReward;
            return object;
        };

        /**
         * Converts this GetRankListAck to JSON.
         * @function toJSON
         * @memberof CLPF.GetRankListAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRankListAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRankListAck;
    })();

    CLPF.LevelExpChangedNtf = (function() {

        /**
         * Properties of a LevelExpChangedNtf.
         * @memberof CLPF
         * @interface ILevelExpChangedNtf
         * @property {number|Long|null} [levelExp] LevelExpChangedNtf levelExp
         */

        /**
         * Constructs a new LevelExpChangedNtf.
         * @memberof CLPF
         * @classdesc Represents a LevelExpChangedNtf.
         * @implements ILevelExpChangedNtf
         * @constructor
         * @param {CLPF.ILevelExpChangedNtf=} [properties] Properties to set
         */
        function LevelExpChangedNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelExpChangedNtf levelExp.
         * @member {number|Long} levelExp
         * @memberof CLPF.LevelExpChangedNtf
         * @instance
         */
        LevelExpChangedNtf.prototype.levelExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new LevelExpChangedNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {CLPF.ILevelExpChangedNtf=} [properties] Properties to set
         * @returns {CLPF.LevelExpChangedNtf} LevelExpChangedNtf instance
         */
        LevelExpChangedNtf.create = function create(properties) {
            return new LevelExpChangedNtf(properties);
        };

        /**
         * Encodes the specified LevelExpChangedNtf message. Does not implicitly {@link CLPF.LevelExpChangedNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {CLPF.ILevelExpChangedNtf} message LevelExpChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelExpChangedNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.levelExp != null && Object.hasOwnProperty.call(message, "levelExp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.levelExp);
            return writer;
        };

        /**
         * Encodes the specified LevelExpChangedNtf message, length delimited. Does not implicitly {@link CLPF.LevelExpChangedNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {CLPF.ILevelExpChangedNtf} message LevelExpChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelExpChangedNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelExpChangedNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LevelExpChangedNtf} LevelExpChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelExpChangedNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LevelExpChangedNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.levelExp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelExpChangedNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LevelExpChangedNtf} LevelExpChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelExpChangedNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelExpChangedNtf message.
         * @function verify
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelExpChangedNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.levelExp != null && message.hasOwnProperty("levelExp"))
                if (!$util.isInteger(message.levelExp) && !(message.levelExp && $util.isInteger(message.levelExp.low) && $util.isInteger(message.levelExp.high)))
                    return "levelExp: integer|Long expected";
            return null;
        };

        /**
         * Creates a LevelExpChangedNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LevelExpChangedNtf} LevelExpChangedNtf
         */
        LevelExpChangedNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LevelExpChangedNtf)
                return object;
            var message = new $root.CLPF.LevelExpChangedNtf();
            if (object.levelExp != null)
                if ($util.Long)
                    (message.levelExp = $util.Long.fromValue(object.levelExp)).unsigned = false;
                else if (typeof object.levelExp === "string")
                    message.levelExp = parseInt(object.levelExp, 10);
                else if (typeof object.levelExp === "number")
                    message.levelExp = object.levelExp;
                else if (typeof object.levelExp === "object")
                    message.levelExp = new $util.LongBits(object.levelExp.low >>> 0, object.levelExp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a LevelExpChangedNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LevelExpChangedNtf
         * @static
         * @param {CLPF.LevelExpChangedNtf} message LevelExpChangedNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LevelExpChangedNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.levelExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.levelExp = options.longs === String ? "0" : 0;
            if (message.levelExp != null && message.hasOwnProperty("levelExp"))
                if (typeof message.levelExp === "number")
                    object.levelExp = options.longs === String ? String(message.levelExp) : message.levelExp;
                else
                    object.levelExp = options.longs === String ? $util.Long.prototype.toString.call(message.levelExp) : options.longs === Number ? new $util.LongBits(message.levelExp.low >>> 0, message.levelExp.high >>> 0).toNumber() : message.levelExp;
            return object;
        };

        /**
         * Converts this LevelExpChangedNtf to JSON.
         * @function toJSON
         * @memberof CLPF.LevelExpChangedNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LevelExpChangedNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LevelExpChangedNtf;
    })();

    CLPF.LevelUpNtf = (function() {

        /**
         * Properties of a LevelUpNtf.
         * @memberof CLPF
         * @interface ILevelUpNtf
         * @property {number|null} [level] LevelUpNtf level
         * @property {Array.<CLPF.IItemInfo>|null} [rewardArray] LevelUpNtf rewardArray
         */

        /**
         * Constructs a new LevelUpNtf.
         * @memberof CLPF
         * @classdesc Represents a LevelUpNtf.
         * @implements ILevelUpNtf
         * @constructor
         * @param {CLPF.ILevelUpNtf=} [properties] Properties to set
         */
        function LevelUpNtf(properties) {
            this.rewardArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelUpNtf level.
         * @member {number} level
         * @memberof CLPF.LevelUpNtf
         * @instance
         */
        LevelUpNtf.prototype.level = 0;

        /**
         * LevelUpNtf rewardArray.
         * @member {Array.<CLPF.IItemInfo>} rewardArray
         * @memberof CLPF.LevelUpNtf
         * @instance
         */
        LevelUpNtf.prototype.rewardArray = $util.emptyArray;

        /**
         * Creates a new LevelUpNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {CLPF.ILevelUpNtf=} [properties] Properties to set
         * @returns {CLPF.LevelUpNtf} LevelUpNtf instance
         */
        LevelUpNtf.create = function create(properties) {
            return new LevelUpNtf(properties);
        };

        /**
         * Encodes the specified LevelUpNtf message. Does not implicitly {@link CLPF.LevelUpNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {CLPF.ILevelUpNtf} message LevelUpNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelUpNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
            if (message.rewardArray != null && message.rewardArray.length)
                for (var i = 0; i < message.rewardArray.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.rewardArray[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LevelUpNtf message, length delimited. Does not implicitly {@link CLPF.LevelUpNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {CLPF.ILevelUpNtf} message LevelUpNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelUpNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelUpNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LevelUpNtf} LevelUpNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelUpNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LevelUpNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                case 2:
                    if (!(message.rewardArray && message.rewardArray.length))
                        message.rewardArray = [];
                    message.rewardArray.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelUpNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LevelUpNtf} LevelUpNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelUpNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelUpNtf message.
         * @function verify
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelUpNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.rewardArray != null && message.hasOwnProperty("rewardArray")) {
                if (!Array.isArray(message.rewardArray))
                    return "rewardArray: array expected";
                for (var i = 0; i < message.rewardArray.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.rewardArray[i]);
                    if (error)
                        return "rewardArray." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LevelUpNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LevelUpNtf} LevelUpNtf
         */
        LevelUpNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LevelUpNtf)
                return object;
            var message = new $root.CLPF.LevelUpNtf();
            if (object.level != null)
                message.level = object.level | 0;
            if (object.rewardArray) {
                if (!Array.isArray(object.rewardArray))
                    throw TypeError(".CLPF.LevelUpNtf.rewardArray: array expected");
                message.rewardArray = [];
                for (var i = 0; i < object.rewardArray.length; ++i) {
                    if (typeof object.rewardArray[i] !== "object")
                        throw TypeError(".CLPF.LevelUpNtf.rewardArray: object expected");
                    message.rewardArray[i] = $root.CLPF.ItemInfo.fromObject(object.rewardArray[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LevelUpNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LevelUpNtf
         * @static
         * @param {CLPF.LevelUpNtf} message LevelUpNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LevelUpNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rewardArray = [];
            if (options.defaults)
                object.level = 0;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.rewardArray && message.rewardArray.length) {
                object.rewardArray = [];
                for (var j = 0; j < message.rewardArray.length; ++j)
                    object.rewardArray[j] = $root.CLPF.ItemInfo.toObject(message.rewardArray[j], options);
            }
            return object;
        };

        /**
         * Converts this LevelUpNtf to JSON.
         * @function toJSON
         * @memberof CLPF.LevelUpNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LevelUpNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LevelUpNtf;
    })();

    CLPF.VipExpChangedNtf = (function() {

        /**
         * Properties of a VipExpChangedNtf.
         * @memberof CLPF
         * @interface IVipExpChangedNtf
         * @property {number|null} [vipLevel] VipExpChangedNtf vipLevel
         * @property {number|Long|null} [vipLevelExp] VipExpChangedNtf vipLevelExp
         */

        /**
         * Constructs a new VipExpChangedNtf.
         * @memberof CLPF
         * @classdesc Represents a VipExpChangedNtf.
         * @implements IVipExpChangedNtf
         * @constructor
         * @param {CLPF.IVipExpChangedNtf=} [properties] Properties to set
         */
        function VipExpChangedNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VipExpChangedNtf vipLevel.
         * @member {number} vipLevel
         * @memberof CLPF.VipExpChangedNtf
         * @instance
         */
        VipExpChangedNtf.prototype.vipLevel = 0;

        /**
         * VipExpChangedNtf vipLevelExp.
         * @member {number|Long} vipLevelExp
         * @memberof CLPF.VipExpChangedNtf
         * @instance
         */
        VipExpChangedNtf.prototype.vipLevelExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new VipExpChangedNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {CLPF.IVipExpChangedNtf=} [properties] Properties to set
         * @returns {CLPF.VipExpChangedNtf} VipExpChangedNtf instance
         */
        VipExpChangedNtf.create = function create(properties) {
            return new VipExpChangedNtf(properties);
        };

        /**
         * Encodes the specified VipExpChangedNtf message. Does not implicitly {@link CLPF.VipExpChangedNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {CLPF.IVipExpChangedNtf} message VipExpChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipExpChangedNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vipLevel != null && Object.hasOwnProperty.call(message, "vipLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.vipLevel);
            if (message.vipLevelExp != null && Object.hasOwnProperty.call(message, "vipLevelExp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.vipLevelExp);
            return writer;
        };

        /**
         * Encodes the specified VipExpChangedNtf message, length delimited. Does not implicitly {@link CLPF.VipExpChangedNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {CLPF.IVipExpChangedNtf} message VipExpChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipExpChangedNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VipExpChangedNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.VipExpChangedNtf} VipExpChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipExpChangedNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.VipExpChangedNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.vipLevel = reader.int32();
                    break;
                case 2:
                    message.vipLevelExp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VipExpChangedNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.VipExpChangedNtf} VipExpChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipExpChangedNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VipExpChangedNtf message.
         * @function verify
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VipExpChangedNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                if (!$util.isInteger(message.vipLevel))
                    return "vipLevel: integer expected";
            if (message.vipLevelExp != null && message.hasOwnProperty("vipLevelExp"))
                if (!$util.isInteger(message.vipLevelExp) && !(message.vipLevelExp && $util.isInteger(message.vipLevelExp.low) && $util.isInteger(message.vipLevelExp.high)))
                    return "vipLevelExp: integer|Long expected";
            return null;
        };

        /**
         * Creates a VipExpChangedNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.VipExpChangedNtf} VipExpChangedNtf
         */
        VipExpChangedNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.VipExpChangedNtf)
                return object;
            var message = new $root.CLPF.VipExpChangedNtf();
            if (object.vipLevel != null)
                message.vipLevel = object.vipLevel | 0;
            if (object.vipLevelExp != null)
                if ($util.Long)
                    (message.vipLevelExp = $util.Long.fromValue(object.vipLevelExp)).unsigned = false;
                else if (typeof object.vipLevelExp === "string")
                    message.vipLevelExp = parseInt(object.vipLevelExp, 10);
                else if (typeof object.vipLevelExp === "number")
                    message.vipLevelExp = object.vipLevelExp;
                else if (typeof object.vipLevelExp === "object")
                    message.vipLevelExp = new $util.LongBits(object.vipLevelExp.low >>> 0, object.vipLevelExp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a VipExpChangedNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.VipExpChangedNtf
         * @static
         * @param {CLPF.VipExpChangedNtf} message VipExpChangedNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VipExpChangedNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vipLevel = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vipLevelExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vipLevelExp = options.longs === String ? "0" : 0;
            }
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                object.vipLevel = message.vipLevel;
            if (message.vipLevelExp != null && message.hasOwnProperty("vipLevelExp"))
                if (typeof message.vipLevelExp === "number")
                    object.vipLevelExp = options.longs === String ? String(message.vipLevelExp) : message.vipLevelExp;
                else
                    object.vipLevelExp = options.longs === String ? $util.Long.prototype.toString.call(message.vipLevelExp) : options.longs === Number ? new $util.LongBits(message.vipLevelExp.low >>> 0, message.vipLevelExp.high >>> 0).toNumber() : message.vipLevelExp;
            return object;
        };

        /**
         * Converts this VipExpChangedNtf to JSON.
         * @function toJSON
         * @memberof CLPF.VipExpChangedNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VipExpChangedNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VipExpChangedNtf;
    })();

    CLPF.ModifyNicknameReq = (function() {

        /**
         * Properties of a ModifyNicknameReq.
         * @memberof CLPF
         * @interface IModifyNicknameReq
         * @property {string|null} [newNickname] ModifyNicknameReq newNickname
         */

        /**
         * Constructs a new ModifyNicknameReq.
         * @memberof CLPF
         * @classdesc Represents a ModifyNicknameReq.
         * @implements IModifyNicknameReq
         * @constructor
         * @param {CLPF.IModifyNicknameReq=} [properties] Properties to set
         */
        function ModifyNicknameReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyNicknameReq newNickname.
         * @member {string} newNickname
         * @memberof CLPF.ModifyNicknameReq
         * @instance
         */
        ModifyNicknameReq.prototype.newNickname = "";

        /**
         * Creates a new ModifyNicknameReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {CLPF.IModifyNicknameReq=} [properties] Properties to set
         * @returns {CLPF.ModifyNicknameReq} ModifyNicknameReq instance
         */
        ModifyNicknameReq.create = function create(properties) {
            return new ModifyNicknameReq(properties);
        };

        /**
         * Encodes the specified ModifyNicknameReq message. Does not implicitly {@link CLPF.ModifyNicknameReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {CLPF.IModifyNicknameReq} message ModifyNicknameReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNicknameReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newNickname != null && Object.hasOwnProperty.call(message, "newNickname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.newNickname);
            return writer;
        };

        /**
         * Encodes the specified ModifyNicknameReq message, length delimited. Does not implicitly {@link CLPF.ModifyNicknameReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {CLPF.IModifyNicknameReq} message ModifyNicknameReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNicknameReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyNicknameReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyNicknameReq} ModifyNicknameReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNicknameReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyNicknameReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newNickname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyNicknameReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyNicknameReq} ModifyNicknameReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNicknameReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyNicknameReq message.
         * @function verify
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyNicknameReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newNickname != null && message.hasOwnProperty("newNickname"))
                if (!$util.isString(message.newNickname))
                    return "newNickname: string expected";
            return null;
        };

        /**
         * Creates a ModifyNicknameReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyNicknameReq} ModifyNicknameReq
         */
        ModifyNicknameReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyNicknameReq)
                return object;
            var message = new $root.CLPF.ModifyNicknameReq();
            if (object.newNickname != null)
                message.newNickname = String(object.newNickname);
            return message;
        };

        /**
         * Creates a plain object from a ModifyNicknameReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyNicknameReq
         * @static
         * @param {CLPF.ModifyNicknameReq} message ModifyNicknameReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyNicknameReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.newNickname = "";
            if (message.newNickname != null && message.hasOwnProperty("newNickname"))
                object.newNickname = message.newNickname;
            return object;
        };

        /**
         * Converts this ModifyNicknameReq to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyNicknameReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyNicknameReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyNicknameReq;
    })();

    CLPF.ModifyNicknameAck = (function() {

        /**
         * Properties of a ModifyNicknameAck.
         * @memberof CLPF
         * @interface IModifyNicknameAck
         * @property {number|null} [errcode] ModifyNicknameAck errcode
         */

        /**
         * Constructs a new ModifyNicknameAck.
         * @memberof CLPF
         * @classdesc Represents a ModifyNicknameAck.
         * @implements IModifyNicknameAck
         * @constructor
         * @param {CLPF.IModifyNicknameAck=} [properties] Properties to set
         */
        function ModifyNicknameAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyNicknameAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ModifyNicknameAck
         * @instance
         */
        ModifyNicknameAck.prototype.errcode = 0;

        /**
         * Creates a new ModifyNicknameAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {CLPF.IModifyNicknameAck=} [properties] Properties to set
         * @returns {CLPF.ModifyNicknameAck} ModifyNicknameAck instance
         */
        ModifyNicknameAck.create = function create(properties) {
            return new ModifyNicknameAck(properties);
        };

        /**
         * Encodes the specified ModifyNicknameAck message. Does not implicitly {@link CLPF.ModifyNicknameAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {CLPF.IModifyNicknameAck} message ModifyNicknameAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNicknameAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ModifyNicknameAck message, length delimited. Does not implicitly {@link CLPF.ModifyNicknameAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {CLPF.IModifyNicknameAck} message ModifyNicknameAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNicknameAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyNicknameAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyNicknameAck} ModifyNicknameAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNicknameAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyNicknameAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyNicknameAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyNicknameAck} ModifyNicknameAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNicknameAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyNicknameAck message.
         * @function verify
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyNicknameAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a ModifyNicknameAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyNicknameAck} ModifyNicknameAck
         */
        ModifyNicknameAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyNicknameAck)
                return object;
            var message = new $root.CLPF.ModifyNicknameAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyNicknameAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyNicknameAck
         * @static
         * @param {CLPF.ModifyNicknameAck} message ModifyNicknameAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyNicknameAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ModifyNicknameAck to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyNicknameAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyNicknameAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyNicknameAck;
    })();

    CLPF.ModifyPersonalSignatureReq = (function() {

        /**
         * Properties of a ModifyPersonalSignatureReq.
         * @memberof CLPF
         * @interface IModifyPersonalSignatureReq
         * @property {string|null} [newPersonalSignature] ModifyPersonalSignatureReq newPersonalSignature
         */

        /**
         * Constructs a new ModifyPersonalSignatureReq.
         * @memberof CLPF
         * @classdesc Represents a ModifyPersonalSignatureReq.
         * @implements IModifyPersonalSignatureReq
         * @constructor
         * @param {CLPF.IModifyPersonalSignatureReq=} [properties] Properties to set
         */
        function ModifyPersonalSignatureReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyPersonalSignatureReq newPersonalSignature.
         * @member {string} newPersonalSignature
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @instance
         */
        ModifyPersonalSignatureReq.prototype.newPersonalSignature = "";

        /**
         * Creates a new ModifyPersonalSignatureReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {CLPF.IModifyPersonalSignatureReq=} [properties] Properties to set
         * @returns {CLPF.ModifyPersonalSignatureReq} ModifyPersonalSignatureReq instance
         */
        ModifyPersonalSignatureReq.create = function create(properties) {
            return new ModifyPersonalSignatureReq(properties);
        };

        /**
         * Encodes the specified ModifyPersonalSignatureReq message. Does not implicitly {@link CLPF.ModifyPersonalSignatureReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {CLPF.IModifyPersonalSignatureReq} message ModifyPersonalSignatureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyPersonalSignatureReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newPersonalSignature != null && Object.hasOwnProperty.call(message, "newPersonalSignature"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.newPersonalSignature);
            return writer;
        };

        /**
         * Encodes the specified ModifyPersonalSignatureReq message, length delimited. Does not implicitly {@link CLPF.ModifyPersonalSignatureReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {CLPF.IModifyPersonalSignatureReq} message ModifyPersonalSignatureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyPersonalSignatureReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyPersonalSignatureReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyPersonalSignatureReq} ModifyPersonalSignatureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyPersonalSignatureReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyPersonalSignatureReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newPersonalSignature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyPersonalSignatureReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyPersonalSignatureReq} ModifyPersonalSignatureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyPersonalSignatureReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyPersonalSignatureReq message.
         * @function verify
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyPersonalSignatureReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newPersonalSignature != null && message.hasOwnProperty("newPersonalSignature"))
                if (!$util.isString(message.newPersonalSignature))
                    return "newPersonalSignature: string expected";
            return null;
        };

        /**
         * Creates a ModifyPersonalSignatureReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyPersonalSignatureReq} ModifyPersonalSignatureReq
         */
        ModifyPersonalSignatureReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyPersonalSignatureReq)
                return object;
            var message = new $root.CLPF.ModifyPersonalSignatureReq();
            if (object.newPersonalSignature != null)
                message.newPersonalSignature = String(object.newPersonalSignature);
            return message;
        };

        /**
         * Creates a plain object from a ModifyPersonalSignatureReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @static
         * @param {CLPF.ModifyPersonalSignatureReq} message ModifyPersonalSignatureReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyPersonalSignatureReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.newPersonalSignature = "";
            if (message.newPersonalSignature != null && message.hasOwnProperty("newPersonalSignature"))
                object.newPersonalSignature = message.newPersonalSignature;
            return object;
        };

        /**
         * Converts this ModifyPersonalSignatureReq to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyPersonalSignatureReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyPersonalSignatureReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyPersonalSignatureReq;
    })();

    CLPF.ModifyPersonalSignatureAck = (function() {

        /**
         * Properties of a ModifyPersonalSignatureAck.
         * @memberof CLPF
         * @interface IModifyPersonalSignatureAck
         * @property {number|null} [errcode] ModifyPersonalSignatureAck errcode
         */

        /**
         * Constructs a new ModifyPersonalSignatureAck.
         * @memberof CLPF
         * @classdesc Represents a ModifyPersonalSignatureAck.
         * @implements IModifyPersonalSignatureAck
         * @constructor
         * @param {CLPF.IModifyPersonalSignatureAck=} [properties] Properties to set
         */
        function ModifyPersonalSignatureAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyPersonalSignatureAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @instance
         */
        ModifyPersonalSignatureAck.prototype.errcode = 0;

        /**
         * Creates a new ModifyPersonalSignatureAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {CLPF.IModifyPersonalSignatureAck=} [properties] Properties to set
         * @returns {CLPF.ModifyPersonalSignatureAck} ModifyPersonalSignatureAck instance
         */
        ModifyPersonalSignatureAck.create = function create(properties) {
            return new ModifyPersonalSignatureAck(properties);
        };

        /**
         * Encodes the specified ModifyPersonalSignatureAck message. Does not implicitly {@link CLPF.ModifyPersonalSignatureAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {CLPF.IModifyPersonalSignatureAck} message ModifyPersonalSignatureAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyPersonalSignatureAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ModifyPersonalSignatureAck message, length delimited. Does not implicitly {@link CLPF.ModifyPersonalSignatureAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {CLPF.IModifyPersonalSignatureAck} message ModifyPersonalSignatureAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyPersonalSignatureAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyPersonalSignatureAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyPersonalSignatureAck} ModifyPersonalSignatureAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyPersonalSignatureAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyPersonalSignatureAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyPersonalSignatureAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyPersonalSignatureAck} ModifyPersonalSignatureAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyPersonalSignatureAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyPersonalSignatureAck message.
         * @function verify
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyPersonalSignatureAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a ModifyPersonalSignatureAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyPersonalSignatureAck} ModifyPersonalSignatureAck
         */
        ModifyPersonalSignatureAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyPersonalSignatureAck)
                return object;
            var message = new $root.CLPF.ModifyPersonalSignatureAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyPersonalSignatureAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @static
         * @param {CLPF.ModifyPersonalSignatureAck} message ModifyPersonalSignatureAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyPersonalSignatureAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ModifyPersonalSignatureAck to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyPersonalSignatureAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyPersonalSignatureAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyPersonalSignatureAck;
    })();

    CLPF.ModifyHeadReq = (function() {

        /**
         * Properties of a ModifyHeadReq.
         * @memberof CLPF
         * @interface IModifyHeadReq
         * @property {number|null} [newHead] ModifyHeadReq newHead
         * @property {number|null} [newHeadFrame] ModifyHeadReq newHeadFrame
         */

        /**
         * Constructs a new ModifyHeadReq.
         * @memberof CLPF
         * @classdesc Represents a ModifyHeadReq.
         * @implements IModifyHeadReq
         * @constructor
         * @param {CLPF.IModifyHeadReq=} [properties] Properties to set
         */
        function ModifyHeadReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyHeadReq newHead.
         * @member {number} newHead
         * @memberof CLPF.ModifyHeadReq
         * @instance
         */
        ModifyHeadReq.prototype.newHead = 0;

        /**
         * ModifyHeadReq newHeadFrame.
         * @member {number} newHeadFrame
         * @memberof CLPF.ModifyHeadReq
         * @instance
         */
        ModifyHeadReq.prototype.newHeadFrame = 0;

        /**
         * Creates a new ModifyHeadReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {CLPF.IModifyHeadReq=} [properties] Properties to set
         * @returns {CLPF.ModifyHeadReq} ModifyHeadReq instance
         */
        ModifyHeadReq.create = function create(properties) {
            return new ModifyHeadReq(properties);
        };

        /**
         * Encodes the specified ModifyHeadReq message. Does not implicitly {@link CLPF.ModifyHeadReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {CLPF.IModifyHeadReq} message ModifyHeadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyHeadReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newHead != null && Object.hasOwnProperty.call(message, "newHead"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.newHead);
            if (message.newHeadFrame != null && Object.hasOwnProperty.call(message, "newHeadFrame"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newHeadFrame);
            return writer;
        };

        /**
         * Encodes the specified ModifyHeadReq message, length delimited. Does not implicitly {@link CLPF.ModifyHeadReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {CLPF.IModifyHeadReq} message ModifyHeadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyHeadReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyHeadReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyHeadReq} ModifyHeadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyHeadReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyHeadReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newHead = reader.int32();
                    break;
                case 2:
                    message.newHeadFrame = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyHeadReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyHeadReq} ModifyHeadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyHeadReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyHeadReq message.
         * @function verify
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyHeadReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newHead != null && message.hasOwnProperty("newHead"))
                if (!$util.isInteger(message.newHead))
                    return "newHead: integer expected";
            if (message.newHeadFrame != null && message.hasOwnProperty("newHeadFrame"))
                if (!$util.isInteger(message.newHeadFrame))
                    return "newHeadFrame: integer expected";
            return null;
        };

        /**
         * Creates a ModifyHeadReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyHeadReq} ModifyHeadReq
         */
        ModifyHeadReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyHeadReq)
                return object;
            var message = new $root.CLPF.ModifyHeadReq();
            if (object.newHead != null)
                message.newHead = object.newHead | 0;
            if (object.newHeadFrame != null)
                message.newHeadFrame = object.newHeadFrame | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyHeadReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyHeadReq
         * @static
         * @param {CLPF.ModifyHeadReq} message ModifyHeadReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyHeadReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.newHead = 0;
                object.newHeadFrame = 0;
            }
            if (message.newHead != null && message.hasOwnProperty("newHead"))
                object.newHead = message.newHead;
            if (message.newHeadFrame != null && message.hasOwnProperty("newHeadFrame"))
                object.newHeadFrame = message.newHeadFrame;
            return object;
        };

        /**
         * Converts this ModifyHeadReq to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyHeadReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyHeadReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyHeadReq;
    })();

    CLPF.ModifyHeadAck = (function() {

        /**
         * Properties of a ModifyHeadAck.
         * @memberof CLPF
         * @interface IModifyHeadAck
         * @property {number|null} [errcode] ModifyHeadAck errcode
         */

        /**
         * Constructs a new ModifyHeadAck.
         * @memberof CLPF
         * @classdesc Represents a ModifyHeadAck.
         * @implements IModifyHeadAck
         * @constructor
         * @param {CLPF.IModifyHeadAck=} [properties] Properties to set
         */
        function ModifyHeadAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyHeadAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ModifyHeadAck
         * @instance
         */
        ModifyHeadAck.prototype.errcode = 0;

        /**
         * Creates a new ModifyHeadAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {CLPF.IModifyHeadAck=} [properties] Properties to set
         * @returns {CLPF.ModifyHeadAck} ModifyHeadAck instance
         */
        ModifyHeadAck.create = function create(properties) {
            return new ModifyHeadAck(properties);
        };

        /**
         * Encodes the specified ModifyHeadAck message. Does not implicitly {@link CLPF.ModifyHeadAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {CLPF.IModifyHeadAck} message ModifyHeadAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyHeadAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ModifyHeadAck message, length delimited. Does not implicitly {@link CLPF.ModifyHeadAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {CLPF.IModifyHeadAck} message ModifyHeadAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyHeadAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyHeadAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyHeadAck} ModifyHeadAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyHeadAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyHeadAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyHeadAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyHeadAck} ModifyHeadAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyHeadAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyHeadAck message.
         * @function verify
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyHeadAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a ModifyHeadAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyHeadAck} ModifyHeadAck
         */
        ModifyHeadAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyHeadAck)
                return object;
            var message = new $root.CLPF.ModifyHeadAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyHeadAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyHeadAck
         * @static
         * @param {CLPF.ModifyHeadAck} message ModifyHeadAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyHeadAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ModifyHeadAck to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyHeadAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyHeadAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyHeadAck;
    })();

    CLPF.MailInfo = (function() {

        /**
         * Properties of a MailInfo.
         * @memberof CLPF
         * @interface IMailInfo
         * @property {number|null} [id] MailInfo id
         * @property {number|null} [type] MailInfo type
         * @property {string|null} [title] MailInfo title
         * @property {string|null} [content] MailInfo content
         * @property {Array.<CLPF.IItemInfo>|null} [items] MailInfo items
         * @property {number|null} [state] MailInfo state
         * @property {number|null} [receiveTime] MailInfo receiveTime
         * @property {number|null} [expireTime] MailInfo expireTime
         */

        /**
         * Constructs a new MailInfo.
         * @memberof CLPF
         * @classdesc Represents a MailInfo.
         * @implements IMailInfo
         * @constructor
         * @param {CLPF.IMailInfo=} [properties] Properties to set
         */
        function MailInfo(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailInfo id.
         * @member {number} id
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.id = 0;

        /**
         * MailInfo type.
         * @member {number} type
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.type = 0;

        /**
         * MailInfo title.
         * @member {string} title
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.title = "";

        /**
         * MailInfo content.
         * @member {string} content
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.content = "";

        /**
         * MailInfo items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.items = $util.emptyArray;

        /**
         * MailInfo state.
         * @member {number} state
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.state = 0;

        /**
         * MailInfo receiveTime.
         * @member {number} receiveTime
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.receiveTime = 0;

        /**
         * MailInfo expireTime.
         * @member {number} expireTime
         * @memberof CLPF.MailInfo
         * @instance
         */
        MailInfo.prototype.expireTime = 0;

        /**
         * Creates a new MailInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.MailInfo
         * @static
         * @param {CLPF.IMailInfo=} [properties] Properties to set
         * @returns {CLPF.MailInfo} MailInfo instance
         */
        MailInfo.create = function create(properties) {
            return new MailInfo(properties);
        };

        /**
         * Encodes the specified MailInfo message. Does not implicitly {@link CLPF.MailInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailInfo
         * @static
         * @param {CLPF.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.content);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
            if (message.receiveTime != null && Object.hasOwnProperty.call(message, "receiveTime"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.receiveTime);
            if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.expireTime);
            return writer;
        };

        /**
         * Encodes the specified MailInfo message, length delimited. Does not implicitly {@link CLPF.MailInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailInfo
         * @static
         * @param {CLPF.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                case 4:
                    message.content = reader.string();
                    break;
                case 5:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.state = reader.int32();
                    break;
                case 7:
                    message.receiveTime = reader.fixed32();
                    break;
                case 8:
                    message.expireTime = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailInfo message.
         * @function verify
         * @memberof CLPF.MailInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.receiveTime != null && message.hasOwnProperty("receiveTime"))
                if (!$util.isInteger(message.receiveTime))
                    return "receiveTime: integer expected";
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (!$util.isInteger(message.expireTime))
                    return "expireTime: integer expected";
            return null;
        };

        /**
         * Creates a MailInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailInfo} MailInfo
         */
        MailInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailInfo)
                return object;
            var message = new $root.CLPF.MailInfo();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.title != null)
                message.title = String(object.title);
            if (object.content != null)
                message.content = String(object.content);
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.MailInfo.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.MailInfo.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            if (object.state != null)
                message.state = object.state | 0;
            if (object.receiveTime != null)
                message.receiveTime = object.receiveTime >>> 0;
            if (object.expireTime != null)
                message.expireTime = object.expireTime >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MailInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailInfo
         * @static
         * @param {CLPF.MailInfo} message MailInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.id = 0;
                object.type = 0;
                object.title = "";
                object.content = "";
                object.state = 0;
                object.receiveTime = 0;
                object.expireTime = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.receiveTime != null && message.hasOwnProperty("receiveTime"))
                object.receiveTime = message.receiveTime;
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                object.expireTime = message.expireTime;
            return object;
        };

        /**
         * Converts this MailInfo to JSON.
         * @function toJSON
         * @memberof CLPF.MailInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailInfo;
    })();

    CLPF.MailQueryStateReq = (function() {

        /**
         * Properties of a MailQueryStateReq.
         * @memberof CLPF
         * @interface IMailQueryStateReq
         */

        /**
         * Constructs a new MailQueryStateReq.
         * @memberof CLPF
         * @classdesc Represents a MailQueryStateReq.
         * @implements IMailQueryStateReq
         * @constructor
         * @param {CLPF.IMailQueryStateReq=} [properties] Properties to set
         */
        function MailQueryStateReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MailQueryStateReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {CLPF.IMailQueryStateReq=} [properties] Properties to set
         * @returns {CLPF.MailQueryStateReq} MailQueryStateReq instance
         */
        MailQueryStateReq.create = function create(properties) {
            return new MailQueryStateReq(properties);
        };

        /**
         * Encodes the specified MailQueryStateReq message. Does not implicitly {@link CLPF.MailQueryStateReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {CLPF.IMailQueryStateReq} message MailQueryStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryStateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MailQueryStateReq message, length delimited. Does not implicitly {@link CLPF.MailQueryStateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {CLPF.IMailQueryStateReq} message MailQueryStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryStateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailQueryStateReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailQueryStateReq} MailQueryStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryStateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailQueryStateReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailQueryStateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailQueryStateReq} MailQueryStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryStateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailQueryStateReq message.
         * @function verify
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailQueryStateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MailQueryStateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailQueryStateReq} MailQueryStateReq
         */
        MailQueryStateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailQueryStateReq)
                return object;
            return new $root.CLPF.MailQueryStateReq();
        };

        /**
         * Creates a plain object from a MailQueryStateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailQueryStateReq
         * @static
         * @param {CLPF.MailQueryStateReq} message MailQueryStateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailQueryStateReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MailQueryStateReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailQueryStateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailQueryStateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailQueryStateReq;
    })();

    CLPF.MailQueryStateAck = (function() {

        /**
         * Properties of a MailQueryStateAck.
         * @memberof CLPF
         * @interface IMailQueryStateAck
         * @property {number|null} [errcode] MailQueryStateAck errcode
         * @property {boolean|null} [hasUnreadMail] MailQueryStateAck hasUnreadMail
         */

        /**
         * Constructs a new MailQueryStateAck.
         * @memberof CLPF
         * @classdesc Represents a MailQueryStateAck.
         * @implements IMailQueryStateAck
         * @constructor
         * @param {CLPF.IMailQueryStateAck=} [properties] Properties to set
         */
        function MailQueryStateAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailQueryStateAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailQueryStateAck
         * @instance
         */
        MailQueryStateAck.prototype.errcode = 0;

        /**
         * MailQueryStateAck hasUnreadMail.
         * @member {boolean} hasUnreadMail
         * @memberof CLPF.MailQueryStateAck
         * @instance
         */
        MailQueryStateAck.prototype.hasUnreadMail = false;

        /**
         * Creates a new MailQueryStateAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {CLPF.IMailQueryStateAck=} [properties] Properties to set
         * @returns {CLPF.MailQueryStateAck} MailQueryStateAck instance
         */
        MailQueryStateAck.create = function create(properties) {
            return new MailQueryStateAck(properties);
        };

        /**
         * Encodes the specified MailQueryStateAck message. Does not implicitly {@link CLPF.MailQueryStateAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {CLPF.IMailQueryStateAck} message MailQueryStateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryStateAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.hasUnreadMail != null && Object.hasOwnProperty.call(message, "hasUnreadMail"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasUnreadMail);
            return writer;
        };

        /**
         * Encodes the specified MailQueryStateAck message, length delimited. Does not implicitly {@link CLPF.MailQueryStateAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {CLPF.IMailQueryStateAck} message MailQueryStateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryStateAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailQueryStateAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailQueryStateAck} MailQueryStateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryStateAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailQueryStateAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.hasUnreadMail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailQueryStateAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailQueryStateAck} MailQueryStateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryStateAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailQueryStateAck message.
         * @function verify
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailQueryStateAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                if (typeof message.hasUnreadMail !== "boolean")
                    return "hasUnreadMail: boolean expected";
            return null;
        };

        /**
         * Creates a MailQueryStateAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailQueryStateAck} MailQueryStateAck
         */
        MailQueryStateAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailQueryStateAck)
                return object;
            var message = new $root.CLPF.MailQueryStateAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.hasUnreadMail != null)
                message.hasUnreadMail = Boolean(object.hasUnreadMail);
            return message;
        };

        /**
         * Creates a plain object from a MailQueryStateAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailQueryStateAck
         * @static
         * @param {CLPF.MailQueryStateAck} message MailQueryStateAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailQueryStateAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.hasUnreadMail = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                object.hasUnreadMail = message.hasUnreadMail;
            return object;
        };

        /**
         * Converts this MailQueryStateAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailQueryStateAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailQueryStateAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailQueryStateAck;
    })();

    CLPF.MailQueryAllIdsReq = (function() {

        /**
         * Properties of a MailQueryAllIdsReq.
         * @memberof CLPF
         * @interface IMailQueryAllIdsReq
         */

        /**
         * Constructs a new MailQueryAllIdsReq.
         * @memberof CLPF
         * @classdesc Represents a MailQueryAllIdsReq.
         * @implements IMailQueryAllIdsReq
         * @constructor
         * @param {CLPF.IMailQueryAllIdsReq=} [properties] Properties to set
         */
        function MailQueryAllIdsReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MailQueryAllIdsReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {CLPF.IMailQueryAllIdsReq=} [properties] Properties to set
         * @returns {CLPF.MailQueryAllIdsReq} MailQueryAllIdsReq instance
         */
        MailQueryAllIdsReq.create = function create(properties) {
            return new MailQueryAllIdsReq(properties);
        };

        /**
         * Encodes the specified MailQueryAllIdsReq message. Does not implicitly {@link CLPF.MailQueryAllIdsReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {CLPF.IMailQueryAllIdsReq} message MailQueryAllIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryAllIdsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MailQueryAllIdsReq message, length delimited. Does not implicitly {@link CLPF.MailQueryAllIdsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {CLPF.IMailQueryAllIdsReq} message MailQueryAllIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryAllIdsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailQueryAllIdsReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailQueryAllIdsReq} MailQueryAllIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryAllIdsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailQueryAllIdsReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailQueryAllIdsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailQueryAllIdsReq} MailQueryAllIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryAllIdsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailQueryAllIdsReq message.
         * @function verify
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailQueryAllIdsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MailQueryAllIdsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailQueryAllIdsReq} MailQueryAllIdsReq
         */
        MailQueryAllIdsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailQueryAllIdsReq)
                return object;
            return new $root.CLPF.MailQueryAllIdsReq();
        };

        /**
         * Creates a plain object from a MailQueryAllIdsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailQueryAllIdsReq
         * @static
         * @param {CLPF.MailQueryAllIdsReq} message MailQueryAllIdsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailQueryAllIdsReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MailQueryAllIdsReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailQueryAllIdsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailQueryAllIdsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailQueryAllIdsReq;
    })();

    CLPF.MailQueryAllIdsAck = (function() {

        /**
         * Properties of a MailQueryAllIdsAck.
         * @memberof CLPF
         * @interface IMailQueryAllIdsAck
         * @property {number|null} [errcode] MailQueryAllIdsAck errcode
         * @property {Array.<number>|null} [array] MailQueryAllIdsAck array
         */

        /**
         * Constructs a new MailQueryAllIdsAck.
         * @memberof CLPF
         * @classdesc Represents a MailQueryAllIdsAck.
         * @implements IMailQueryAllIdsAck
         * @constructor
         * @param {CLPF.IMailQueryAllIdsAck=} [properties] Properties to set
         */
        function MailQueryAllIdsAck(properties) {
            this.array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailQueryAllIdsAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailQueryAllIdsAck
         * @instance
         */
        MailQueryAllIdsAck.prototype.errcode = 0;

        /**
         * MailQueryAllIdsAck array.
         * @member {Array.<number>} array
         * @memberof CLPF.MailQueryAllIdsAck
         * @instance
         */
        MailQueryAllIdsAck.prototype.array = $util.emptyArray;

        /**
         * Creates a new MailQueryAllIdsAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {CLPF.IMailQueryAllIdsAck=} [properties] Properties to set
         * @returns {CLPF.MailQueryAllIdsAck} MailQueryAllIdsAck instance
         */
        MailQueryAllIdsAck.create = function create(properties) {
            return new MailQueryAllIdsAck(properties);
        };

        /**
         * Encodes the specified MailQueryAllIdsAck message. Does not implicitly {@link CLPF.MailQueryAllIdsAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {CLPF.IMailQueryAllIdsAck} message MailQueryAllIdsAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryAllIdsAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.array != null && message.array.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.array.length; ++i)
                    writer.int32(message.array[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MailQueryAllIdsAck message, length delimited. Does not implicitly {@link CLPF.MailQueryAllIdsAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {CLPF.IMailQueryAllIdsAck} message MailQueryAllIdsAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailQueryAllIdsAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailQueryAllIdsAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailQueryAllIdsAck} MailQueryAllIdsAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryAllIdsAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailQueryAllIdsAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.array && message.array.length))
                        message.array = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.array.push(reader.int32());
                    } else
                        message.array.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailQueryAllIdsAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailQueryAllIdsAck} MailQueryAllIdsAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailQueryAllIdsAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailQueryAllIdsAck message.
         * @function verify
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailQueryAllIdsAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.array != null && message.hasOwnProperty("array")) {
                if (!Array.isArray(message.array))
                    return "array: array expected";
                for (var i = 0; i < message.array.length; ++i)
                    if (!$util.isInteger(message.array[i]))
                        return "array: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a MailQueryAllIdsAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailQueryAllIdsAck} MailQueryAllIdsAck
         */
        MailQueryAllIdsAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailQueryAllIdsAck)
                return object;
            var message = new $root.CLPF.MailQueryAllIdsAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.array) {
                if (!Array.isArray(object.array))
                    throw TypeError(".CLPF.MailQueryAllIdsAck.array: array expected");
                message.array = [];
                for (var i = 0; i < object.array.length; ++i)
                    message.array[i] = object.array[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a MailQueryAllIdsAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailQueryAllIdsAck
         * @static
         * @param {CLPF.MailQueryAllIdsAck} message MailQueryAllIdsAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailQueryAllIdsAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.array = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.array && message.array.length) {
                object.array = [];
                for (var j = 0; j < message.array.length; ++j)
                    object.array[j] = message.array[j];
            }
            return object;
        };

        /**
         * Converts this MailQueryAllIdsAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailQueryAllIdsAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailQueryAllIdsAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailQueryAllIdsAck;
    })();

    CLPF.MailBatchQueryContentReq = (function() {

        /**
         * Properties of a MailBatchQueryContentReq.
         * @memberof CLPF
         * @interface IMailBatchQueryContentReq
         * @property {Array.<number>|null} [array] MailBatchQueryContentReq array
         */

        /**
         * Constructs a new MailBatchQueryContentReq.
         * @memberof CLPF
         * @classdesc Represents a MailBatchQueryContentReq.
         * @implements IMailBatchQueryContentReq
         * @constructor
         * @param {CLPF.IMailBatchQueryContentReq=} [properties] Properties to set
         */
        function MailBatchQueryContentReq(properties) {
            this.array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailBatchQueryContentReq array.
         * @member {Array.<number>} array
         * @memberof CLPF.MailBatchQueryContentReq
         * @instance
         */
        MailBatchQueryContentReq.prototype.array = $util.emptyArray;

        /**
         * Creates a new MailBatchQueryContentReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {CLPF.IMailBatchQueryContentReq=} [properties] Properties to set
         * @returns {CLPF.MailBatchQueryContentReq} MailBatchQueryContentReq instance
         */
        MailBatchQueryContentReq.create = function create(properties) {
            return new MailBatchQueryContentReq(properties);
        };

        /**
         * Encodes the specified MailBatchQueryContentReq message. Does not implicitly {@link CLPF.MailBatchQueryContentReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {CLPF.IMailBatchQueryContentReq} message MailBatchQueryContentReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailBatchQueryContentReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.array != null && message.array.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.array.length; ++i)
                    writer.int32(message.array[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MailBatchQueryContentReq message, length delimited. Does not implicitly {@link CLPF.MailBatchQueryContentReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {CLPF.IMailBatchQueryContentReq} message MailBatchQueryContentReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailBatchQueryContentReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailBatchQueryContentReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailBatchQueryContentReq} MailBatchQueryContentReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailBatchQueryContentReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailBatchQueryContentReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.array && message.array.length))
                        message.array = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.array.push(reader.int32());
                    } else
                        message.array.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailBatchQueryContentReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailBatchQueryContentReq} MailBatchQueryContentReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailBatchQueryContentReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailBatchQueryContentReq message.
         * @function verify
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailBatchQueryContentReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.array != null && message.hasOwnProperty("array")) {
                if (!Array.isArray(message.array))
                    return "array: array expected";
                for (var i = 0; i < message.array.length; ++i)
                    if (!$util.isInteger(message.array[i]))
                        return "array: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a MailBatchQueryContentReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailBatchQueryContentReq} MailBatchQueryContentReq
         */
        MailBatchQueryContentReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailBatchQueryContentReq)
                return object;
            var message = new $root.CLPF.MailBatchQueryContentReq();
            if (object.array) {
                if (!Array.isArray(object.array))
                    throw TypeError(".CLPF.MailBatchQueryContentReq.array: array expected");
                message.array = [];
                for (var i = 0; i < object.array.length; ++i)
                    message.array[i] = object.array[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a MailBatchQueryContentReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailBatchQueryContentReq
         * @static
         * @param {CLPF.MailBatchQueryContentReq} message MailBatchQueryContentReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailBatchQueryContentReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.array = [];
            if (message.array && message.array.length) {
                object.array = [];
                for (var j = 0; j < message.array.length; ++j)
                    object.array[j] = message.array[j];
            }
            return object;
        };

        /**
         * Converts this MailBatchQueryContentReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailBatchQueryContentReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailBatchQueryContentReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailBatchQueryContentReq;
    })();

    CLPF.MailBatchQueryContentAck = (function() {

        /**
         * Properties of a MailBatchQueryContentAck.
         * @memberof CLPF
         * @interface IMailBatchQueryContentAck
         * @property {number|null} [errcode] MailBatchQueryContentAck errcode
         * @property {Array.<number>|null} [invalidArray] MailBatchQueryContentAck invalidArray
         * @property {Array.<CLPF.IMailInfo>|null} [resultArray] MailBatchQueryContentAck resultArray
         */

        /**
         * Constructs a new MailBatchQueryContentAck.
         * @memberof CLPF
         * @classdesc Represents a MailBatchQueryContentAck.
         * @implements IMailBatchQueryContentAck
         * @constructor
         * @param {CLPF.IMailBatchQueryContentAck=} [properties] Properties to set
         */
        function MailBatchQueryContentAck(properties) {
            this.invalidArray = [];
            this.resultArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailBatchQueryContentAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailBatchQueryContentAck
         * @instance
         */
        MailBatchQueryContentAck.prototype.errcode = 0;

        /**
         * MailBatchQueryContentAck invalidArray.
         * @member {Array.<number>} invalidArray
         * @memberof CLPF.MailBatchQueryContentAck
         * @instance
         */
        MailBatchQueryContentAck.prototype.invalidArray = $util.emptyArray;

        /**
         * MailBatchQueryContentAck resultArray.
         * @member {Array.<CLPF.IMailInfo>} resultArray
         * @memberof CLPF.MailBatchQueryContentAck
         * @instance
         */
        MailBatchQueryContentAck.prototype.resultArray = $util.emptyArray;

        /**
         * Creates a new MailBatchQueryContentAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {CLPF.IMailBatchQueryContentAck=} [properties] Properties to set
         * @returns {CLPF.MailBatchQueryContentAck} MailBatchQueryContentAck instance
         */
        MailBatchQueryContentAck.create = function create(properties) {
            return new MailBatchQueryContentAck(properties);
        };

        /**
         * Encodes the specified MailBatchQueryContentAck message. Does not implicitly {@link CLPF.MailBatchQueryContentAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {CLPF.IMailBatchQueryContentAck} message MailBatchQueryContentAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailBatchQueryContentAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.invalidArray != null && message.invalidArray.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.invalidArray.length; ++i)
                    writer.int32(message.invalidArray[i]);
                writer.ldelim();
            }
            if (message.resultArray != null && message.resultArray.length)
                for (var i = 0; i < message.resultArray.length; ++i)
                    $root.CLPF.MailInfo.encode(message.resultArray[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MailBatchQueryContentAck message, length delimited. Does not implicitly {@link CLPF.MailBatchQueryContentAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {CLPF.IMailBatchQueryContentAck} message MailBatchQueryContentAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailBatchQueryContentAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailBatchQueryContentAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailBatchQueryContentAck} MailBatchQueryContentAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailBatchQueryContentAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailBatchQueryContentAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.invalidArray && message.invalidArray.length))
                        message.invalidArray = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.invalidArray.push(reader.int32());
                    } else
                        message.invalidArray.push(reader.int32());
                    break;
                case 3:
                    if (!(message.resultArray && message.resultArray.length))
                        message.resultArray = [];
                    message.resultArray.push($root.CLPF.MailInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailBatchQueryContentAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailBatchQueryContentAck} MailBatchQueryContentAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailBatchQueryContentAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailBatchQueryContentAck message.
         * @function verify
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailBatchQueryContentAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.invalidArray != null && message.hasOwnProperty("invalidArray")) {
                if (!Array.isArray(message.invalidArray))
                    return "invalidArray: array expected";
                for (var i = 0; i < message.invalidArray.length; ++i)
                    if (!$util.isInteger(message.invalidArray[i]))
                        return "invalidArray: integer[] expected";
            }
            if (message.resultArray != null && message.hasOwnProperty("resultArray")) {
                if (!Array.isArray(message.resultArray))
                    return "resultArray: array expected";
                for (var i = 0; i < message.resultArray.length; ++i) {
                    var error = $root.CLPF.MailInfo.verify(message.resultArray[i]);
                    if (error)
                        return "resultArray." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MailBatchQueryContentAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailBatchQueryContentAck} MailBatchQueryContentAck
         */
        MailBatchQueryContentAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailBatchQueryContentAck)
                return object;
            var message = new $root.CLPF.MailBatchQueryContentAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.invalidArray) {
                if (!Array.isArray(object.invalidArray))
                    throw TypeError(".CLPF.MailBatchQueryContentAck.invalidArray: array expected");
                message.invalidArray = [];
                for (var i = 0; i < object.invalidArray.length; ++i)
                    message.invalidArray[i] = object.invalidArray[i] | 0;
            }
            if (object.resultArray) {
                if (!Array.isArray(object.resultArray))
                    throw TypeError(".CLPF.MailBatchQueryContentAck.resultArray: array expected");
                message.resultArray = [];
                for (var i = 0; i < object.resultArray.length; ++i) {
                    if (typeof object.resultArray[i] !== "object")
                        throw TypeError(".CLPF.MailBatchQueryContentAck.resultArray: object expected");
                    message.resultArray[i] = $root.CLPF.MailInfo.fromObject(object.resultArray[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MailBatchQueryContentAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailBatchQueryContentAck
         * @static
         * @param {CLPF.MailBatchQueryContentAck} message MailBatchQueryContentAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailBatchQueryContentAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.invalidArray = [];
                object.resultArray = [];
            }
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.invalidArray && message.invalidArray.length) {
                object.invalidArray = [];
                for (var j = 0; j < message.invalidArray.length; ++j)
                    object.invalidArray[j] = message.invalidArray[j];
            }
            if (message.resultArray && message.resultArray.length) {
                object.resultArray = [];
                for (var j = 0; j < message.resultArray.length; ++j)
                    object.resultArray[j] = $root.CLPF.MailInfo.toObject(message.resultArray[j], options);
            }
            return object;
        };

        /**
         * Converts this MailBatchQueryContentAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailBatchQueryContentAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailBatchQueryContentAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailBatchQueryContentAck;
    })();

    CLPF.MailAccessReq = (function() {

        /**
         * Properties of a MailAccessReq.
         * @memberof CLPF
         * @interface IMailAccessReq
         * @property {number|null} [mailId] MailAccessReq mailId
         */

        /**
         * Constructs a new MailAccessReq.
         * @memberof CLPF
         * @classdesc Represents a MailAccessReq.
         * @implements IMailAccessReq
         * @constructor
         * @param {CLPF.IMailAccessReq=} [properties] Properties to set
         */
        function MailAccessReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailAccessReq mailId.
         * @member {number} mailId
         * @memberof CLPF.MailAccessReq
         * @instance
         */
        MailAccessReq.prototype.mailId = 0;

        /**
         * Creates a new MailAccessReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {CLPF.IMailAccessReq=} [properties] Properties to set
         * @returns {CLPF.MailAccessReq} MailAccessReq instance
         */
        MailAccessReq.create = function create(properties) {
            return new MailAccessReq(properties);
        };

        /**
         * Encodes the specified MailAccessReq message. Does not implicitly {@link CLPF.MailAccessReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {CLPF.IMailAccessReq} message MailAccessReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailAccessReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && Object.hasOwnProperty.call(message, "mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Encodes the specified MailAccessReq message, length delimited. Does not implicitly {@link CLPF.MailAccessReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {CLPF.IMailAccessReq} message MailAccessReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailAccessReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailAccessReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailAccessReq} MailAccessReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailAccessReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailAccessReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailAccessReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailAccessReq} MailAccessReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailAccessReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailAccessReq message.
         * @function verify
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailAccessReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                if (!$util.isInteger(message.mailId))
                    return "mailId: integer expected";
            return null;
        };

        /**
         * Creates a MailAccessReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailAccessReq} MailAccessReq
         */
        MailAccessReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailAccessReq)
                return object;
            var message = new $root.CLPF.MailAccessReq();
            if (object.mailId != null)
                message.mailId = object.mailId | 0;
            return message;
        };

        /**
         * Creates a plain object from a MailAccessReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailAccessReq
         * @static
         * @param {CLPF.MailAccessReq} message MailAccessReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailAccessReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailId = 0;
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                object.mailId = message.mailId;
            return object;
        };

        /**
         * Converts this MailAccessReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailAccessReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailAccessReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailAccessReq;
    })();

    CLPF.MailAccessAck = (function() {

        /**
         * Properties of a MailAccessAck.
         * @memberof CLPF
         * @interface IMailAccessAck
         * @property {number|null} [errcode] MailAccessAck errcode
         * @property {boolean|null} [hasUnreadMail] MailAccessAck hasUnreadMail
         */

        /**
         * Constructs a new MailAccessAck.
         * @memberof CLPF
         * @classdesc Represents a MailAccessAck.
         * @implements IMailAccessAck
         * @constructor
         * @param {CLPF.IMailAccessAck=} [properties] Properties to set
         */
        function MailAccessAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailAccessAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailAccessAck
         * @instance
         */
        MailAccessAck.prototype.errcode = 0;

        /**
         * MailAccessAck hasUnreadMail.
         * @member {boolean} hasUnreadMail
         * @memberof CLPF.MailAccessAck
         * @instance
         */
        MailAccessAck.prototype.hasUnreadMail = false;

        /**
         * Creates a new MailAccessAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {CLPF.IMailAccessAck=} [properties] Properties to set
         * @returns {CLPF.MailAccessAck} MailAccessAck instance
         */
        MailAccessAck.create = function create(properties) {
            return new MailAccessAck(properties);
        };

        /**
         * Encodes the specified MailAccessAck message. Does not implicitly {@link CLPF.MailAccessAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {CLPF.IMailAccessAck} message MailAccessAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailAccessAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.hasUnreadMail != null && Object.hasOwnProperty.call(message, "hasUnreadMail"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasUnreadMail);
            return writer;
        };

        /**
         * Encodes the specified MailAccessAck message, length delimited. Does not implicitly {@link CLPF.MailAccessAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {CLPF.IMailAccessAck} message MailAccessAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailAccessAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailAccessAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailAccessAck} MailAccessAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailAccessAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailAccessAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.hasUnreadMail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailAccessAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailAccessAck} MailAccessAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailAccessAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailAccessAck message.
         * @function verify
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailAccessAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                if (typeof message.hasUnreadMail !== "boolean")
                    return "hasUnreadMail: boolean expected";
            return null;
        };

        /**
         * Creates a MailAccessAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailAccessAck} MailAccessAck
         */
        MailAccessAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailAccessAck)
                return object;
            var message = new $root.CLPF.MailAccessAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.hasUnreadMail != null)
                message.hasUnreadMail = Boolean(object.hasUnreadMail);
            return message;
        };

        /**
         * Creates a plain object from a MailAccessAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailAccessAck
         * @static
         * @param {CLPF.MailAccessAck} message MailAccessAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailAccessAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.hasUnreadMail = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                object.hasUnreadMail = message.hasUnreadMail;
            return object;
        };

        /**
         * Converts this MailAccessAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailAccessAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailAccessAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailAccessAck;
    })();

    CLPF.MailFetchItemReq = (function() {

        /**
         * Properties of a MailFetchItemReq.
         * @memberof CLPF
         * @interface IMailFetchItemReq
         * @property {number|null} [mailId] MailFetchItemReq mailId
         */

        /**
         * Constructs a new MailFetchItemReq.
         * @memberof CLPF
         * @classdesc Represents a MailFetchItemReq.
         * @implements IMailFetchItemReq
         * @constructor
         * @param {CLPF.IMailFetchItemReq=} [properties] Properties to set
         */
        function MailFetchItemReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailFetchItemReq mailId.
         * @member {number} mailId
         * @memberof CLPF.MailFetchItemReq
         * @instance
         */
        MailFetchItemReq.prototype.mailId = 0;

        /**
         * Creates a new MailFetchItemReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {CLPF.IMailFetchItemReq=} [properties] Properties to set
         * @returns {CLPF.MailFetchItemReq} MailFetchItemReq instance
         */
        MailFetchItemReq.create = function create(properties) {
            return new MailFetchItemReq(properties);
        };

        /**
         * Encodes the specified MailFetchItemReq message. Does not implicitly {@link CLPF.MailFetchItemReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {CLPF.IMailFetchItemReq} message MailFetchItemReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailFetchItemReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && Object.hasOwnProperty.call(message, "mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Encodes the specified MailFetchItemReq message, length delimited. Does not implicitly {@link CLPF.MailFetchItemReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {CLPF.IMailFetchItemReq} message MailFetchItemReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailFetchItemReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailFetchItemReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailFetchItemReq} MailFetchItemReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailFetchItemReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailFetchItemReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailFetchItemReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailFetchItemReq} MailFetchItemReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailFetchItemReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailFetchItemReq message.
         * @function verify
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailFetchItemReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                if (!$util.isInteger(message.mailId))
                    return "mailId: integer expected";
            return null;
        };

        /**
         * Creates a MailFetchItemReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailFetchItemReq} MailFetchItemReq
         */
        MailFetchItemReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailFetchItemReq)
                return object;
            var message = new $root.CLPF.MailFetchItemReq();
            if (object.mailId != null)
                message.mailId = object.mailId | 0;
            return message;
        };

        /**
         * Creates a plain object from a MailFetchItemReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailFetchItemReq
         * @static
         * @param {CLPF.MailFetchItemReq} message MailFetchItemReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailFetchItemReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailId = 0;
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                object.mailId = message.mailId;
            return object;
        };

        /**
         * Converts this MailFetchItemReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailFetchItemReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailFetchItemReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailFetchItemReq;
    })();

    CLPF.MailFetchItemAck = (function() {

        /**
         * Properties of a MailFetchItemAck.
         * @memberof CLPF
         * @interface IMailFetchItemAck
         * @property {number|null} [errcode] MailFetchItemAck errcode
         * @property {Array.<CLPF.IItemInfo>|null} [items] MailFetchItemAck items
         * @property {boolean|null} [hasUnreadMail] MailFetchItemAck hasUnreadMail
         */

        /**
         * Constructs a new MailFetchItemAck.
         * @memberof CLPF
         * @classdesc Represents a MailFetchItemAck.
         * @implements IMailFetchItemAck
         * @constructor
         * @param {CLPF.IMailFetchItemAck=} [properties] Properties to set
         */
        function MailFetchItemAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailFetchItemAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailFetchItemAck
         * @instance
         */
        MailFetchItemAck.prototype.errcode = 0;

        /**
         * MailFetchItemAck items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.MailFetchItemAck
         * @instance
         */
        MailFetchItemAck.prototype.items = $util.emptyArray;

        /**
         * MailFetchItemAck hasUnreadMail.
         * @member {boolean} hasUnreadMail
         * @memberof CLPF.MailFetchItemAck
         * @instance
         */
        MailFetchItemAck.prototype.hasUnreadMail = false;

        /**
         * Creates a new MailFetchItemAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {CLPF.IMailFetchItemAck=} [properties] Properties to set
         * @returns {CLPF.MailFetchItemAck} MailFetchItemAck instance
         */
        MailFetchItemAck.create = function create(properties) {
            return new MailFetchItemAck(properties);
        };

        /**
         * Encodes the specified MailFetchItemAck message. Does not implicitly {@link CLPF.MailFetchItemAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {CLPF.IMailFetchItemAck} message MailFetchItemAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailFetchItemAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hasUnreadMail != null && Object.hasOwnProperty.call(message, "hasUnreadMail"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasUnreadMail);
            return writer;
        };

        /**
         * Encodes the specified MailFetchItemAck message, length delimited. Does not implicitly {@link CLPF.MailFetchItemAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {CLPF.IMailFetchItemAck} message MailFetchItemAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailFetchItemAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailFetchItemAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailFetchItemAck} MailFetchItemAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailFetchItemAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailFetchItemAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.hasUnreadMail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailFetchItemAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailFetchItemAck} MailFetchItemAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailFetchItemAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailFetchItemAck message.
         * @function verify
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailFetchItemAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                if (typeof message.hasUnreadMail !== "boolean")
                    return "hasUnreadMail: boolean expected";
            return null;
        };

        /**
         * Creates a MailFetchItemAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailFetchItemAck} MailFetchItemAck
         */
        MailFetchItemAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailFetchItemAck)
                return object;
            var message = new $root.CLPF.MailFetchItemAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.MailFetchItemAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.MailFetchItemAck.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            if (object.hasUnreadMail != null)
                message.hasUnreadMail = Boolean(object.hasUnreadMail);
            return message;
        };

        /**
         * Creates a plain object from a MailFetchItemAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailFetchItemAck
         * @static
         * @param {CLPF.MailFetchItemAck} message MailFetchItemAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailFetchItemAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.errcode = 0;
                object.hasUnreadMail = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                object.hasUnreadMail = message.hasUnreadMail;
            return object;
        };

        /**
         * Converts this MailFetchItemAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailFetchItemAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailFetchItemAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailFetchItemAck;
    })();

    CLPF.MailRemoveReq = (function() {

        /**
         * Properties of a MailRemoveReq.
         * @memberof CLPF
         * @interface IMailRemoveReq
         * @property {number|null} [removeType] MailRemoveReq removeType
         * @property {Array.<number>|null} [removeIds] MailRemoveReq removeIds
         */

        /**
         * Constructs a new MailRemoveReq.
         * @memberof CLPF
         * @classdesc Represents a MailRemoveReq.
         * @implements IMailRemoveReq
         * @constructor
         * @param {CLPF.IMailRemoveReq=} [properties] Properties to set
         */
        function MailRemoveReq(properties) {
            this.removeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRemoveReq removeType.
         * @member {number} removeType
         * @memberof CLPF.MailRemoveReq
         * @instance
         */
        MailRemoveReq.prototype.removeType = 0;

        /**
         * MailRemoveReq removeIds.
         * @member {Array.<number>} removeIds
         * @memberof CLPF.MailRemoveReq
         * @instance
         */
        MailRemoveReq.prototype.removeIds = $util.emptyArray;

        /**
         * Creates a new MailRemoveReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {CLPF.IMailRemoveReq=} [properties] Properties to set
         * @returns {CLPF.MailRemoveReq} MailRemoveReq instance
         */
        MailRemoveReq.create = function create(properties) {
            return new MailRemoveReq(properties);
        };

        /**
         * Encodes the specified MailRemoveReq message. Does not implicitly {@link CLPF.MailRemoveReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {CLPF.IMailRemoveReq} message MailRemoveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRemoveReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.removeType != null && Object.hasOwnProperty.call(message, "removeType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.removeType);
            if (message.removeIds != null && message.removeIds.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.removeIds.length; ++i)
                    writer.int32(message.removeIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MailRemoveReq message, length delimited. Does not implicitly {@link CLPF.MailRemoveReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {CLPF.IMailRemoveReq} message MailRemoveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRemoveReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRemoveReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailRemoveReq} MailRemoveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRemoveReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailRemoveReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.removeType = reader.int32();
                    break;
                case 2:
                    if (!(message.removeIds && message.removeIds.length))
                        message.removeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.removeIds.push(reader.int32());
                    } else
                        message.removeIds.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRemoveReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailRemoveReq} MailRemoveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRemoveReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRemoveReq message.
         * @function verify
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRemoveReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.removeType != null && message.hasOwnProperty("removeType"))
                if (!$util.isInteger(message.removeType))
                    return "removeType: integer expected";
            if (message.removeIds != null && message.hasOwnProperty("removeIds")) {
                if (!Array.isArray(message.removeIds))
                    return "removeIds: array expected";
                for (var i = 0; i < message.removeIds.length; ++i)
                    if (!$util.isInteger(message.removeIds[i]))
                        return "removeIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a MailRemoveReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailRemoveReq} MailRemoveReq
         */
        MailRemoveReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailRemoveReq)
                return object;
            var message = new $root.CLPF.MailRemoveReq();
            if (object.removeType != null)
                message.removeType = object.removeType | 0;
            if (object.removeIds) {
                if (!Array.isArray(object.removeIds))
                    throw TypeError(".CLPF.MailRemoveReq.removeIds: array expected");
                message.removeIds = [];
                for (var i = 0; i < object.removeIds.length; ++i)
                    message.removeIds[i] = object.removeIds[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a MailRemoveReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailRemoveReq
         * @static
         * @param {CLPF.MailRemoveReq} message MailRemoveReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailRemoveReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.removeIds = [];
            if (options.defaults)
                object.removeType = 0;
            if (message.removeType != null && message.hasOwnProperty("removeType"))
                object.removeType = message.removeType;
            if (message.removeIds && message.removeIds.length) {
                object.removeIds = [];
                for (var j = 0; j < message.removeIds.length; ++j)
                    object.removeIds[j] = message.removeIds[j];
            }
            return object;
        };

        /**
         * Converts this MailRemoveReq to JSON.
         * @function toJSON
         * @memberof CLPF.MailRemoveReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailRemoveReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailRemoveReq;
    })();

    CLPF.MailRemoveAck = (function() {

        /**
         * Properties of a MailRemoveAck.
         * @memberof CLPF
         * @interface IMailRemoveAck
         * @property {number|null} [errcode] MailRemoveAck errcode
         * @property {boolean|null} [hasUnreadMail] MailRemoveAck hasUnreadMail
         * @property {Array.<number>|null} [removedIds] MailRemoveAck removedIds
         */

        /**
         * Constructs a new MailRemoveAck.
         * @memberof CLPF
         * @classdesc Represents a MailRemoveAck.
         * @implements IMailRemoveAck
         * @constructor
         * @param {CLPF.IMailRemoveAck=} [properties] Properties to set
         */
        function MailRemoveAck(properties) {
            this.removedIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRemoveAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MailRemoveAck
         * @instance
         */
        MailRemoveAck.prototype.errcode = 0;

        /**
         * MailRemoveAck hasUnreadMail.
         * @member {boolean} hasUnreadMail
         * @memberof CLPF.MailRemoveAck
         * @instance
         */
        MailRemoveAck.prototype.hasUnreadMail = false;

        /**
         * MailRemoveAck removedIds.
         * @member {Array.<number>} removedIds
         * @memberof CLPF.MailRemoveAck
         * @instance
         */
        MailRemoveAck.prototype.removedIds = $util.emptyArray;

        /**
         * Creates a new MailRemoveAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {CLPF.IMailRemoveAck=} [properties] Properties to set
         * @returns {CLPF.MailRemoveAck} MailRemoveAck instance
         */
        MailRemoveAck.create = function create(properties) {
            return new MailRemoveAck(properties);
        };

        /**
         * Encodes the specified MailRemoveAck message. Does not implicitly {@link CLPF.MailRemoveAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {CLPF.IMailRemoveAck} message MailRemoveAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRemoveAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.hasUnreadMail != null && Object.hasOwnProperty.call(message, "hasUnreadMail"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasUnreadMail);
            if (message.removedIds != null && message.removedIds.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.removedIds.length; ++i)
                    writer.int32(message.removedIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MailRemoveAck message, length delimited. Does not implicitly {@link CLPF.MailRemoveAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {CLPF.IMailRemoveAck} message MailRemoveAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRemoveAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRemoveAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailRemoveAck} MailRemoveAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRemoveAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailRemoveAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.hasUnreadMail = reader.bool();
                    break;
                case 3:
                    if (!(message.removedIds && message.removedIds.length))
                        message.removedIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.removedIds.push(reader.int32());
                    } else
                        message.removedIds.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRemoveAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailRemoveAck} MailRemoveAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRemoveAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRemoveAck message.
         * @function verify
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRemoveAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                if (typeof message.hasUnreadMail !== "boolean")
                    return "hasUnreadMail: boolean expected";
            if (message.removedIds != null && message.hasOwnProperty("removedIds")) {
                if (!Array.isArray(message.removedIds))
                    return "removedIds: array expected";
                for (var i = 0; i < message.removedIds.length; ++i)
                    if (!$util.isInteger(message.removedIds[i]))
                        return "removedIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a MailRemoveAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailRemoveAck} MailRemoveAck
         */
        MailRemoveAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailRemoveAck)
                return object;
            var message = new $root.CLPF.MailRemoveAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.hasUnreadMail != null)
                message.hasUnreadMail = Boolean(object.hasUnreadMail);
            if (object.removedIds) {
                if (!Array.isArray(object.removedIds))
                    throw TypeError(".CLPF.MailRemoveAck.removedIds: array expected");
                message.removedIds = [];
                for (var i = 0; i < object.removedIds.length; ++i)
                    message.removedIds[i] = object.removedIds[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a MailRemoveAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailRemoveAck
         * @static
         * @param {CLPF.MailRemoveAck} message MailRemoveAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailRemoveAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.removedIds = [];
            if (options.defaults) {
                object.errcode = 0;
                object.hasUnreadMail = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.hasUnreadMail != null && message.hasOwnProperty("hasUnreadMail"))
                object.hasUnreadMail = message.hasUnreadMail;
            if (message.removedIds && message.removedIds.length) {
                object.removedIds = [];
                for (var j = 0; j < message.removedIds.length; ++j)
                    object.removedIds[j] = message.removedIds[j];
            }
            return object;
        };

        /**
         * Converts this MailRemoveAck to JSON.
         * @function toJSON
         * @memberof CLPF.MailRemoveAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailRemoveAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailRemoveAck;
    })();

    CLPF.MailArriveNtf = (function() {

        /**
         * Properties of a MailArriveNtf.
         * @memberof CLPF
         * @interface IMailArriveNtf
         * @property {CLPF.IMailInfo|null} [mailInfo] MailArriveNtf mailInfo
         */

        /**
         * Constructs a new MailArriveNtf.
         * @memberof CLPF
         * @classdesc Represents a MailArriveNtf.
         * @implements IMailArriveNtf
         * @constructor
         * @param {CLPF.IMailArriveNtf=} [properties] Properties to set
         */
        function MailArriveNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailArriveNtf mailInfo.
         * @member {CLPF.IMailInfo|null|undefined} mailInfo
         * @memberof CLPF.MailArriveNtf
         * @instance
         */
        MailArriveNtf.prototype.mailInfo = null;

        /**
         * Creates a new MailArriveNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {CLPF.IMailArriveNtf=} [properties] Properties to set
         * @returns {CLPF.MailArriveNtf} MailArriveNtf instance
         */
        MailArriveNtf.create = function create(properties) {
            return new MailArriveNtf(properties);
        };

        /**
         * Encodes the specified MailArriveNtf message. Does not implicitly {@link CLPF.MailArriveNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {CLPF.IMailArriveNtf} message MailArriveNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailArriveNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailInfo != null && Object.hasOwnProperty.call(message, "mailInfo"))
                $root.CLPF.MailInfo.encode(message.mailInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MailArriveNtf message, length delimited. Does not implicitly {@link CLPF.MailArriveNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {CLPF.IMailArriveNtf} message MailArriveNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailArriveNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailArriveNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MailArriveNtf} MailArriveNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailArriveNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MailArriveNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailInfo = $root.CLPF.MailInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailArriveNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MailArriveNtf} MailArriveNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailArriveNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailArriveNtf message.
         * @function verify
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailArriveNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailInfo != null && message.hasOwnProperty("mailInfo")) {
                var error = $root.CLPF.MailInfo.verify(message.mailInfo);
                if (error)
                    return "mailInfo." + error;
            }
            return null;
        };

        /**
         * Creates a MailArriveNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MailArriveNtf} MailArriveNtf
         */
        MailArriveNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MailArriveNtf)
                return object;
            var message = new $root.CLPF.MailArriveNtf();
            if (object.mailInfo != null) {
                if (typeof object.mailInfo !== "object")
                    throw TypeError(".CLPF.MailArriveNtf.mailInfo: object expected");
                message.mailInfo = $root.CLPF.MailInfo.fromObject(object.mailInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a MailArriveNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MailArriveNtf
         * @static
         * @param {CLPF.MailArriveNtf} message MailArriveNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailArriveNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailInfo = null;
            if (message.mailInfo != null && message.hasOwnProperty("mailInfo"))
                object.mailInfo = $root.CLPF.MailInfo.toObject(message.mailInfo, options);
            return object;
        };

        /**
         * Converts this MailArriveNtf to JSON.
         * @function toJSON
         * @memberof CLPF.MailArriveNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailArriveNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailArriveNtf;
    })();

    CLPF.MessageBroadcastNtf = (function() {

        /**
         * Properties of a MessageBroadcastNtf.
         * @memberof CLPF
         * @interface IMessageBroadcastNtf
         * @property {number|null} [type] MessageBroadcastNtf type
         * @property {string|null} [content] MessageBroadcastNtf content
         */

        /**
         * Constructs a new MessageBroadcastNtf.
         * @memberof CLPF
         * @classdesc Represents a MessageBroadcastNtf.
         * @implements IMessageBroadcastNtf
         * @constructor
         * @param {CLPF.IMessageBroadcastNtf=} [properties] Properties to set
         */
        function MessageBroadcastNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageBroadcastNtf type.
         * @member {number} type
         * @memberof CLPF.MessageBroadcastNtf
         * @instance
         */
        MessageBroadcastNtf.prototype.type = 0;

        /**
         * MessageBroadcastNtf content.
         * @member {string} content
         * @memberof CLPF.MessageBroadcastNtf
         * @instance
         */
        MessageBroadcastNtf.prototype.content = "";

        /**
         * Creates a new MessageBroadcastNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {CLPF.IMessageBroadcastNtf=} [properties] Properties to set
         * @returns {CLPF.MessageBroadcastNtf} MessageBroadcastNtf instance
         */
        MessageBroadcastNtf.create = function create(properties) {
            return new MessageBroadcastNtf(properties);
        };

        /**
         * Encodes the specified MessageBroadcastNtf message. Does not implicitly {@link CLPF.MessageBroadcastNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {CLPF.IMessageBroadcastNtf} message MessageBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageBroadcastNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified MessageBroadcastNtf message, length delimited. Does not implicitly {@link CLPF.MessageBroadcastNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {CLPF.IMessageBroadcastNtf} message MessageBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageBroadcastNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageBroadcastNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MessageBroadcastNtf} MessageBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageBroadcastNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MessageBroadcastNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageBroadcastNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MessageBroadcastNtf} MessageBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageBroadcastNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageBroadcastNtf message.
         * @function verify
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageBroadcastNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a MessageBroadcastNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MessageBroadcastNtf} MessageBroadcastNtf
         */
        MessageBroadcastNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MessageBroadcastNtf)
                return object;
            var message = new $root.CLPF.MessageBroadcastNtf();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a MessageBroadcastNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MessageBroadcastNtf
         * @static
         * @param {CLPF.MessageBroadcastNtf} message MessageBroadcastNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageBroadcastNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.content = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this MessageBroadcastNtf to JSON.
         * @function toJSON
         * @memberof CLPF.MessageBroadcastNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageBroadcastNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageBroadcastNtf;
    })();

    CLPF.TotalHanselBroadcastNtf = (function() {

        /**
         * Properties of a TotalHanselBroadcastNtf.
         * @memberof CLPF
         * @interface ITotalHanselBroadcastNtf
         * @property {number|null} [gameType] TotalHanselBroadcastNtf gameType
         * @property {number|Long|null} [totalHansel] TotalHanselBroadcastNtf totalHansel
         */

        /**
         * Constructs a new TotalHanselBroadcastNtf.
         * @memberof CLPF
         * @classdesc Represents a TotalHanselBroadcastNtf.
         * @implements ITotalHanselBroadcastNtf
         * @constructor
         * @param {CLPF.ITotalHanselBroadcastNtf=} [properties] Properties to set
         */
        function TotalHanselBroadcastNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TotalHanselBroadcastNtf gameType.
         * @member {number} gameType
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @instance
         */
        TotalHanselBroadcastNtf.prototype.gameType = 0;

        /**
         * TotalHanselBroadcastNtf totalHansel.
         * @member {number|Long} totalHansel
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @instance
         */
        TotalHanselBroadcastNtf.prototype.totalHansel = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TotalHanselBroadcastNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {CLPF.ITotalHanselBroadcastNtf=} [properties] Properties to set
         * @returns {CLPF.TotalHanselBroadcastNtf} TotalHanselBroadcastNtf instance
         */
        TotalHanselBroadcastNtf.create = function create(properties) {
            return new TotalHanselBroadcastNtf(properties);
        };

        /**
         * Encodes the specified TotalHanselBroadcastNtf message. Does not implicitly {@link CLPF.TotalHanselBroadcastNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {CLPF.ITotalHanselBroadcastNtf} message TotalHanselBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TotalHanselBroadcastNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameType);
            if (message.totalHansel != null && Object.hasOwnProperty.call(message, "totalHansel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalHansel);
            return writer;
        };

        /**
         * Encodes the specified TotalHanselBroadcastNtf message, length delimited. Does not implicitly {@link CLPF.TotalHanselBroadcastNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {CLPF.ITotalHanselBroadcastNtf} message TotalHanselBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TotalHanselBroadcastNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TotalHanselBroadcastNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.TotalHanselBroadcastNtf} TotalHanselBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TotalHanselBroadcastNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.TotalHanselBroadcastNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.int32();
                    break;
                case 2:
                    message.totalHansel = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TotalHanselBroadcastNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.TotalHanselBroadcastNtf} TotalHanselBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TotalHanselBroadcastNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TotalHanselBroadcastNtf message.
         * @function verify
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TotalHanselBroadcastNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            if (message.totalHansel != null && message.hasOwnProperty("totalHansel"))
                if (!$util.isInteger(message.totalHansel) && !(message.totalHansel && $util.isInteger(message.totalHansel.low) && $util.isInteger(message.totalHansel.high)))
                    return "totalHansel: integer|Long expected";
            return null;
        };

        /**
         * Creates a TotalHanselBroadcastNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.TotalHanselBroadcastNtf} TotalHanselBroadcastNtf
         */
        TotalHanselBroadcastNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.TotalHanselBroadcastNtf)
                return object;
            var message = new $root.CLPF.TotalHanselBroadcastNtf();
            if (object.gameType != null)
                message.gameType = object.gameType | 0;
            if (object.totalHansel != null)
                if ($util.Long)
                    (message.totalHansel = $util.Long.fromValue(object.totalHansel)).unsigned = false;
                else if (typeof object.totalHansel === "string")
                    message.totalHansel = parseInt(object.totalHansel, 10);
                else if (typeof object.totalHansel === "number")
                    message.totalHansel = object.totalHansel;
                else if (typeof object.totalHansel === "object")
                    message.totalHansel = new $util.LongBits(object.totalHansel.low >>> 0, object.totalHansel.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TotalHanselBroadcastNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @static
         * @param {CLPF.TotalHanselBroadcastNtf} message TotalHanselBroadcastNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TotalHanselBroadcastNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gameType = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalHansel = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalHansel = options.longs === String ? "0" : 0;
            }
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            if (message.totalHansel != null && message.hasOwnProperty("totalHansel"))
                if (typeof message.totalHansel === "number")
                    object.totalHansel = options.longs === String ? String(message.totalHansel) : message.totalHansel;
                else
                    object.totalHansel = options.longs === String ? $util.Long.prototype.toString.call(message.totalHansel) : options.longs === Number ? new $util.LongBits(message.totalHansel.low >>> 0, message.totalHansel.high >>> 0).toNumber() : message.totalHansel;
            return object;
        };

        /**
         * Converts this TotalHanselBroadcastNtf to JSON.
         * @function toJSON
         * @memberof CLPF.TotalHanselBroadcastNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TotalHanselBroadcastNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TotalHanselBroadcastNtf;
    })();

    CLPF.GameHanselItem = (function() {

        /**
         * Properties of a GameHanselItem.
         * @memberof CLPF
         * @interface IGameHanselItem
         * @property {number|null} [type] GameHanselItem type
         * @property {number|Long|null} [gameHansel] GameHanselItem gameHansel
         */

        /**
         * Constructs a new GameHanselItem.
         * @memberof CLPF
         * @classdesc Represents a GameHanselItem.
         * @implements IGameHanselItem
         * @constructor
         * @param {CLPF.IGameHanselItem=} [properties] Properties to set
         */
        function GameHanselItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameHanselItem type.
         * @member {number} type
         * @memberof CLPF.GameHanselItem
         * @instance
         */
        GameHanselItem.prototype.type = 0;

        /**
         * GameHanselItem gameHansel.
         * @member {number|Long} gameHansel
         * @memberof CLPF.GameHanselItem
         * @instance
         */
        GameHanselItem.prototype.gameHansel = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GameHanselItem instance using the specified properties.
         * @function create
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {CLPF.IGameHanselItem=} [properties] Properties to set
         * @returns {CLPF.GameHanselItem} GameHanselItem instance
         */
        GameHanselItem.create = function create(properties) {
            return new GameHanselItem(properties);
        };

        /**
         * Encodes the specified GameHanselItem message. Does not implicitly {@link CLPF.GameHanselItem.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {CLPF.IGameHanselItem} message GameHanselItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameHanselItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.gameHansel != null && Object.hasOwnProperty.call(message, "gameHansel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gameHansel);
            return writer;
        };

        /**
         * Encodes the specified GameHanselItem message, length delimited. Does not implicitly {@link CLPF.GameHanselItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {CLPF.IGameHanselItem} message GameHanselItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameHanselItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameHanselItem message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GameHanselItem} GameHanselItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameHanselItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GameHanselItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.gameHansel = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameHanselItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GameHanselItem} GameHanselItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameHanselItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameHanselItem message.
         * @function verify
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameHanselItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.gameHansel != null && message.hasOwnProperty("gameHansel"))
                if (!$util.isInteger(message.gameHansel) && !(message.gameHansel && $util.isInteger(message.gameHansel.low) && $util.isInteger(message.gameHansel.high)))
                    return "gameHansel: integer|Long expected";
            return null;
        };

        /**
         * Creates a GameHanselItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GameHanselItem} GameHanselItem
         */
        GameHanselItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GameHanselItem)
                return object;
            var message = new $root.CLPF.GameHanselItem();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.gameHansel != null)
                if ($util.Long)
                    (message.gameHansel = $util.Long.fromValue(object.gameHansel)).unsigned = false;
                else if (typeof object.gameHansel === "string")
                    message.gameHansel = parseInt(object.gameHansel, 10);
                else if (typeof object.gameHansel === "number")
                    message.gameHansel = object.gameHansel;
                else if (typeof object.gameHansel === "object")
                    message.gameHansel = new $util.LongBits(object.gameHansel.low >>> 0, object.gameHansel.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GameHanselItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GameHanselItem
         * @static
         * @param {CLPF.GameHanselItem} message GameHanselItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameHanselItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.gameHansel = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gameHansel = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.gameHansel != null && message.hasOwnProperty("gameHansel"))
                if (typeof message.gameHansel === "number")
                    object.gameHansel = options.longs === String ? String(message.gameHansel) : message.gameHansel;
                else
                    object.gameHansel = options.longs === String ? $util.Long.prototype.toString.call(message.gameHansel) : options.longs === Number ? new $util.LongBits(message.gameHansel.low >>> 0, message.gameHansel.high >>> 0).toNumber() : message.gameHansel;
            return object;
        };

        /**
         * Converts this GameHanselItem to JSON.
         * @function toJSON
         * @memberof CLPF.GameHanselItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameHanselItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameHanselItem;
    })();

    CLPF.GameHanselBroadcastNtf = (function() {

        /**
         * Properties of a GameHanselBroadcastNtf.
         * @memberof CLPF
         * @interface IGameHanselBroadcastNtf
         * @property {number|null} [gameId] GameHanselBroadcastNtf gameId
         * @property {Array.<CLPF.IGameHanselItem>|null} [items] GameHanselBroadcastNtf items
         */

        /**
         * Constructs a new GameHanselBroadcastNtf.
         * @memberof CLPF
         * @classdesc Represents a GameHanselBroadcastNtf.
         * @implements IGameHanselBroadcastNtf
         * @constructor
         * @param {CLPF.IGameHanselBroadcastNtf=} [properties] Properties to set
         */
        function GameHanselBroadcastNtf(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameHanselBroadcastNtf gameId.
         * @member {number} gameId
         * @memberof CLPF.GameHanselBroadcastNtf
         * @instance
         */
        GameHanselBroadcastNtf.prototype.gameId = 0;

        /**
         * GameHanselBroadcastNtf items.
         * @member {Array.<CLPF.IGameHanselItem>} items
         * @memberof CLPF.GameHanselBroadcastNtf
         * @instance
         */
        GameHanselBroadcastNtf.prototype.items = $util.emptyArray;

        /**
         * Creates a new GameHanselBroadcastNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {CLPF.IGameHanselBroadcastNtf=} [properties] Properties to set
         * @returns {CLPF.GameHanselBroadcastNtf} GameHanselBroadcastNtf instance
         */
        GameHanselBroadcastNtf.create = function create(properties) {
            return new GameHanselBroadcastNtf(properties);
        };

        /**
         * Encodes the specified GameHanselBroadcastNtf message. Does not implicitly {@link CLPF.GameHanselBroadcastNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {CLPF.IGameHanselBroadcastNtf} message GameHanselBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameHanselBroadcastNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameId);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.GameHanselItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GameHanselBroadcastNtf message, length delimited. Does not implicitly {@link CLPF.GameHanselBroadcastNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {CLPF.IGameHanselBroadcastNtf} message GameHanselBroadcastNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameHanselBroadcastNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameHanselBroadcastNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GameHanselBroadcastNtf} GameHanselBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameHanselBroadcastNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GameHanselBroadcastNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameId = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.GameHanselItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameHanselBroadcastNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GameHanselBroadcastNtf} GameHanselBroadcastNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameHanselBroadcastNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameHanselBroadcastNtf message.
         * @function verify
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameHanselBroadcastNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.GameHanselItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GameHanselBroadcastNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GameHanselBroadcastNtf} GameHanselBroadcastNtf
         */
        GameHanselBroadcastNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GameHanselBroadcastNtf)
                return object;
            var message = new $root.CLPF.GameHanselBroadcastNtf();
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.GameHanselBroadcastNtf.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.GameHanselBroadcastNtf.items: object expected");
                    message.items[i] = $root.CLPF.GameHanselItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GameHanselBroadcastNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GameHanselBroadcastNtf
         * @static
         * @param {CLPF.GameHanselBroadcastNtf} message GameHanselBroadcastNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameHanselBroadcastNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.gameId = 0;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.GameHanselItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GameHanselBroadcastNtf to JSON.
         * @function toJSON
         * @memberof CLPF.GameHanselBroadcastNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameHanselBroadcastNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameHanselBroadcastNtf;
    })();

    CLPF.MonthCardQueryStateReq = (function() {

        /**
         * Properties of a MonthCardQueryStateReq.
         * @memberof CLPF
         * @interface IMonthCardQueryStateReq
         */

        /**
         * Constructs a new MonthCardQueryStateReq.
         * @memberof CLPF
         * @classdesc Represents a MonthCardQueryStateReq.
         * @implements IMonthCardQueryStateReq
         * @constructor
         * @param {CLPF.IMonthCardQueryStateReq=} [properties] Properties to set
         */
        function MonthCardQueryStateReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MonthCardQueryStateReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {CLPF.IMonthCardQueryStateReq=} [properties] Properties to set
         * @returns {CLPF.MonthCardQueryStateReq} MonthCardQueryStateReq instance
         */
        MonthCardQueryStateReq.create = function create(properties) {
            return new MonthCardQueryStateReq(properties);
        };

        /**
         * Encodes the specified MonthCardQueryStateReq message. Does not implicitly {@link CLPF.MonthCardQueryStateReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {CLPF.IMonthCardQueryStateReq} message MonthCardQueryStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardQueryStateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MonthCardQueryStateReq message, length delimited. Does not implicitly {@link CLPF.MonthCardQueryStateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {CLPF.IMonthCardQueryStateReq} message MonthCardQueryStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardQueryStateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MonthCardQueryStateReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MonthCardQueryStateReq} MonthCardQueryStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardQueryStateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MonthCardQueryStateReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MonthCardQueryStateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MonthCardQueryStateReq} MonthCardQueryStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardQueryStateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MonthCardQueryStateReq message.
         * @function verify
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MonthCardQueryStateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MonthCardQueryStateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MonthCardQueryStateReq} MonthCardQueryStateReq
         */
        MonthCardQueryStateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MonthCardQueryStateReq)
                return object;
            return new $root.CLPF.MonthCardQueryStateReq();
        };

        /**
         * Creates a plain object from a MonthCardQueryStateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MonthCardQueryStateReq
         * @static
         * @param {CLPF.MonthCardQueryStateReq} message MonthCardQueryStateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MonthCardQueryStateReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MonthCardQueryStateReq to JSON.
         * @function toJSON
         * @memberof CLPF.MonthCardQueryStateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MonthCardQueryStateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MonthCardQueryStateReq;
    })();

    CLPF.MonthCardQueryStateAck = (function() {

        /**
         * Properties of a MonthCardQueryStateAck.
         * @memberof CLPF
         * @interface IMonthCardQueryStateAck
         * @property {number|null} [errcode] MonthCardQueryStateAck errcode
         * @property {number|null} [monthCardExpireTime] MonthCardQueryStateAck monthCardExpireTime
         * @property {boolean|null} [monthCardHasFetched] MonthCardQueryStateAck monthCardHasFetched
         */

        /**
         * Constructs a new MonthCardQueryStateAck.
         * @memberof CLPF
         * @classdesc Represents a MonthCardQueryStateAck.
         * @implements IMonthCardQueryStateAck
         * @constructor
         * @param {CLPF.IMonthCardQueryStateAck=} [properties] Properties to set
         */
        function MonthCardQueryStateAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MonthCardQueryStateAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MonthCardQueryStateAck
         * @instance
         */
        MonthCardQueryStateAck.prototype.errcode = 0;

        /**
         * MonthCardQueryStateAck monthCardExpireTime.
         * @member {number} monthCardExpireTime
         * @memberof CLPF.MonthCardQueryStateAck
         * @instance
         */
        MonthCardQueryStateAck.prototype.monthCardExpireTime = 0;

        /**
         * MonthCardQueryStateAck monthCardHasFetched.
         * @member {boolean} monthCardHasFetched
         * @memberof CLPF.MonthCardQueryStateAck
         * @instance
         */
        MonthCardQueryStateAck.prototype.monthCardHasFetched = false;

        /**
         * Creates a new MonthCardQueryStateAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {CLPF.IMonthCardQueryStateAck=} [properties] Properties to set
         * @returns {CLPF.MonthCardQueryStateAck} MonthCardQueryStateAck instance
         */
        MonthCardQueryStateAck.create = function create(properties) {
            return new MonthCardQueryStateAck(properties);
        };

        /**
         * Encodes the specified MonthCardQueryStateAck message. Does not implicitly {@link CLPF.MonthCardQueryStateAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {CLPF.IMonthCardQueryStateAck} message MonthCardQueryStateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardQueryStateAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.monthCardExpireTime != null && Object.hasOwnProperty.call(message, "monthCardExpireTime"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.monthCardExpireTime);
            if (message.monthCardHasFetched != null && Object.hasOwnProperty.call(message, "monthCardHasFetched"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.monthCardHasFetched);
            return writer;
        };

        /**
         * Encodes the specified MonthCardQueryStateAck message, length delimited. Does not implicitly {@link CLPF.MonthCardQueryStateAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {CLPF.IMonthCardQueryStateAck} message MonthCardQueryStateAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardQueryStateAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MonthCardQueryStateAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MonthCardQueryStateAck} MonthCardQueryStateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardQueryStateAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MonthCardQueryStateAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.monthCardExpireTime = reader.fixed32();
                    break;
                case 3:
                    message.monthCardHasFetched = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MonthCardQueryStateAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MonthCardQueryStateAck} MonthCardQueryStateAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardQueryStateAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MonthCardQueryStateAck message.
         * @function verify
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MonthCardQueryStateAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.monthCardExpireTime != null && message.hasOwnProperty("monthCardExpireTime"))
                if (!$util.isInteger(message.monthCardExpireTime))
                    return "monthCardExpireTime: integer expected";
            if (message.monthCardHasFetched != null && message.hasOwnProperty("monthCardHasFetched"))
                if (typeof message.monthCardHasFetched !== "boolean")
                    return "monthCardHasFetched: boolean expected";
            return null;
        };

        /**
         * Creates a MonthCardQueryStateAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MonthCardQueryStateAck} MonthCardQueryStateAck
         */
        MonthCardQueryStateAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MonthCardQueryStateAck)
                return object;
            var message = new $root.CLPF.MonthCardQueryStateAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.monthCardExpireTime != null)
                message.monthCardExpireTime = object.monthCardExpireTime >>> 0;
            if (object.monthCardHasFetched != null)
                message.monthCardHasFetched = Boolean(object.monthCardHasFetched);
            return message;
        };

        /**
         * Creates a plain object from a MonthCardQueryStateAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MonthCardQueryStateAck
         * @static
         * @param {CLPF.MonthCardQueryStateAck} message MonthCardQueryStateAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MonthCardQueryStateAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.monthCardExpireTime = 0;
                object.monthCardHasFetched = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.monthCardExpireTime != null && message.hasOwnProperty("monthCardExpireTime"))
                object.monthCardExpireTime = message.monthCardExpireTime;
            if (message.monthCardHasFetched != null && message.hasOwnProperty("monthCardHasFetched"))
                object.monthCardHasFetched = message.monthCardHasFetched;
            return object;
        };

        /**
         * Converts this MonthCardQueryStateAck to JSON.
         * @function toJSON
         * @memberof CLPF.MonthCardQueryStateAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MonthCardQueryStateAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MonthCardQueryStateAck;
    })();

    CLPF.MonthCardFetchRewardReq = (function() {

        /**
         * Properties of a MonthCardFetchRewardReq.
         * @memberof CLPF
         * @interface IMonthCardFetchRewardReq
         */

        /**
         * Constructs a new MonthCardFetchRewardReq.
         * @memberof CLPF
         * @classdesc Represents a MonthCardFetchRewardReq.
         * @implements IMonthCardFetchRewardReq
         * @constructor
         * @param {CLPF.IMonthCardFetchRewardReq=} [properties] Properties to set
         */
        function MonthCardFetchRewardReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MonthCardFetchRewardReq instance using the specified properties.
         * @function create
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {CLPF.IMonthCardFetchRewardReq=} [properties] Properties to set
         * @returns {CLPF.MonthCardFetchRewardReq} MonthCardFetchRewardReq instance
         */
        MonthCardFetchRewardReq.create = function create(properties) {
            return new MonthCardFetchRewardReq(properties);
        };

        /**
         * Encodes the specified MonthCardFetchRewardReq message. Does not implicitly {@link CLPF.MonthCardFetchRewardReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {CLPF.IMonthCardFetchRewardReq} message MonthCardFetchRewardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardFetchRewardReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MonthCardFetchRewardReq message, length delimited. Does not implicitly {@link CLPF.MonthCardFetchRewardReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {CLPF.IMonthCardFetchRewardReq} message MonthCardFetchRewardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardFetchRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MonthCardFetchRewardReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MonthCardFetchRewardReq} MonthCardFetchRewardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardFetchRewardReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MonthCardFetchRewardReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MonthCardFetchRewardReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MonthCardFetchRewardReq} MonthCardFetchRewardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardFetchRewardReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MonthCardFetchRewardReq message.
         * @function verify
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MonthCardFetchRewardReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MonthCardFetchRewardReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MonthCardFetchRewardReq} MonthCardFetchRewardReq
         */
        MonthCardFetchRewardReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MonthCardFetchRewardReq)
                return object;
            return new $root.CLPF.MonthCardFetchRewardReq();
        };

        /**
         * Creates a plain object from a MonthCardFetchRewardReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MonthCardFetchRewardReq
         * @static
         * @param {CLPF.MonthCardFetchRewardReq} message MonthCardFetchRewardReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MonthCardFetchRewardReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MonthCardFetchRewardReq to JSON.
         * @function toJSON
         * @memberof CLPF.MonthCardFetchRewardReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MonthCardFetchRewardReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MonthCardFetchRewardReq;
    })();

    CLPF.MonthCardFetchRewardAck = (function() {

        /**
         * Properties of a MonthCardFetchRewardAck.
         * @memberof CLPF
         * @interface IMonthCardFetchRewardAck
         * @property {number|null} [errcode] MonthCardFetchRewardAck errcode
         * @property {Array.<CLPF.IItemInfo>|null} [items] MonthCardFetchRewardAck items
         */

        /**
         * Constructs a new MonthCardFetchRewardAck.
         * @memberof CLPF
         * @classdesc Represents a MonthCardFetchRewardAck.
         * @implements IMonthCardFetchRewardAck
         * @constructor
         * @param {CLPF.IMonthCardFetchRewardAck=} [properties] Properties to set
         */
        function MonthCardFetchRewardAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MonthCardFetchRewardAck errcode.
         * @member {number} errcode
         * @memberof CLPF.MonthCardFetchRewardAck
         * @instance
         */
        MonthCardFetchRewardAck.prototype.errcode = 0;

        /**
         * MonthCardFetchRewardAck items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.MonthCardFetchRewardAck
         * @instance
         */
        MonthCardFetchRewardAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new MonthCardFetchRewardAck instance using the specified properties.
         * @function create
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {CLPF.IMonthCardFetchRewardAck=} [properties] Properties to set
         * @returns {CLPF.MonthCardFetchRewardAck} MonthCardFetchRewardAck instance
         */
        MonthCardFetchRewardAck.create = function create(properties) {
            return new MonthCardFetchRewardAck(properties);
        };

        /**
         * Encodes the specified MonthCardFetchRewardAck message. Does not implicitly {@link CLPF.MonthCardFetchRewardAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {CLPF.IMonthCardFetchRewardAck} message MonthCardFetchRewardAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardFetchRewardAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MonthCardFetchRewardAck message, length delimited. Does not implicitly {@link CLPF.MonthCardFetchRewardAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {CLPF.IMonthCardFetchRewardAck} message MonthCardFetchRewardAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MonthCardFetchRewardAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MonthCardFetchRewardAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.MonthCardFetchRewardAck} MonthCardFetchRewardAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardFetchRewardAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.MonthCardFetchRewardAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MonthCardFetchRewardAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.MonthCardFetchRewardAck} MonthCardFetchRewardAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MonthCardFetchRewardAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MonthCardFetchRewardAck message.
         * @function verify
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MonthCardFetchRewardAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MonthCardFetchRewardAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.MonthCardFetchRewardAck} MonthCardFetchRewardAck
         */
        MonthCardFetchRewardAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.MonthCardFetchRewardAck)
                return object;
            var message = new $root.CLPF.MonthCardFetchRewardAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.MonthCardFetchRewardAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.MonthCardFetchRewardAck.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MonthCardFetchRewardAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.MonthCardFetchRewardAck
         * @static
         * @param {CLPF.MonthCardFetchRewardAck} message MonthCardFetchRewardAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MonthCardFetchRewardAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this MonthCardFetchRewardAck to JSON.
         * @function toJSON
         * @memberof CLPF.MonthCardFetchRewardAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MonthCardFetchRewardAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MonthCardFetchRewardAck;
    })();

    CLPF.AnnouncementChangedNtf = (function() {

        /**
         * Properties of an AnnouncementChangedNtf.
         * @memberof CLPF
         * @interface IAnnouncementChangedNtf
         * @property {number|null} [contentType] AnnouncementChangedNtf contentType
         */

        /**
         * Constructs a new AnnouncementChangedNtf.
         * @memberof CLPF
         * @classdesc Represents an AnnouncementChangedNtf.
         * @implements IAnnouncementChangedNtf
         * @constructor
         * @param {CLPF.IAnnouncementChangedNtf=} [properties] Properties to set
         */
        function AnnouncementChangedNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnnouncementChangedNtf contentType.
         * @member {number} contentType
         * @memberof CLPF.AnnouncementChangedNtf
         * @instance
         */
        AnnouncementChangedNtf.prototype.contentType = 0;

        /**
         * Creates a new AnnouncementChangedNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {CLPF.IAnnouncementChangedNtf=} [properties] Properties to set
         * @returns {CLPF.AnnouncementChangedNtf} AnnouncementChangedNtf instance
         */
        AnnouncementChangedNtf.create = function create(properties) {
            return new AnnouncementChangedNtf(properties);
        };

        /**
         * Encodes the specified AnnouncementChangedNtf message. Does not implicitly {@link CLPF.AnnouncementChangedNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {CLPF.IAnnouncementChangedNtf} message AnnouncementChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnnouncementChangedNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified AnnouncementChangedNtf message, length delimited. Does not implicitly {@link CLPF.AnnouncementChangedNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {CLPF.IAnnouncementChangedNtf} message AnnouncementChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnnouncementChangedNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnnouncementChangedNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AnnouncementChangedNtf} AnnouncementChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnnouncementChangedNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AnnouncementChangedNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnnouncementChangedNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AnnouncementChangedNtf} AnnouncementChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnnouncementChangedNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnnouncementChangedNtf message.
         * @function verify
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnnouncementChangedNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isInteger(message.contentType))
                    return "contentType: integer expected";
            return null;
        };

        /**
         * Creates an AnnouncementChangedNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AnnouncementChangedNtf} AnnouncementChangedNtf
         */
        AnnouncementChangedNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AnnouncementChangedNtf)
                return object;
            var message = new $root.CLPF.AnnouncementChangedNtf();
            if (object.contentType != null)
                message.contentType = object.contentType | 0;
            return message;
        };

        /**
         * Creates a plain object from an AnnouncementChangedNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AnnouncementChangedNtf
         * @static
         * @param {CLPF.AnnouncementChangedNtf} message AnnouncementChangedNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnnouncementChangedNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.contentType = 0;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            return object;
        };

        /**
         * Converts this AnnouncementChangedNtf to JSON.
         * @function toJSON
         * @memberof CLPF.AnnouncementChangedNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnnouncementChangedNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnnouncementChangedNtf;
    })();

    CLPF.GuideDataQueryReq = (function() {

        /**
         * Properties of a GuideDataQueryReq.
         * @memberof CLPF
         * @interface IGuideDataQueryReq
         */

        /**
         * Constructs a new GuideDataQueryReq.
         * @memberof CLPF
         * @classdesc Represents a GuideDataQueryReq.
         * @implements IGuideDataQueryReq
         * @constructor
         * @param {CLPF.IGuideDataQueryReq=} [properties] Properties to set
         */
        function GuideDataQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuideDataQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {CLPF.IGuideDataQueryReq=} [properties] Properties to set
         * @returns {CLPF.GuideDataQueryReq} GuideDataQueryReq instance
         */
        GuideDataQueryReq.create = function create(properties) {
            return new GuideDataQueryReq(properties);
        };

        /**
         * Encodes the specified GuideDataQueryReq message. Does not implicitly {@link CLPF.GuideDataQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {CLPF.IGuideDataQueryReq} message GuideDataQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuideDataQueryReq message, length delimited. Does not implicitly {@link CLPF.GuideDataQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {CLPF.IGuideDataQueryReq} message GuideDataQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuideDataQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GuideDataQueryReq} GuideDataQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GuideDataQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuideDataQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GuideDataQueryReq} GuideDataQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuideDataQueryReq message.
         * @function verify
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuideDataQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GuideDataQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GuideDataQueryReq} GuideDataQueryReq
         */
        GuideDataQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GuideDataQueryReq)
                return object;
            return new $root.CLPF.GuideDataQueryReq();
        };

        /**
         * Creates a plain object from a GuideDataQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GuideDataQueryReq
         * @static
         * @param {CLPF.GuideDataQueryReq} message GuideDataQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuideDataQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuideDataQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.GuideDataQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuideDataQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuideDataQueryReq;
    })();

    CLPF.GuideDataQueryAck = (function() {

        /**
         * Properties of a GuideDataQueryAck.
         * @memberof CLPF
         * @interface IGuideDataQueryAck
         * @property {Array.<number>|null} [flagArray] GuideDataQueryAck flagArray
         */

        /**
         * Constructs a new GuideDataQueryAck.
         * @memberof CLPF
         * @classdesc Represents a GuideDataQueryAck.
         * @implements IGuideDataQueryAck
         * @constructor
         * @param {CLPF.IGuideDataQueryAck=} [properties] Properties to set
         */
        function GuideDataQueryAck(properties) {
            this.flagArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuideDataQueryAck flagArray.
         * @member {Array.<number>} flagArray
         * @memberof CLPF.GuideDataQueryAck
         * @instance
         */
        GuideDataQueryAck.prototype.flagArray = $util.emptyArray;

        /**
         * Creates a new GuideDataQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {CLPF.IGuideDataQueryAck=} [properties] Properties to set
         * @returns {CLPF.GuideDataQueryAck} GuideDataQueryAck instance
         */
        GuideDataQueryAck.create = function create(properties) {
            return new GuideDataQueryAck(properties);
        };

        /**
         * Encodes the specified GuideDataQueryAck message. Does not implicitly {@link CLPF.GuideDataQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {CLPF.IGuideDataQueryAck} message GuideDataQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flagArray != null && message.flagArray.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.flagArray.length; ++i)
                    writer.int32(message.flagArray[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GuideDataQueryAck message, length delimited. Does not implicitly {@link CLPF.GuideDataQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {CLPF.IGuideDataQueryAck} message GuideDataQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuideDataQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GuideDataQueryAck} GuideDataQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GuideDataQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.flagArray && message.flagArray.length))
                        message.flagArray = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flagArray.push(reader.int32());
                    } else
                        message.flagArray.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuideDataQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GuideDataQueryAck} GuideDataQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuideDataQueryAck message.
         * @function verify
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuideDataQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flagArray != null && message.hasOwnProperty("flagArray")) {
                if (!Array.isArray(message.flagArray))
                    return "flagArray: array expected";
                for (var i = 0; i < message.flagArray.length; ++i)
                    if (!$util.isInteger(message.flagArray[i]))
                        return "flagArray: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a GuideDataQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GuideDataQueryAck} GuideDataQueryAck
         */
        GuideDataQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GuideDataQueryAck)
                return object;
            var message = new $root.CLPF.GuideDataQueryAck();
            if (object.flagArray) {
                if (!Array.isArray(object.flagArray))
                    throw TypeError(".CLPF.GuideDataQueryAck.flagArray: array expected");
                message.flagArray = [];
                for (var i = 0; i < object.flagArray.length; ++i)
                    message.flagArray[i] = object.flagArray[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a GuideDataQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GuideDataQueryAck
         * @static
         * @param {CLPF.GuideDataQueryAck} message GuideDataQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuideDataQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.flagArray = [];
            if (message.flagArray && message.flagArray.length) {
                object.flagArray = [];
                for (var j = 0; j < message.flagArray.length; ++j)
                    object.flagArray[j] = message.flagArray[j];
            }
            return object;
        };

        /**
         * Converts this GuideDataQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.GuideDataQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuideDataQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuideDataQueryAck;
    })();

    CLPF.GuideDataActRpt = (function() {

        /**
         * Properties of a GuideDataActRpt.
         * @memberof CLPF
         * @interface IGuideDataActRpt
         * @property {number|null} [flag] GuideDataActRpt flag
         */

        /**
         * Constructs a new GuideDataActRpt.
         * @memberof CLPF
         * @classdesc Represents a GuideDataActRpt.
         * @implements IGuideDataActRpt
         * @constructor
         * @param {CLPF.IGuideDataActRpt=} [properties] Properties to set
         */
        function GuideDataActRpt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuideDataActRpt flag.
         * @member {number} flag
         * @memberof CLPF.GuideDataActRpt
         * @instance
         */
        GuideDataActRpt.prototype.flag = 0;

        /**
         * Creates a new GuideDataActRpt instance using the specified properties.
         * @function create
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {CLPF.IGuideDataActRpt=} [properties] Properties to set
         * @returns {CLPF.GuideDataActRpt} GuideDataActRpt instance
         */
        GuideDataActRpt.create = function create(properties) {
            return new GuideDataActRpt(properties);
        };

        /**
         * Encodes the specified GuideDataActRpt message. Does not implicitly {@link CLPF.GuideDataActRpt.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {CLPF.IGuideDataActRpt} message GuideDataActRpt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataActRpt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.flag);
            return writer;
        };

        /**
         * Encodes the specified GuideDataActRpt message, length delimited. Does not implicitly {@link CLPF.GuideDataActRpt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {CLPF.IGuideDataActRpt} message GuideDataActRpt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideDataActRpt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuideDataActRpt message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GuideDataActRpt} GuideDataActRpt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataActRpt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GuideDataActRpt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.flag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuideDataActRpt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GuideDataActRpt} GuideDataActRpt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideDataActRpt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuideDataActRpt message.
         * @function verify
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuideDataActRpt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };

        /**
         * Creates a GuideDataActRpt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GuideDataActRpt} GuideDataActRpt
         */
        GuideDataActRpt.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GuideDataActRpt)
                return object;
            var message = new $root.CLPF.GuideDataActRpt();
            if (object.flag != null)
                message.flag = object.flag | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuideDataActRpt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GuideDataActRpt
         * @static
         * @param {CLPF.GuideDataActRpt} message GuideDataActRpt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuideDataActRpt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.flag = 0;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };

        /**
         * Converts this GuideDataActRpt to JSON.
         * @function toJSON
         * @memberof CLPF.GuideDataActRpt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuideDataActRpt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuideDataActRpt;
    })();

    CLPF.ClientConfigPublishNtf = (function() {

        /**
         * Properties of a ClientConfigPublishNtf.
         * @memberof CLPF
         * @interface IClientConfigPublishNtf
         * @property {string|null} [md5] ClientConfigPublishNtf md5
         */

        /**
         * Constructs a new ClientConfigPublishNtf.
         * @memberof CLPF
         * @classdesc Represents a ClientConfigPublishNtf.
         * @implements IClientConfigPublishNtf
         * @constructor
         * @param {CLPF.IClientConfigPublishNtf=} [properties] Properties to set
         */
        function ClientConfigPublishNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientConfigPublishNtf md5.
         * @member {string} md5
         * @memberof CLPF.ClientConfigPublishNtf
         * @instance
         */
        ClientConfigPublishNtf.prototype.md5 = "";

        /**
         * Creates a new ClientConfigPublishNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {CLPF.IClientConfigPublishNtf=} [properties] Properties to set
         * @returns {CLPF.ClientConfigPublishNtf} ClientConfigPublishNtf instance
         */
        ClientConfigPublishNtf.create = function create(properties) {
            return new ClientConfigPublishNtf(properties);
        };

        /**
         * Encodes the specified ClientConfigPublishNtf message. Does not implicitly {@link CLPF.ClientConfigPublishNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {CLPF.IClientConfigPublishNtf} message ClientConfigPublishNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientConfigPublishNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.md5 != null && Object.hasOwnProperty.call(message, "md5"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.md5);
            return writer;
        };

        /**
         * Encodes the specified ClientConfigPublishNtf message, length delimited. Does not implicitly {@link CLPF.ClientConfigPublishNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {CLPF.IClientConfigPublishNtf} message ClientConfigPublishNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientConfigPublishNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientConfigPublishNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ClientConfigPublishNtf} ClientConfigPublishNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientConfigPublishNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ClientConfigPublishNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.md5 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientConfigPublishNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ClientConfigPublishNtf} ClientConfigPublishNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientConfigPublishNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientConfigPublishNtf message.
         * @function verify
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientConfigPublishNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.md5 != null && message.hasOwnProperty("md5"))
                if (!$util.isString(message.md5))
                    return "md5: string expected";
            return null;
        };

        /**
         * Creates a ClientConfigPublishNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ClientConfigPublishNtf} ClientConfigPublishNtf
         */
        ClientConfigPublishNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ClientConfigPublishNtf)
                return object;
            var message = new $root.CLPF.ClientConfigPublishNtf();
            if (object.md5 != null)
                message.md5 = String(object.md5);
            return message;
        };

        /**
         * Creates a plain object from a ClientConfigPublishNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ClientConfigPublishNtf
         * @static
         * @param {CLPF.ClientConfigPublishNtf} message ClientConfigPublishNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientConfigPublishNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.md5 = "";
            if (message.md5 != null && message.hasOwnProperty("md5"))
                object.md5 = message.md5;
            return object;
        };

        /**
         * Converts this ClientConfigPublishNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ClientConfigPublishNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientConfigPublishNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientConfigPublishNtf;
    })();

    CLPF.GameConfigItem = (function() {

        /**
         * Properties of a GameConfigItem.
         * @memberof CLPF
         * @interface IGameConfigItem
         * @property {string|null} [serverName] GameConfigItem serverName
         * @property {number|null} [gameId] GameConfigItem gameId
         * @property {boolean|null} [repeatedRoom] GameConfigItem repeatedRoom
         * @property {Array.<CLPF.IRoomConfigItem>|null} [items] GameConfigItem items
         */

        /**
         * Constructs a new GameConfigItem.
         * @memberof CLPF
         * @classdesc Represents a GameConfigItem.
         * @implements IGameConfigItem
         * @constructor
         * @param {CLPF.IGameConfigItem=} [properties] Properties to set
         */
        function GameConfigItem(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameConfigItem serverName.
         * @member {string} serverName
         * @memberof CLPF.GameConfigItem
         * @instance
         */
        GameConfigItem.prototype.serverName = "";

        /**
         * GameConfigItem gameId.
         * @member {number} gameId
         * @memberof CLPF.GameConfigItem
         * @instance
         */
        GameConfigItem.prototype.gameId = 0;

        /**
         * GameConfigItem repeatedRoom.
         * @member {boolean} repeatedRoom
         * @memberof CLPF.GameConfigItem
         * @instance
         */
        GameConfigItem.prototype.repeatedRoom = false;

        /**
         * GameConfigItem items.
         * @member {Array.<CLPF.IRoomConfigItem>} items
         * @memberof CLPF.GameConfigItem
         * @instance
         */
        GameConfigItem.prototype.items = $util.emptyArray;

        /**
         * Creates a new GameConfigItem instance using the specified properties.
         * @function create
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {CLPF.IGameConfigItem=} [properties] Properties to set
         * @returns {CLPF.GameConfigItem} GameConfigItem instance
         */
        GameConfigItem.create = function create(properties) {
            return new GameConfigItem(properties);
        };

        /**
         * Encodes the specified GameConfigItem message. Does not implicitly {@link CLPF.GameConfigItem.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {CLPF.IGameConfigItem} message GameConfigItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameConfigItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverName != null && Object.hasOwnProperty.call(message, "serverName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverName);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.repeatedRoom != null && Object.hasOwnProperty.call(message, "repeatedRoom"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.repeatedRoom);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.RoomConfigItem.encode(message.items[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GameConfigItem message, length delimited. Does not implicitly {@link CLPF.GameConfigItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {CLPF.IGameConfigItem} message GameConfigItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameConfigItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameConfigItem message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GameConfigItem} GameConfigItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameConfigItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GameConfigItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverName = reader.string();
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    message.repeatedRoom = reader.bool();
                    break;
                case 4:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.RoomConfigItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameConfigItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GameConfigItem} GameConfigItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameConfigItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameConfigItem message.
         * @function verify
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameConfigItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverName != null && message.hasOwnProperty("serverName"))
                if (!$util.isString(message.serverName))
                    return "serverName: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.repeatedRoom != null && message.hasOwnProperty("repeatedRoom"))
                if (typeof message.repeatedRoom !== "boolean")
                    return "repeatedRoom: boolean expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.RoomConfigItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GameConfigItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GameConfigItem} GameConfigItem
         */
        GameConfigItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GameConfigItem)
                return object;
            var message = new $root.CLPF.GameConfigItem();
            if (object.serverName != null)
                message.serverName = String(object.serverName);
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.repeatedRoom != null)
                message.repeatedRoom = Boolean(object.repeatedRoom);
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.GameConfigItem.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.GameConfigItem.items: object expected");
                    message.items[i] = $root.CLPF.RoomConfigItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GameConfigItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GameConfigItem
         * @static
         * @param {CLPF.GameConfigItem} message GameConfigItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameConfigItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.serverName = "";
                object.gameId = 0;
                object.repeatedRoom = false;
            }
            if (message.serverName != null && message.hasOwnProperty("serverName"))
                object.serverName = message.serverName;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.repeatedRoom != null && message.hasOwnProperty("repeatedRoom"))
                object.repeatedRoom = message.repeatedRoom;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.RoomConfigItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GameConfigItem to JSON.
         * @function toJSON
         * @memberof CLPF.GameConfigItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameConfigItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameConfigItem;
    })();

    CLPF.RoomConfigItem = (function() {

        /**
         * Properties of a RoomConfigItem.
         * @memberof CLPF
         * @interface IRoomConfigItem
         * @property {string|null} [serverName] RoomConfigItem serverName
         * @property {number|null} [gameId] RoomConfigItem gameId
         * @property {number|null} [roomId] RoomConfigItem roomId
         * @property {string|null} [roomName] RoomConfigItem roomName
         * @property {number|Long|null} [minEnterScore] RoomConfigItem minEnterScore
         * @property {number|Long|null} [roomBet] RoomConfigItem roomBet
         * @property {number|Long|null} [fee] RoomConfigItem fee
         * @property {number|Long|null} [minGun] RoomConfigItem minGun
         * @property {number|Long|null} [maxGun] RoomConfigItem maxGun
         * @property {boolean|null} [showDesks] RoomConfigItem showDesks
         * @property {number|null} [roomType] RoomConfigItem roomType
         * @property {string|null} [extraConfig] RoomConfigItem extraConfig
         */

        /**
         * Constructs a new RoomConfigItem.
         * @memberof CLPF
         * @classdesc Represents a RoomConfigItem.
         * @implements IRoomConfigItem
         * @constructor
         * @param {CLPF.IRoomConfigItem=} [properties] Properties to set
         */
        function RoomConfigItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomConfigItem serverName.
         * @member {string} serverName
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.serverName = "";

        /**
         * RoomConfigItem gameId.
         * @member {number} gameId
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.gameId = 0;

        /**
         * RoomConfigItem roomId.
         * @member {number} roomId
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.roomId = 0;

        /**
         * RoomConfigItem roomName.
         * @member {string} roomName
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.roomName = "";

        /**
         * RoomConfigItem minEnterScore.
         * @member {number|Long} minEnterScore
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.minEnterScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomConfigItem roomBet.
         * @member {number|Long} roomBet
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.roomBet = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomConfigItem fee.
         * @member {number|Long} fee
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomConfigItem minGun.
         * @member {number|Long} minGun
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.minGun = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomConfigItem maxGun.
         * @member {number|Long} maxGun
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.maxGun = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomConfigItem showDesks.
         * @member {boolean} showDesks
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.showDesks = false;

        /**
         * RoomConfigItem roomType.
         * @member {number} roomType
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.roomType = 0;

        /**
         * RoomConfigItem extraConfig.
         * @member {string} extraConfig
         * @memberof CLPF.RoomConfigItem
         * @instance
         */
        RoomConfigItem.prototype.extraConfig = "";

        /**
         * Creates a new RoomConfigItem instance using the specified properties.
         * @function create
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {CLPF.IRoomConfigItem=} [properties] Properties to set
         * @returns {CLPF.RoomConfigItem} RoomConfigItem instance
         */
        RoomConfigItem.create = function create(properties) {
            return new RoomConfigItem(properties);
        };

        /**
         * Encodes the specified RoomConfigItem message. Does not implicitly {@link CLPF.RoomConfigItem.verify|verify} messages.
         * @function encode
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {CLPF.IRoomConfigItem} message RoomConfigItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomConfigItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverName != null && Object.hasOwnProperty.call(message, "serverName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverName);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roomId);
            if (message.roomName != null && Object.hasOwnProperty.call(message, "roomName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.roomName);
            if (message.minEnterScore != null && Object.hasOwnProperty.call(message, "minEnterScore"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.minEnterScore);
            if (message.roomBet != null && Object.hasOwnProperty.call(message, "roomBet"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.roomBet);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.minGun != null && Object.hasOwnProperty.call(message, "minGun"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.minGun);
            if (message.maxGun != null && Object.hasOwnProperty.call(message, "maxGun"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.maxGun);
            if (message.showDesks != null && Object.hasOwnProperty.call(message, "showDesks"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.showDesks);
            if (message.roomType != null && Object.hasOwnProperty.call(message, "roomType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.roomType);
            if (message.extraConfig != null && Object.hasOwnProperty.call(message, "extraConfig"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.extraConfig);
            return writer;
        };

        /**
         * Encodes the specified RoomConfigItem message, length delimited. Does not implicitly {@link CLPF.RoomConfigItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {CLPF.IRoomConfigItem} message RoomConfigItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomConfigItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoomConfigItem message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.RoomConfigItem} RoomConfigItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomConfigItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.RoomConfigItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverName = reader.string();
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    message.roomId = reader.int32();
                    break;
                case 4:
                    message.roomName = reader.string();
                    break;
                case 5:
                    message.minEnterScore = reader.int64();
                    break;
                case 6:
                    message.roomBet = reader.int64();
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    message.minGun = reader.int64();
                    break;
                case 9:
                    message.maxGun = reader.int64();
                    break;
                case 10:
                    message.showDesks = reader.bool();
                    break;
                case 11:
                    message.roomType = reader.int32();
                    break;
                case 12:
                    message.extraConfig = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomConfigItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.RoomConfigItem} RoomConfigItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomConfigItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoomConfigItem message.
         * @function verify
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoomConfigItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverName != null && message.hasOwnProperty("serverName"))
                if (!$util.isString(message.serverName))
                    return "serverName: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.roomName != null && message.hasOwnProperty("roomName"))
                if (!$util.isString(message.roomName))
                    return "roomName: string expected";
            if (message.minEnterScore != null && message.hasOwnProperty("minEnterScore"))
                if (!$util.isInteger(message.minEnterScore) && !(message.minEnterScore && $util.isInteger(message.minEnterScore.low) && $util.isInteger(message.minEnterScore.high)))
                    return "minEnterScore: integer|Long expected";
            if (message.roomBet != null && message.hasOwnProperty("roomBet"))
                if (!$util.isInteger(message.roomBet) && !(message.roomBet && $util.isInteger(message.roomBet.low) && $util.isInteger(message.roomBet.high)))
                    return "roomBet: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.minGun != null && message.hasOwnProperty("minGun"))
                if (!$util.isInteger(message.minGun) && !(message.minGun && $util.isInteger(message.minGun.low) && $util.isInteger(message.minGun.high)))
                    return "minGun: integer|Long expected";
            if (message.maxGun != null && message.hasOwnProperty("maxGun"))
                if (!$util.isInteger(message.maxGun) && !(message.maxGun && $util.isInteger(message.maxGun.low) && $util.isInteger(message.maxGun.high)))
                    return "maxGun: integer|Long expected";
            if (message.showDesks != null && message.hasOwnProperty("showDesks"))
                if (typeof message.showDesks !== "boolean")
                    return "showDesks: boolean expected";
            if (message.roomType != null && message.hasOwnProperty("roomType"))
                if (!$util.isInteger(message.roomType))
                    return "roomType: integer expected";
            if (message.extraConfig != null && message.hasOwnProperty("extraConfig"))
                if (!$util.isString(message.extraConfig))
                    return "extraConfig: string expected";
            return null;
        };

        /**
         * Creates a RoomConfigItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.RoomConfigItem} RoomConfigItem
         */
        RoomConfigItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.RoomConfigItem)
                return object;
            var message = new $root.CLPF.RoomConfigItem();
            if (object.serverName != null)
                message.serverName = String(object.serverName);
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.roomName != null)
                message.roomName = String(object.roomName);
            if (object.minEnterScore != null)
                if ($util.Long)
                    (message.minEnterScore = $util.Long.fromValue(object.minEnterScore)).unsigned = false;
                else if (typeof object.minEnterScore === "string")
                    message.minEnterScore = parseInt(object.minEnterScore, 10);
                else if (typeof object.minEnterScore === "number")
                    message.minEnterScore = object.minEnterScore;
                else if (typeof object.minEnterScore === "object")
                    message.minEnterScore = new $util.LongBits(object.minEnterScore.low >>> 0, object.minEnterScore.high >>> 0).toNumber();
            if (object.roomBet != null)
                if ($util.Long)
                    (message.roomBet = $util.Long.fromValue(object.roomBet)).unsigned = false;
                else if (typeof object.roomBet === "string")
                    message.roomBet = parseInt(object.roomBet, 10);
                else if (typeof object.roomBet === "number")
                    message.roomBet = object.roomBet;
                else if (typeof object.roomBet === "object")
                    message.roomBet = new $util.LongBits(object.roomBet.low >>> 0, object.roomBet.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.minGun != null)
                if ($util.Long)
                    (message.minGun = $util.Long.fromValue(object.minGun)).unsigned = false;
                else if (typeof object.minGun === "string")
                    message.minGun = parseInt(object.minGun, 10);
                else if (typeof object.minGun === "number")
                    message.minGun = object.minGun;
                else if (typeof object.minGun === "object")
                    message.minGun = new $util.LongBits(object.minGun.low >>> 0, object.minGun.high >>> 0).toNumber();
            if (object.maxGun != null)
                if ($util.Long)
                    (message.maxGun = $util.Long.fromValue(object.maxGun)).unsigned = false;
                else if (typeof object.maxGun === "string")
                    message.maxGun = parseInt(object.maxGun, 10);
                else if (typeof object.maxGun === "number")
                    message.maxGun = object.maxGun;
                else if (typeof object.maxGun === "object")
                    message.maxGun = new $util.LongBits(object.maxGun.low >>> 0, object.maxGun.high >>> 0).toNumber();
            if (object.showDesks != null)
                message.showDesks = Boolean(object.showDesks);
            if (object.roomType != null)
                message.roomType = object.roomType | 0;
            if (object.extraConfig != null)
                message.extraConfig = String(object.extraConfig);
            return message;
        };

        /**
         * Creates a plain object from a RoomConfigItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.RoomConfigItem
         * @static
         * @param {CLPF.RoomConfigItem} message RoomConfigItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoomConfigItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverName = "";
                object.gameId = 0;
                object.roomId = 0;
                object.roomName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.minEnterScore = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minEnterScore = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.roomBet = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roomBet = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.minGun = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minGun = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxGun = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxGun = options.longs === String ? "0" : 0;
                object.showDesks = false;
                object.roomType = 0;
                object.extraConfig = "";
            }
            if (message.serverName != null && message.hasOwnProperty("serverName"))
                object.serverName = message.serverName;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.roomName != null && message.hasOwnProperty("roomName"))
                object.roomName = message.roomName;
            if (message.minEnterScore != null && message.hasOwnProperty("minEnterScore"))
                if (typeof message.minEnterScore === "number")
                    object.minEnterScore = options.longs === String ? String(message.minEnterScore) : message.minEnterScore;
                else
                    object.minEnterScore = options.longs === String ? $util.Long.prototype.toString.call(message.minEnterScore) : options.longs === Number ? new $util.LongBits(message.minEnterScore.low >>> 0, message.minEnterScore.high >>> 0).toNumber() : message.minEnterScore;
            if (message.roomBet != null && message.hasOwnProperty("roomBet"))
                if (typeof message.roomBet === "number")
                    object.roomBet = options.longs === String ? String(message.roomBet) : message.roomBet;
                else
                    object.roomBet = options.longs === String ? $util.Long.prototype.toString.call(message.roomBet) : options.longs === Number ? new $util.LongBits(message.roomBet.low >>> 0, message.roomBet.high >>> 0).toNumber() : message.roomBet;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.minGun != null && message.hasOwnProperty("minGun"))
                if (typeof message.minGun === "number")
                    object.minGun = options.longs === String ? String(message.minGun) : message.minGun;
                else
                    object.minGun = options.longs === String ? $util.Long.prototype.toString.call(message.minGun) : options.longs === Number ? new $util.LongBits(message.minGun.low >>> 0, message.minGun.high >>> 0).toNumber() : message.minGun;
            if (message.maxGun != null && message.hasOwnProperty("maxGun"))
                if (typeof message.maxGun === "number")
                    object.maxGun = options.longs === String ? String(message.maxGun) : message.maxGun;
                else
                    object.maxGun = options.longs === String ? $util.Long.prototype.toString.call(message.maxGun) : options.longs === Number ? new $util.LongBits(message.maxGun.low >>> 0, message.maxGun.high >>> 0).toNumber() : message.maxGun;
            if (message.showDesks != null && message.hasOwnProperty("showDesks"))
                object.showDesks = message.showDesks;
            if (message.roomType != null && message.hasOwnProperty("roomType"))
                object.roomType = message.roomType;
            if (message.extraConfig != null && message.hasOwnProperty("extraConfig"))
                object.extraConfig = message.extraConfig;
            return object;
        };

        /**
         * Converts this RoomConfigItem to JSON.
         * @function toJSON
         * @memberof CLPF.RoomConfigItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoomConfigItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoomConfigItem;
    })();

    CLPF.ClientGameConfigListNtf = (function() {

        /**
         * Properties of a ClientGameConfigListNtf.
         * @memberof CLPF
         * @interface IClientGameConfigListNtf
         * @property {Array.<CLPF.IGameConfigItem>|null} [items] ClientGameConfigListNtf items
         */

        /**
         * Constructs a new ClientGameConfigListNtf.
         * @memberof CLPF
         * @classdesc Represents a ClientGameConfigListNtf.
         * @implements IClientGameConfigListNtf
         * @constructor
         * @param {CLPF.IClientGameConfigListNtf=} [properties] Properties to set
         */
        function ClientGameConfigListNtf(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientGameConfigListNtf items.
         * @member {Array.<CLPF.IGameConfigItem>} items
         * @memberof CLPF.ClientGameConfigListNtf
         * @instance
         */
        ClientGameConfigListNtf.prototype.items = $util.emptyArray;

        /**
         * Creates a new ClientGameConfigListNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {CLPF.IClientGameConfigListNtf=} [properties] Properties to set
         * @returns {CLPF.ClientGameConfigListNtf} ClientGameConfigListNtf instance
         */
        ClientGameConfigListNtf.create = function create(properties) {
            return new ClientGameConfigListNtf(properties);
        };

        /**
         * Encodes the specified ClientGameConfigListNtf message. Does not implicitly {@link CLPF.ClientGameConfigListNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {CLPF.IClientGameConfigListNtf} message ClientGameConfigListNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientGameConfigListNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.GameConfigItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientGameConfigListNtf message, length delimited. Does not implicitly {@link CLPF.ClientGameConfigListNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {CLPF.IClientGameConfigListNtf} message ClientGameConfigListNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientGameConfigListNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientGameConfigListNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ClientGameConfigListNtf} ClientGameConfigListNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientGameConfigListNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ClientGameConfigListNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.GameConfigItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientGameConfigListNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ClientGameConfigListNtf} ClientGameConfigListNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientGameConfigListNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientGameConfigListNtf message.
         * @function verify
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientGameConfigListNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.GameConfigItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientGameConfigListNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ClientGameConfigListNtf} ClientGameConfigListNtf
         */
        ClientGameConfigListNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ClientGameConfigListNtf)
                return object;
            var message = new $root.CLPF.ClientGameConfigListNtf();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.ClientGameConfigListNtf.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.ClientGameConfigListNtf.items: object expected");
                    message.items[i] = $root.CLPF.GameConfigItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientGameConfigListNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ClientGameConfigListNtf
         * @static
         * @param {CLPF.ClientGameConfigListNtf} message ClientGameConfigListNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientGameConfigListNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.GameConfigItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientGameConfigListNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ClientGameConfigListNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientGameConfigListNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientGameConfigListNtf;
    })();

    CLPF.GameConfigChangedNtf = (function() {

        /**
         * Properties of a GameConfigChangedNtf.
         * @memberof CLPF
         * @interface IGameConfigChangedNtf
         * @property {Array.<CLPF.IGameConfigItem>|null} [addOrReplaceItems] GameConfigChangedNtf addOrReplaceItems
         * @property {Array.<number>|null} [removeItems] GameConfigChangedNtf removeItems
         */

        /**
         * Constructs a new GameConfigChangedNtf.
         * @memberof CLPF
         * @classdesc Represents a GameConfigChangedNtf.
         * @implements IGameConfigChangedNtf
         * @constructor
         * @param {CLPF.IGameConfigChangedNtf=} [properties] Properties to set
         */
        function GameConfigChangedNtf(properties) {
            this.addOrReplaceItems = [];
            this.removeItems = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameConfigChangedNtf addOrReplaceItems.
         * @member {Array.<CLPF.IGameConfigItem>} addOrReplaceItems
         * @memberof CLPF.GameConfigChangedNtf
         * @instance
         */
        GameConfigChangedNtf.prototype.addOrReplaceItems = $util.emptyArray;

        /**
         * GameConfigChangedNtf removeItems.
         * @member {Array.<number>} removeItems
         * @memberof CLPF.GameConfigChangedNtf
         * @instance
         */
        GameConfigChangedNtf.prototype.removeItems = $util.emptyArray;

        /**
         * Creates a new GameConfigChangedNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {CLPF.IGameConfigChangedNtf=} [properties] Properties to set
         * @returns {CLPF.GameConfigChangedNtf} GameConfigChangedNtf instance
         */
        GameConfigChangedNtf.create = function create(properties) {
            return new GameConfigChangedNtf(properties);
        };

        /**
         * Encodes the specified GameConfigChangedNtf message. Does not implicitly {@link CLPF.GameConfigChangedNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {CLPF.IGameConfigChangedNtf} message GameConfigChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameConfigChangedNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addOrReplaceItems != null && message.addOrReplaceItems.length)
                for (var i = 0; i < message.addOrReplaceItems.length; ++i)
                    $root.CLPF.GameConfigItem.encode(message.addOrReplaceItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.removeItems != null && message.removeItems.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.removeItems.length; ++i)
                    writer.int32(message.removeItems[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GameConfigChangedNtf message, length delimited. Does not implicitly {@link CLPF.GameConfigChangedNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {CLPF.IGameConfigChangedNtf} message GameConfigChangedNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameConfigChangedNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameConfigChangedNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GameConfigChangedNtf} GameConfigChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameConfigChangedNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GameConfigChangedNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addOrReplaceItems && message.addOrReplaceItems.length))
                        message.addOrReplaceItems = [];
                    message.addOrReplaceItems.push($root.CLPF.GameConfigItem.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.removeItems && message.removeItems.length))
                        message.removeItems = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.removeItems.push(reader.int32());
                    } else
                        message.removeItems.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameConfigChangedNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GameConfigChangedNtf} GameConfigChangedNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameConfigChangedNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameConfigChangedNtf message.
         * @function verify
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameConfigChangedNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addOrReplaceItems != null && message.hasOwnProperty("addOrReplaceItems")) {
                if (!Array.isArray(message.addOrReplaceItems))
                    return "addOrReplaceItems: array expected";
                for (var i = 0; i < message.addOrReplaceItems.length; ++i) {
                    var error = $root.CLPF.GameConfigItem.verify(message.addOrReplaceItems[i]);
                    if (error)
                        return "addOrReplaceItems." + error;
                }
            }
            if (message.removeItems != null && message.hasOwnProperty("removeItems")) {
                if (!Array.isArray(message.removeItems))
                    return "removeItems: array expected";
                for (var i = 0; i < message.removeItems.length; ++i)
                    if (!$util.isInteger(message.removeItems[i]))
                        return "removeItems: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a GameConfigChangedNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GameConfigChangedNtf} GameConfigChangedNtf
         */
        GameConfigChangedNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GameConfigChangedNtf)
                return object;
            var message = new $root.CLPF.GameConfigChangedNtf();
            if (object.addOrReplaceItems) {
                if (!Array.isArray(object.addOrReplaceItems))
                    throw TypeError(".CLPF.GameConfigChangedNtf.addOrReplaceItems: array expected");
                message.addOrReplaceItems = [];
                for (var i = 0; i < object.addOrReplaceItems.length; ++i) {
                    if (typeof object.addOrReplaceItems[i] !== "object")
                        throw TypeError(".CLPF.GameConfigChangedNtf.addOrReplaceItems: object expected");
                    message.addOrReplaceItems[i] = $root.CLPF.GameConfigItem.fromObject(object.addOrReplaceItems[i]);
                }
            }
            if (object.removeItems) {
                if (!Array.isArray(object.removeItems))
                    throw TypeError(".CLPF.GameConfigChangedNtf.removeItems: array expected");
                message.removeItems = [];
                for (var i = 0; i < object.removeItems.length; ++i)
                    message.removeItems[i] = object.removeItems[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a GameConfigChangedNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GameConfigChangedNtf
         * @static
         * @param {CLPF.GameConfigChangedNtf} message GameConfigChangedNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameConfigChangedNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.addOrReplaceItems = [];
                object.removeItems = [];
            }
            if (message.addOrReplaceItems && message.addOrReplaceItems.length) {
                object.addOrReplaceItems = [];
                for (var j = 0; j < message.addOrReplaceItems.length; ++j)
                    object.addOrReplaceItems[j] = $root.CLPF.GameConfigItem.toObject(message.addOrReplaceItems[j], options);
            }
            if (message.removeItems && message.removeItems.length) {
                object.removeItems = [];
                for (var j = 0; j < message.removeItems.length; ++j)
                    object.removeItems[j] = message.removeItems[j];
            }
            return object;
        };

        /**
         * Converts this GameConfigChangedNtf to JSON.
         * @function toJSON
         * @memberof CLPF.GameConfigChangedNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameConfigChangedNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameConfigChangedNtf;
    })();

    CLPF.QueryGameConfigReq = (function() {

        /**
         * Properties of a QueryGameConfigReq.
         * @memberof CLPF
         * @interface IQueryGameConfigReq
         * @property {number|null} [gameId] QueryGameConfigReq gameId
         */

        /**
         * Constructs a new QueryGameConfigReq.
         * @memberof CLPF
         * @classdesc Represents a QueryGameConfigReq.
         * @implements IQueryGameConfigReq
         * @constructor
         * @param {CLPF.IQueryGameConfigReq=} [properties] Properties to set
         */
        function QueryGameConfigReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGameConfigReq gameId.
         * @member {number} gameId
         * @memberof CLPF.QueryGameConfigReq
         * @instance
         */
        QueryGameConfigReq.prototype.gameId = 0;

        /**
         * Creates a new QueryGameConfigReq instance using the specified properties.
         * @function create
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {CLPF.IQueryGameConfigReq=} [properties] Properties to set
         * @returns {CLPF.QueryGameConfigReq} QueryGameConfigReq instance
         */
        QueryGameConfigReq.create = function create(properties) {
            return new QueryGameConfigReq(properties);
        };

        /**
         * Encodes the specified QueryGameConfigReq message. Does not implicitly {@link CLPF.QueryGameConfigReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {CLPF.IQueryGameConfigReq} message QueryGameConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGameConfigReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified QueryGameConfigReq message, length delimited. Does not implicitly {@link CLPF.QueryGameConfigReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {CLPF.IQueryGameConfigReq} message QueryGameConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGameConfigReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGameConfigReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.QueryGameConfigReq} QueryGameConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGameConfigReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.QueryGameConfigReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryGameConfigReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.QueryGameConfigReq} QueryGameConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGameConfigReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGameConfigReq message.
         * @function verify
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGameConfigReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            return null;
        };

        /**
         * Creates a QueryGameConfigReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.QueryGameConfigReq} QueryGameConfigReq
         */
        QueryGameConfigReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.QueryGameConfigReq)
                return object;
            var message = new $root.CLPF.QueryGameConfigReq();
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            return message;
        };

        /**
         * Creates a plain object from a QueryGameConfigReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.QueryGameConfigReq
         * @static
         * @param {CLPF.QueryGameConfigReq} message QueryGameConfigReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGameConfigReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.gameId = 0;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this QueryGameConfigReq to JSON.
         * @function toJSON
         * @memberof CLPF.QueryGameConfigReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGameConfigReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGameConfigReq;
    })();

    CLPF.QueryGameConfigAck = (function() {

        /**
         * Properties of a QueryGameConfigAck.
         * @memberof CLPF
         * @interface IQueryGameConfigAck
         * @property {number|null} [errcode] QueryGameConfigAck errcode
         * @property {Array.<CLPF.IGameConfigItem>|null} [items] QueryGameConfigAck items
         */

        /**
         * Constructs a new QueryGameConfigAck.
         * @memberof CLPF
         * @classdesc Represents a QueryGameConfigAck.
         * @implements IQueryGameConfigAck
         * @constructor
         * @param {CLPF.IQueryGameConfigAck=} [properties] Properties to set
         */
        function QueryGameConfigAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGameConfigAck errcode.
         * @member {number} errcode
         * @memberof CLPF.QueryGameConfigAck
         * @instance
         */
        QueryGameConfigAck.prototype.errcode = 0;

        /**
         * QueryGameConfigAck items.
         * @member {Array.<CLPF.IGameConfigItem>} items
         * @memberof CLPF.QueryGameConfigAck
         * @instance
         */
        QueryGameConfigAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new QueryGameConfigAck instance using the specified properties.
         * @function create
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {CLPF.IQueryGameConfigAck=} [properties] Properties to set
         * @returns {CLPF.QueryGameConfigAck} QueryGameConfigAck instance
         */
        QueryGameConfigAck.create = function create(properties) {
            return new QueryGameConfigAck(properties);
        };

        /**
         * Encodes the specified QueryGameConfigAck message. Does not implicitly {@link CLPF.QueryGameConfigAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {CLPF.IQueryGameConfigAck} message QueryGameConfigAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGameConfigAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.GameConfigItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryGameConfigAck message, length delimited. Does not implicitly {@link CLPF.QueryGameConfigAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {CLPF.IQueryGameConfigAck} message QueryGameConfigAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGameConfigAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGameConfigAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.QueryGameConfigAck} QueryGameConfigAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGameConfigAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.QueryGameConfigAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.GameConfigItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryGameConfigAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.QueryGameConfigAck} QueryGameConfigAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGameConfigAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGameConfigAck message.
         * @function verify
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGameConfigAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.GameConfigItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryGameConfigAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.QueryGameConfigAck} QueryGameConfigAck
         */
        QueryGameConfigAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.QueryGameConfigAck)
                return object;
            var message = new $root.CLPF.QueryGameConfigAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.QueryGameConfigAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.QueryGameConfigAck.items: object expected");
                    message.items[i] = $root.CLPF.GameConfigItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryGameConfigAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.QueryGameConfigAck
         * @static
         * @param {CLPF.QueryGameConfigAck} message QueryGameConfigAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGameConfigAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.GameConfigItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryGameConfigAck to JSON.
         * @function toJSON
         * @memberof CLPF.QueryGameConfigAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGameConfigAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGameConfigAck;
    })();

    CLPF.EnterRoomReq = (function() {

        /**
         * Properties of an EnterRoomReq.
         * @memberof CLPF
         * @interface IEnterRoomReq
         * @property {number|null} [gameId] EnterRoomReq gameId
         * @property {number|null} [roomId] EnterRoomReq roomId
         */

        /**
         * Constructs a new EnterRoomReq.
         * @memberof CLPF
         * @classdesc Represents an EnterRoomReq.
         * @implements IEnterRoomReq
         * @constructor
         * @param {CLPF.IEnterRoomReq=} [properties] Properties to set
         */
        function EnterRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRoomReq gameId.
         * @member {number} gameId
         * @memberof CLPF.EnterRoomReq
         * @instance
         */
        EnterRoomReq.prototype.gameId = 0;

        /**
         * EnterRoomReq roomId.
         * @member {number} roomId
         * @memberof CLPF.EnterRoomReq
         * @instance
         */
        EnterRoomReq.prototype.roomId = 0;

        /**
         * Creates a new EnterRoomReq instance using the specified properties.
         * @function create
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {CLPF.IEnterRoomReq=} [properties] Properties to set
         * @returns {CLPF.EnterRoomReq} EnterRoomReq instance
         */
        EnterRoomReq.create = function create(properties) {
            return new EnterRoomReq(properties);
        };

        /**
         * Encodes the specified EnterRoomReq message. Does not implicitly {@link CLPF.EnterRoomReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {CLPF.IEnterRoomReq} message EnterRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roomId);
            return writer;
        };

        /**
         * Encodes the specified EnterRoomReq message, length delimited. Does not implicitly {@link CLPF.EnterRoomReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {CLPF.IEnterRoomReq} message EnterRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.EnterRoomReq} EnterRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.EnterRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameId = reader.int32();
                    break;
                case 2:
                    message.roomId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterRoomReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.EnterRoomReq} EnterRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterRoomReq message.
         * @function verify
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterRoomReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            return null;
        };

        /**
         * Creates an EnterRoomReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.EnterRoomReq} EnterRoomReq
         */
        EnterRoomReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.EnterRoomReq)
                return object;
            var message = new $root.CLPF.EnterRoomReq();
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EnterRoomReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.EnterRoomReq
         * @static
         * @param {CLPF.EnterRoomReq} message EnterRoomReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterRoomReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gameId = 0;
                object.roomId = 0;
            }
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            return object;
        };

        /**
         * Converts this EnterRoomReq to JSON.
         * @function toJSON
         * @memberof CLPF.EnterRoomReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterRoomReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterRoomReq;
    })();

    CLPF.EnterRoomAck = (function() {

        /**
         * Properties of an EnterRoomAck.
         * @memberof CLPF
         * @interface IEnterRoomAck
         * @property {number|null} [errcode] EnterRoomAck errcode
         * @property {string|null} [errmessage] EnterRoomAck errmessage
         */

        /**
         * Constructs a new EnterRoomAck.
         * @memberof CLPF
         * @classdesc Represents an EnterRoomAck.
         * @implements IEnterRoomAck
         * @constructor
         * @param {CLPF.IEnterRoomAck=} [properties] Properties to set
         */
        function EnterRoomAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRoomAck errcode.
         * @member {number} errcode
         * @memberof CLPF.EnterRoomAck
         * @instance
         */
        EnterRoomAck.prototype.errcode = 0;

        /**
         * EnterRoomAck errmessage.
         * @member {string} errmessage
         * @memberof CLPF.EnterRoomAck
         * @instance
         */
        EnterRoomAck.prototype.errmessage = "";

        /**
         * Creates a new EnterRoomAck instance using the specified properties.
         * @function create
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {CLPF.IEnterRoomAck=} [properties] Properties to set
         * @returns {CLPF.EnterRoomAck} EnterRoomAck instance
         */
        EnterRoomAck.create = function create(properties) {
            return new EnterRoomAck(properties);
        };

        /**
         * Encodes the specified EnterRoomAck message. Does not implicitly {@link CLPF.EnterRoomAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {CLPF.IEnterRoomAck} message EnterRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRoomAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.errmessage != null && Object.hasOwnProperty.call(message, "errmessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errmessage);
            return writer;
        };

        /**
         * Encodes the specified EnterRoomAck message, length delimited. Does not implicitly {@link CLPF.EnterRoomAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {CLPF.IEnterRoomAck} message EnterRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRoomAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterRoomAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.EnterRoomAck} EnterRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.EnterRoomAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.errmessage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterRoomAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.EnterRoomAck} EnterRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterRoomAck message.
         * @function verify
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterRoomAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                if (!$util.isString(message.errmessage))
                    return "errmessage: string expected";
            return null;
        };

        /**
         * Creates an EnterRoomAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.EnterRoomAck} EnterRoomAck
         */
        EnterRoomAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.EnterRoomAck)
                return object;
            var message = new $root.CLPF.EnterRoomAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.errmessage != null)
                message.errmessage = String(object.errmessage);
            return message;
        };

        /**
         * Creates a plain object from an EnterRoomAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.EnterRoomAck
         * @static
         * @param {CLPF.EnterRoomAck} message EnterRoomAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterRoomAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.errmessage = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                object.errmessage = message.errmessage;
            return object;
        };

        /**
         * Converts this EnterRoomAck to JSON.
         * @function toJSON
         * @memberof CLPF.EnterRoomAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterRoomAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterRoomAck;
    })();

    CLPF.ExitRoomReq = (function() {

        /**
         * Properties of an ExitRoomReq.
         * @memberof CLPF
         * @interface IExitRoomReq
         */

        /**
         * Constructs a new ExitRoomReq.
         * @memberof CLPF
         * @classdesc Represents an ExitRoomReq.
         * @implements IExitRoomReq
         * @constructor
         * @param {CLPF.IExitRoomReq=} [properties] Properties to set
         */
        function ExitRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ExitRoomReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {CLPF.IExitRoomReq=} [properties] Properties to set
         * @returns {CLPF.ExitRoomReq} ExitRoomReq instance
         */
        ExitRoomReq.create = function create(properties) {
            return new ExitRoomReq(properties);
        };

        /**
         * Encodes the specified ExitRoomReq message. Does not implicitly {@link CLPF.ExitRoomReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {CLPF.IExitRoomReq} message ExitRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ExitRoomReq message, length delimited. Does not implicitly {@link CLPF.ExitRoomReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {CLPF.IExitRoomReq} message ExitRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExitRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ExitRoomReq} ExitRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ExitRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExitRoomReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ExitRoomReq} ExitRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExitRoomReq message.
         * @function verify
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExitRoomReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an ExitRoomReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ExitRoomReq} ExitRoomReq
         */
        ExitRoomReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ExitRoomReq)
                return object;
            return new $root.CLPF.ExitRoomReq();
        };

        /**
         * Creates a plain object from an ExitRoomReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ExitRoomReq
         * @static
         * @param {CLPF.ExitRoomReq} message ExitRoomReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExitRoomReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ExitRoomReq to JSON.
         * @function toJSON
         * @memberof CLPF.ExitRoomReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExitRoomReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExitRoomReq;
    })();

    CLPF.ExitRoomAck = (function() {

        /**
         * Properties of an ExitRoomAck.
         * @memberof CLPF
         * @interface IExitRoomAck
         * @property {number|null} [errcode] ExitRoomAck errcode
         */

        /**
         * Constructs a new ExitRoomAck.
         * @memberof CLPF
         * @classdesc Represents an ExitRoomAck.
         * @implements IExitRoomAck
         * @constructor
         * @param {CLPF.IExitRoomAck=} [properties] Properties to set
         */
        function ExitRoomAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExitRoomAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ExitRoomAck
         * @instance
         */
        ExitRoomAck.prototype.errcode = 0;

        /**
         * Creates a new ExitRoomAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {CLPF.IExitRoomAck=} [properties] Properties to set
         * @returns {CLPF.ExitRoomAck} ExitRoomAck instance
         */
        ExitRoomAck.create = function create(properties) {
            return new ExitRoomAck(properties);
        };

        /**
         * Encodes the specified ExitRoomAck message. Does not implicitly {@link CLPF.ExitRoomAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {CLPF.IExitRoomAck} message ExitRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ExitRoomAck message, length delimited. Does not implicitly {@link CLPF.ExitRoomAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {CLPF.IExitRoomAck} message ExitRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExitRoomAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ExitRoomAck} ExitRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ExitRoomAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExitRoomAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ExitRoomAck} ExitRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExitRoomAck message.
         * @function verify
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExitRoomAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates an ExitRoomAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ExitRoomAck} ExitRoomAck
         */
        ExitRoomAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ExitRoomAck)
                return object;
            var message = new $root.CLPF.ExitRoomAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExitRoomAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ExitRoomAck
         * @static
         * @param {CLPF.ExitRoomAck} message ExitRoomAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExitRoomAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ExitRoomAck to JSON.
         * @function toJSON
         * @memberof CLPF.ExitRoomAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExitRoomAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExitRoomAck;
    })();

    CLPF.ExitRoomNtf = (function() {

        /**
         * Properties of an ExitRoomNtf.
         * @memberof CLPF
         * @interface IExitRoomNtf
         * @property {number|null} [reason] ExitRoomNtf reason
         * @property {string|null} [errmessage] ExitRoomNtf errmessage
         */

        /**
         * Constructs a new ExitRoomNtf.
         * @memberof CLPF
         * @classdesc Represents an ExitRoomNtf.
         * @implements IExitRoomNtf
         * @constructor
         * @param {CLPF.IExitRoomNtf=} [properties] Properties to set
         */
        function ExitRoomNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExitRoomNtf reason.
         * @member {number} reason
         * @memberof CLPF.ExitRoomNtf
         * @instance
         */
        ExitRoomNtf.prototype.reason = 0;

        /**
         * ExitRoomNtf errmessage.
         * @member {string} errmessage
         * @memberof CLPF.ExitRoomNtf
         * @instance
         */
        ExitRoomNtf.prototype.errmessage = "";

        /**
         * Creates a new ExitRoomNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {CLPF.IExitRoomNtf=} [properties] Properties to set
         * @returns {CLPF.ExitRoomNtf} ExitRoomNtf instance
         */
        ExitRoomNtf.create = function create(properties) {
            return new ExitRoomNtf(properties);
        };

        /**
         * Encodes the specified ExitRoomNtf message. Does not implicitly {@link CLPF.ExitRoomNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {CLPF.IExitRoomNtf} message ExitRoomNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
            if (message.errmessage != null && Object.hasOwnProperty.call(message, "errmessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errmessage);
            return writer;
        };

        /**
         * Encodes the specified ExitRoomNtf message, length delimited. Does not implicitly {@link CLPF.ExitRoomNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {CLPF.IExitRoomNtf} message ExitRoomNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitRoomNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExitRoomNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ExitRoomNtf} ExitRoomNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ExitRoomNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.errmessage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExitRoomNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ExitRoomNtf} ExitRoomNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitRoomNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExitRoomNtf message.
         * @function verify
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExitRoomNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                if (!$util.isString(message.errmessage))
                    return "errmessage: string expected";
            return null;
        };

        /**
         * Creates an ExitRoomNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ExitRoomNtf} ExitRoomNtf
         */
        ExitRoomNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ExitRoomNtf)
                return object;
            var message = new $root.CLPF.ExitRoomNtf();
            if (object.reason != null)
                message.reason = object.reason | 0;
            if (object.errmessage != null)
                message.errmessage = String(object.errmessage);
            return message;
        };

        /**
         * Creates a plain object from an ExitRoomNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ExitRoomNtf
         * @static
         * @param {CLPF.ExitRoomNtf} message ExitRoomNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExitRoomNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reason = 0;
                object.errmessage = "";
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                object.errmessage = message.errmessage;
            return object;
        };

        /**
         * Converts this ExitRoomNtf to JSON.
         * @function toJSON
         * @memberof CLPF.ExitRoomNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExitRoomNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExitRoomNtf;
    })();

    CLPF.AccountPhoneBindReq = (function() {

        /**
         * Properties of an AccountPhoneBindReq.
         * @memberof CLPF
         * @interface IAccountPhoneBindReq
         * @property {string|null} [account] AccountPhoneBindReq account
         * @property {string|null} [phone] AccountPhoneBindReq phone
         * @property {string|null} [phoneCode] AccountPhoneBindReq phoneCode
         * @property {string|null} [password] AccountPhoneBindReq password
         */

        /**
         * Constructs a new AccountPhoneBindReq.
         * @memberof CLPF
         * @classdesc Represents an AccountPhoneBindReq.
         * @implements IAccountPhoneBindReq
         * @constructor
         * @param {CLPF.IAccountPhoneBindReq=} [properties] Properties to set
         */
        function AccountPhoneBindReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountPhoneBindReq account.
         * @member {string} account
         * @memberof CLPF.AccountPhoneBindReq
         * @instance
         */
        AccountPhoneBindReq.prototype.account = "";

        /**
         * AccountPhoneBindReq phone.
         * @member {string} phone
         * @memberof CLPF.AccountPhoneBindReq
         * @instance
         */
        AccountPhoneBindReq.prototype.phone = "";

        /**
         * AccountPhoneBindReq phoneCode.
         * @member {string} phoneCode
         * @memberof CLPF.AccountPhoneBindReq
         * @instance
         */
        AccountPhoneBindReq.prototype.phoneCode = "";

        /**
         * AccountPhoneBindReq password.
         * @member {string} password
         * @memberof CLPF.AccountPhoneBindReq
         * @instance
         */
        AccountPhoneBindReq.prototype.password = "";

        /**
         * Creates a new AccountPhoneBindReq instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {CLPF.IAccountPhoneBindReq=} [properties] Properties to set
         * @returns {CLPF.AccountPhoneBindReq} AccountPhoneBindReq instance
         */
        AccountPhoneBindReq.create = function create(properties) {
            return new AccountPhoneBindReq(properties);
        };

        /**
         * Encodes the specified AccountPhoneBindReq message. Does not implicitly {@link CLPF.AccountPhoneBindReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {CLPF.IAccountPhoneBindReq} message AccountPhoneBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPhoneBindReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);
            if (message.phoneCode != null && Object.hasOwnProperty.call(message, "phoneCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.phoneCode);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified AccountPhoneBindReq message, length delimited. Does not implicitly {@link CLPF.AccountPhoneBindReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {CLPF.IAccountPhoneBindReq} message AccountPhoneBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPhoneBindReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountPhoneBindReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountPhoneBindReq} AccountPhoneBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPhoneBindReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountPhoneBindReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                case 3:
                    message.phoneCode = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountPhoneBindReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountPhoneBindReq} AccountPhoneBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPhoneBindReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountPhoneBindReq message.
         * @function verify
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountPhoneBindReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.phoneCode != null && message.hasOwnProperty("phoneCode"))
                if (!$util.isString(message.phoneCode))
                    return "phoneCode: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates an AccountPhoneBindReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountPhoneBindReq} AccountPhoneBindReq
         */
        AccountPhoneBindReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountPhoneBindReq)
                return object;
            var message = new $root.CLPF.AccountPhoneBindReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.phoneCode != null)
                message.phoneCode = String(object.phoneCode);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from an AccountPhoneBindReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountPhoneBindReq
         * @static
         * @param {CLPF.AccountPhoneBindReq} message AccountPhoneBindReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountPhoneBindReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = "";
                object.phone = "";
                object.phoneCode = "";
                object.password = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.phoneCode != null && message.hasOwnProperty("phoneCode"))
                object.phoneCode = message.phoneCode;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this AccountPhoneBindReq to JSON.
         * @function toJSON
         * @memberof CLPF.AccountPhoneBindReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountPhoneBindReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountPhoneBindReq;
    })();

    CLPF.AccountPhoneBindAck = (function() {

        /**
         * Properties of an AccountPhoneBindAck.
         * @memberof CLPF
         * @interface IAccountPhoneBindAck
         * @property {number|null} [errcode] AccountPhoneBindAck errcode
         * @property {string|null} [account] AccountPhoneBindAck account
         */

        /**
         * Constructs a new AccountPhoneBindAck.
         * @memberof CLPF
         * @classdesc Represents an AccountPhoneBindAck.
         * @implements IAccountPhoneBindAck
         * @constructor
         * @param {CLPF.IAccountPhoneBindAck=} [properties] Properties to set
         */
        function AccountPhoneBindAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountPhoneBindAck errcode.
         * @member {number} errcode
         * @memberof CLPF.AccountPhoneBindAck
         * @instance
         */
        AccountPhoneBindAck.prototype.errcode = 0;

        /**
         * AccountPhoneBindAck account.
         * @member {string} account
         * @memberof CLPF.AccountPhoneBindAck
         * @instance
         */
        AccountPhoneBindAck.prototype.account = "";

        /**
         * Creates a new AccountPhoneBindAck instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {CLPF.IAccountPhoneBindAck=} [properties] Properties to set
         * @returns {CLPF.AccountPhoneBindAck} AccountPhoneBindAck instance
         */
        AccountPhoneBindAck.create = function create(properties) {
            return new AccountPhoneBindAck(properties);
        };

        /**
         * Encodes the specified AccountPhoneBindAck message. Does not implicitly {@link CLPF.AccountPhoneBindAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {CLPF.IAccountPhoneBindAck} message AccountPhoneBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPhoneBindAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.account);
            return writer;
        };

        /**
         * Encodes the specified AccountPhoneBindAck message, length delimited. Does not implicitly {@link CLPF.AccountPhoneBindAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {CLPF.IAccountPhoneBindAck} message AccountPhoneBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPhoneBindAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountPhoneBindAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountPhoneBindAck} AccountPhoneBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPhoneBindAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountPhoneBindAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.account = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountPhoneBindAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountPhoneBindAck} AccountPhoneBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPhoneBindAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountPhoneBindAck message.
         * @function verify
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountPhoneBindAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            return null;
        };

        /**
         * Creates an AccountPhoneBindAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountPhoneBindAck} AccountPhoneBindAck
         */
        AccountPhoneBindAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountPhoneBindAck)
                return object;
            var message = new $root.CLPF.AccountPhoneBindAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.account != null)
                message.account = String(object.account);
            return message;
        };

        /**
         * Creates a plain object from an AccountPhoneBindAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountPhoneBindAck
         * @static
         * @param {CLPF.AccountPhoneBindAck} message AccountPhoneBindAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountPhoneBindAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.account = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            return object;
        };

        /**
         * Converts this AccountPhoneBindAck to JSON.
         * @function toJSON
         * @memberof CLPF.AccountPhoneBindAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountPhoneBindAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountPhoneBindAck;
    })();

    CLPF.AccountEmailBindReq = (function() {

        /**
         * Properties of an AccountEmailBindReq.
         * @memberof CLPF
         * @interface IAccountEmailBindReq
         * @property {string|null} [account] AccountEmailBindReq account
         * @property {string|null} [email] AccountEmailBindReq email
         * @property {string|null} [emailCode] AccountEmailBindReq emailCode
         * @property {string|null} [password] AccountEmailBindReq password
         */

        /**
         * Constructs a new AccountEmailBindReq.
         * @memberof CLPF
         * @classdesc Represents an AccountEmailBindReq.
         * @implements IAccountEmailBindReq
         * @constructor
         * @param {CLPF.IAccountEmailBindReq=} [properties] Properties to set
         */
        function AccountEmailBindReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountEmailBindReq account.
         * @member {string} account
         * @memberof CLPF.AccountEmailBindReq
         * @instance
         */
        AccountEmailBindReq.prototype.account = "";

        /**
         * AccountEmailBindReq email.
         * @member {string} email
         * @memberof CLPF.AccountEmailBindReq
         * @instance
         */
        AccountEmailBindReq.prototype.email = "";

        /**
         * AccountEmailBindReq emailCode.
         * @member {string} emailCode
         * @memberof CLPF.AccountEmailBindReq
         * @instance
         */
        AccountEmailBindReq.prototype.emailCode = "";

        /**
         * AccountEmailBindReq password.
         * @member {string} password
         * @memberof CLPF.AccountEmailBindReq
         * @instance
         */
        AccountEmailBindReq.prototype.password = "";

        /**
         * Creates a new AccountEmailBindReq instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {CLPF.IAccountEmailBindReq=} [properties] Properties to set
         * @returns {CLPF.AccountEmailBindReq} AccountEmailBindReq instance
         */
        AccountEmailBindReq.create = function create(properties) {
            return new AccountEmailBindReq(properties);
        };

        /**
         * Encodes the specified AccountEmailBindReq message. Does not implicitly {@link CLPF.AccountEmailBindReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {CLPF.IAccountEmailBindReq} message AccountEmailBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountEmailBindReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.emailCode != null && Object.hasOwnProperty.call(message, "emailCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.emailCode);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified AccountEmailBindReq message, length delimited. Does not implicitly {@link CLPF.AccountEmailBindReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {CLPF.IAccountEmailBindReq} message AccountEmailBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountEmailBindReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountEmailBindReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountEmailBindReq} AccountEmailBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountEmailBindReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountEmailBindReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.emailCode = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountEmailBindReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountEmailBindReq} AccountEmailBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountEmailBindReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountEmailBindReq message.
         * @function verify
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountEmailBindReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.emailCode != null && message.hasOwnProperty("emailCode"))
                if (!$util.isString(message.emailCode))
                    return "emailCode: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates an AccountEmailBindReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountEmailBindReq} AccountEmailBindReq
         */
        AccountEmailBindReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountEmailBindReq)
                return object;
            var message = new $root.CLPF.AccountEmailBindReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.email != null)
                message.email = String(object.email);
            if (object.emailCode != null)
                message.emailCode = String(object.emailCode);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from an AccountEmailBindReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountEmailBindReq
         * @static
         * @param {CLPF.AccountEmailBindReq} message AccountEmailBindReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountEmailBindReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = "";
                object.email = "";
                object.emailCode = "";
                object.password = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.emailCode != null && message.hasOwnProperty("emailCode"))
                object.emailCode = message.emailCode;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this AccountEmailBindReq to JSON.
         * @function toJSON
         * @memberof CLPF.AccountEmailBindReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountEmailBindReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountEmailBindReq;
    })();

    CLPF.AccountEmailBindAck = (function() {

        /**
         * Properties of an AccountEmailBindAck.
         * @memberof CLPF
         * @interface IAccountEmailBindAck
         * @property {number|null} [errcode] AccountEmailBindAck errcode
         * @property {string|null} [account] AccountEmailBindAck account
         */

        /**
         * Constructs a new AccountEmailBindAck.
         * @memberof CLPF
         * @classdesc Represents an AccountEmailBindAck.
         * @implements IAccountEmailBindAck
         * @constructor
         * @param {CLPF.IAccountEmailBindAck=} [properties] Properties to set
         */
        function AccountEmailBindAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountEmailBindAck errcode.
         * @member {number} errcode
         * @memberof CLPF.AccountEmailBindAck
         * @instance
         */
        AccountEmailBindAck.prototype.errcode = 0;

        /**
         * AccountEmailBindAck account.
         * @member {string} account
         * @memberof CLPF.AccountEmailBindAck
         * @instance
         */
        AccountEmailBindAck.prototype.account = "";

        /**
         * Creates a new AccountEmailBindAck instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {CLPF.IAccountEmailBindAck=} [properties] Properties to set
         * @returns {CLPF.AccountEmailBindAck} AccountEmailBindAck instance
         */
        AccountEmailBindAck.create = function create(properties) {
            return new AccountEmailBindAck(properties);
        };

        /**
         * Encodes the specified AccountEmailBindAck message. Does not implicitly {@link CLPF.AccountEmailBindAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {CLPF.IAccountEmailBindAck} message AccountEmailBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountEmailBindAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.account);
            return writer;
        };

        /**
         * Encodes the specified AccountEmailBindAck message, length delimited. Does not implicitly {@link CLPF.AccountEmailBindAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {CLPF.IAccountEmailBindAck} message AccountEmailBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountEmailBindAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountEmailBindAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountEmailBindAck} AccountEmailBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountEmailBindAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountEmailBindAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.account = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountEmailBindAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountEmailBindAck} AccountEmailBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountEmailBindAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountEmailBindAck message.
         * @function verify
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountEmailBindAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            return null;
        };

        /**
         * Creates an AccountEmailBindAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountEmailBindAck} AccountEmailBindAck
         */
        AccountEmailBindAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountEmailBindAck)
                return object;
            var message = new $root.CLPF.AccountEmailBindAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.account != null)
                message.account = String(object.account);
            return message;
        };

        /**
         * Creates a plain object from an AccountEmailBindAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountEmailBindAck
         * @static
         * @param {CLPF.AccountEmailBindAck} message AccountEmailBindAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountEmailBindAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.account = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            return object;
        };

        /**
         * Converts this AccountEmailBindAck to JSON.
         * @function toJSON
         * @memberof CLPF.AccountEmailBindAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountEmailBindAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountEmailBindAck;
    })();

    CLPF.AccountBindReq = (function() {

        /**
         * Properties of an AccountBindReq.
         * @memberof CLPF
         * @interface IAccountBindReq
         * @property {string|null} [account] AccountBindReq account
         * @property {string|null} [password] AccountBindReq password
         */

        /**
         * Constructs a new AccountBindReq.
         * @memberof CLPF
         * @classdesc Represents an AccountBindReq.
         * @implements IAccountBindReq
         * @constructor
         * @param {CLPF.IAccountBindReq=} [properties] Properties to set
         */
        function AccountBindReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountBindReq account.
         * @member {string} account
         * @memberof CLPF.AccountBindReq
         * @instance
         */
        AccountBindReq.prototype.account = "";

        /**
         * AccountBindReq password.
         * @member {string} password
         * @memberof CLPF.AccountBindReq
         * @instance
         */
        AccountBindReq.prototype.password = "";

        /**
         * Creates a new AccountBindReq instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {CLPF.IAccountBindReq=} [properties] Properties to set
         * @returns {CLPF.AccountBindReq} AccountBindReq instance
         */
        AccountBindReq.create = function create(properties) {
            return new AccountBindReq(properties);
        };

        /**
         * Encodes the specified AccountBindReq message. Does not implicitly {@link CLPF.AccountBindReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {CLPF.IAccountBindReq} message AccountBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountBindReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified AccountBindReq message, length delimited. Does not implicitly {@link CLPF.AccountBindReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {CLPF.IAccountBindReq} message AccountBindReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountBindReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountBindReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountBindReq} AccountBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountBindReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountBindReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountBindReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountBindReq} AccountBindReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountBindReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountBindReq message.
         * @function verify
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountBindReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates an AccountBindReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountBindReq} AccountBindReq
         */
        AccountBindReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountBindReq)
                return object;
            var message = new $root.CLPF.AccountBindReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from an AccountBindReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountBindReq
         * @static
         * @param {CLPF.AccountBindReq} message AccountBindReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountBindReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = "";
                object.password = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this AccountBindReq to JSON.
         * @function toJSON
         * @memberof CLPF.AccountBindReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountBindReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountBindReq;
    })();

    CLPF.AccountBindAck = (function() {

        /**
         * Properties of an AccountBindAck.
         * @memberof CLPF
         * @interface IAccountBindAck
         * @property {number|null} [errcode] AccountBindAck errcode
         * @property {string|null} [account] AccountBindAck account
         */

        /**
         * Constructs a new AccountBindAck.
         * @memberof CLPF
         * @classdesc Represents an AccountBindAck.
         * @implements IAccountBindAck
         * @constructor
         * @param {CLPF.IAccountBindAck=} [properties] Properties to set
         */
        function AccountBindAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountBindAck errcode.
         * @member {number} errcode
         * @memberof CLPF.AccountBindAck
         * @instance
         */
        AccountBindAck.prototype.errcode = 0;

        /**
         * AccountBindAck account.
         * @member {string} account
         * @memberof CLPF.AccountBindAck
         * @instance
         */
        AccountBindAck.prototype.account = "";

        /**
         * Creates a new AccountBindAck instance using the specified properties.
         * @function create
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {CLPF.IAccountBindAck=} [properties] Properties to set
         * @returns {CLPF.AccountBindAck} AccountBindAck instance
         */
        AccountBindAck.create = function create(properties) {
            return new AccountBindAck(properties);
        };

        /**
         * Encodes the specified AccountBindAck message. Does not implicitly {@link CLPF.AccountBindAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {CLPF.IAccountBindAck} message AccountBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountBindAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.account);
            return writer;
        };

        /**
         * Encodes the specified AccountBindAck message, length delimited. Does not implicitly {@link CLPF.AccountBindAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {CLPF.IAccountBindAck} message AccountBindAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountBindAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountBindAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AccountBindAck} AccountBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountBindAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AccountBindAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.account = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountBindAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AccountBindAck} AccountBindAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountBindAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountBindAck message.
         * @function verify
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountBindAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            return null;
        };

        /**
         * Creates an AccountBindAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AccountBindAck} AccountBindAck
         */
        AccountBindAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AccountBindAck)
                return object;
            var message = new $root.CLPF.AccountBindAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.account != null)
                message.account = String(object.account);
            return message;
        };

        /**
         * Creates a plain object from an AccountBindAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AccountBindAck
         * @static
         * @param {CLPF.AccountBindAck} message AccountBindAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountBindAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.account = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            return object;
        };

        /**
         * Converts this AccountBindAck to JSON.
         * @function toJSON
         * @memberof CLPF.AccountBindAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountBindAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountBindAck;
    })();

    CLPF.PlayerNicknameQueryReq = (function() {

        /**
         * Properties of a PlayerNicknameQueryReq.
         * @memberof CLPF
         * @interface IPlayerNicknameQueryReq
         * @property {number|null} [userId] PlayerNicknameQueryReq userId
         */

        /**
         * Constructs a new PlayerNicknameQueryReq.
         * @memberof CLPF
         * @classdesc Represents a PlayerNicknameQueryReq.
         * @implements IPlayerNicknameQueryReq
         * @constructor
         * @param {CLPF.IPlayerNicknameQueryReq=} [properties] Properties to set
         */
        function PlayerNicknameQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerNicknameQueryReq userId.
         * @member {number} userId
         * @memberof CLPF.PlayerNicknameQueryReq
         * @instance
         */
        PlayerNicknameQueryReq.prototype.userId = 0;

        /**
         * Creates a new PlayerNicknameQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {CLPF.IPlayerNicknameQueryReq=} [properties] Properties to set
         * @returns {CLPF.PlayerNicknameQueryReq} PlayerNicknameQueryReq instance
         */
        PlayerNicknameQueryReq.create = function create(properties) {
            return new PlayerNicknameQueryReq(properties);
        };

        /**
         * Encodes the specified PlayerNicknameQueryReq message. Does not implicitly {@link CLPF.PlayerNicknameQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {CLPF.IPlayerNicknameQueryReq} message PlayerNicknameQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerNicknameQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            return writer;
        };

        /**
         * Encodes the specified PlayerNicknameQueryReq message, length delimited. Does not implicitly {@link CLPF.PlayerNicknameQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {CLPF.IPlayerNicknameQueryReq} message PlayerNicknameQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerNicknameQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerNicknameQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.PlayerNicknameQueryReq} PlayerNicknameQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerNicknameQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.PlayerNicknameQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerNicknameQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.PlayerNicknameQueryReq} PlayerNicknameQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerNicknameQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerNicknameQueryReq message.
         * @function verify
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerNicknameQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            return null;
        };

        /**
         * Creates a PlayerNicknameQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.PlayerNicknameQueryReq} PlayerNicknameQueryReq
         */
        PlayerNicknameQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.PlayerNicknameQueryReq)
                return object;
            var message = new $root.CLPF.PlayerNicknameQueryReq();
            if (object.userId != null)
                message.userId = object.userId | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayerNicknameQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.PlayerNicknameQueryReq
         * @static
         * @param {CLPF.PlayerNicknameQueryReq} message PlayerNicknameQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerNicknameQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.userId = 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this PlayerNicknameQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.PlayerNicknameQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerNicknameQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerNicknameQueryReq;
    })();

    CLPF.PlayerNicknameQueryAck = (function() {

        /**
         * Properties of a PlayerNicknameQueryAck.
         * @memberof CLPF
         * @interface IPlayerNicknameQueryAck
         * @property {number|null} [errcode] PlayerNicknameQueryAck errcode
         * @property {string|null} [nickname] PlayerNicknameQueryAck nickname
         */

        /**
         * Constructs a new PlayerNicknameQueryAck.
         * @memberof CLPF
         * @classdesc Represents a PlayerNicknameQueryAck.
         * @implements IPlayerNicknameQueryAck
         * @constructor
         * @param {CLPF.IPlayerNicknameQueryAck=} [properties] Properties to set
         */
        function PlayerNicknameQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerNicknameQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.PlayerNicknameQueryAck
         * @instance
         */
        PlayerNicknameQueryAck.prototype.errcode = 0;

        /**
         * PlayerNicknameQueryAck nickname.
         * @member {string} nickname
         * @memberof CLPF.PlayerNicknameQueryAck
         * @instance
         */
        PlayerNicknameQueryAck.prototype.nickname = "";

        /**
         * Creates a new PlayerNicknameQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {CLPF.IPlayerNicknameQueryAck=} [properties] Properties to set
         * @returns {CLPF.PlayerNicknameQueryAck} PlayerNicknameQueryAck instance
         */
        PlayerNicknameQueryAck.create = function create(properties) {
            return new PlayerNicknameQueryAck(properties);
        };

        /**
         * Encodes the specified PlayerNicknameQueryAck message. Does not implicitly {@link CLPF.PlayerNicknameQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {CLPF.IPlayerNicknameQueryAck} message PlayerNicknameQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerNicknameQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            return writer;
        };

        /**
         * Encodes the specified PlayerNicknameQueryAck message, length delimited. Does not implicitly {@link CLPF.PlayerNicknameQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {CLPF.IPlayerNicknameQueryAck} message PlayerNicknameQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerNicknameQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerNicknameQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.PlayerNicknameQueryAck} PlayerNicknameQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerNicknameQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.PlayerNicknameQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerNicknameQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.PlayerNicknameQueryAck} PlayerNicknameQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerNicknameQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerNicknameQueryAck message.
         * @function verify
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerNicknameQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            return null;
        };

        /**
         * Creates a PlayerNicknameQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.PlayerNicknameQueryAck} PlayerNicknameQueryAck
         */
        PlayerNicknameQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.PlayerNicknameQueryAck)
                return object;
            var message = new $root.CLPF.PlayerNicknameQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            return message;
        };

        /**
         * Creates a plain object from a PlayerNicknameQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.PlayerNicknameQueryAck
         * @static
         * @param {CLPF.PlayerNicknameQueryAck} message PlayerNicknameQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerNicknameQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.nickname = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            return object;
        };

        /**
         * Converts this PlayerNicknameQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.PlayerNicknameQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerNicknameQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerNicknameQueryAck;
    })();

    CLPF.BankPasswordInitReq = (function() {

        /**
         * Properties of a BankPasswordInitReq.
         * @memberof CLPF
         * @interface IBankPasswordInitReq
         * @property {string|null} [password] BankPasswordInitReq password
         */

        /**
         * Constructs a new BankPasswordInitReq.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordInitReq.
         * @implements IBankPasswordInitReq
         * @constructor
         * @param {CLPF.IBankPasswordInitReq=} [properties] Properties to set
         */
        function BankPasswordInitReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordInitReq password.
         * @member {string} password
         * @memberof CLPF.BankPasswordInitReq
         * @instance
         */
        BankPasswordInitReq.prototype.password = "";

        /**
         * Creates a new BankPasswordInitReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {CLPF.IBankPasswordInitReq=} [properties] Properties to set
         * @returns {CLPF.BankPasswordInitReq} BankPasswordInitReq instance
         */
        BankPasswordInitReq.create = function create(properties) {
            return new BankPasswordInitReq(properties);
        };

        /**
         * Encodes the specified BankPasswordInitReq message. Does not implicitly {@link CLPF.BankPasswordInitReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {CLPF.IBankPasswordInitReq} message BankPasswordInitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordInitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordInitReq message, length delimited. Does not implicitly {@link CLPF.BankPasswordInitReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {CLPF.IBankPasswordInitReq} message BankPasswordInitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordInitReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordInitReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordInitReq} BankPasswordInitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordInitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordInitReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordInitReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordInitReq} BankPasswordInitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordInitReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordInitReq message.
         * @function verify
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordInitReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a BankPasswordInitReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordInitReq} BankPasswordInitReq
         */
        BankPasswordInitReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordInitReq)
                return object;
            var message = new $root.CLPF.BankPasswordInitReq();
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordInitReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordInitReq
         * @static
         * @param {CLPF.BankPasswordInitReq} message BankPasswordInitReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordInitReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.password = "";
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this BankPasswordInitReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordInitReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordInitReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordInitReq;
    })();

    CLPF.BankPasswordInitAck = (function() {

        /**
         * Properties of a BankPasswordInitAck.
         * @memberof CLPF
         * @interface IBankPasswordInitAck
         * @property {number|null} [errcode] BankPasswordInitAck errcode
         */

        /**
         * Constructs a new BankPasswordInitAck.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordInitAck.
         * @implements IBankPasswordInitAck
         * @constructor
         * @param {CLPF.IBankPasswordInitAck=} [properties] Properties to set
         */
        function BankPasswordInitAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordInitAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankPasswordInitAck
         * @instance
         */
        BankPasswordInitAck.prototype.errcode = 0;

        /**
         * Creates a new BankPasswordInitAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {CLPF.IBankPasswordInitAck=} [properties] Properties to set
         * @returns {CLPF.BankPasswordInitAck} BankPasswordInitAck instance
         */
        BankPasswordInitAck.create = function create(properties) {
            return new BankPasswordInitAck(properties);
        };

        /**
         * Encodes the specified BankPasswordInitAck message. Does not implicitly {@link CLPF.BankPasswordInitAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {CLPF.IBankPasswordInitAck} message BankPasswordInitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordInitAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordInitAck message, length delimited. Does not implicitly {@link CLPF.BankPasswordInitAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {CLPF.IBankPasswordInitAck} message BankPasswordInitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordInitAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordInitAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordInitAck} BankPasswordInitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordInitAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordInitAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordInitAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordInitAck} BankPasswordInitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordInitAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordInitAck message.
         * @function verify
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordInitAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a BankPasswordInitAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordInitAck} BankPasswordInitAck
         */
        BankPasswordInitAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordInitAck)
                return object;
            var message = new $root.CLPF.BankPasswordInitAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordInitAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordInitAck
         * @static
         * @param {CLPF.BankPasswordInitAck} message BankPasswordInitAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordInitAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this BankPasswordInitAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordInitAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordInitAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordInitAck;
    })();

    CLPF.BankPasswordVerifyReq = (function() {

        /**
         * Properties of a BankPasswordVerifyReq.
         * @memberof CLPF
         * @interface IBankPasswordVerifyReq
         * @property {string|null} [password] BankPasswordVerifyReq password
         */

        /**
         * Constructs a new BankPasswordVerifyReq.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordVerifyReq.
         * @implements IBankPasswordVerifyReq
         * @constructor
         * @param {CLPF.IBankPasswordVerifyReq=} [properties] Properties to set
         */
        function BankPasswordVerifyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordVerifyReq password.
         * @member {string} password
         * @memberof CLPF.BankPasswordVerifyReq
         * @instance
         */
        BankPasswordVerifyReq.prototype.password = "";

        /**
         * Creates a new BankPasswordVerifyReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {CLPF.IBankPasswordVerifyReq=} [properties] Properties to set
         * @returns {CLPF.BankPasswordVerifyReq} BankPasswordVerifyReq instance
         */
        BankPasswordVerifyReq.create = function create(properties) {
            return new BankPasswordVerifyReq(properties);
        };

        /**
         * Encodes the specified BankPasswordVerifyReq message. Does not implicitly {@link CLPF.BankPasswordVerifyReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {CLPF.IBankPasswordVerifyReq} message BankPasswordVerifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordVerifyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordVerifyReq message, length delimited. Does not implicitly {@link CLPF.BankPasswordVerifyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {CLPF.IBankPasswordVerifyReq} message BankPasswordVerifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordVerifyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordVerifyReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordVerifyReq} BankPasswordVerifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordVerifyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordVerifyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordVerifyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordVerifyReq} BankPasswordVerifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordVerifyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordVerifyReq message.
         * @function verify
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordVerifyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a BankPasswordVerifyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordVerifyReq} BankPasswordVerifyReq
         */
        BankPasswordVerifyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordVerifyReq)
                return object;
            var message = new $root.CLPF.BankPasswordVerifyReq();
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordVerifyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordVerifyReq
         * @static
         * @param {CLPF.BankPasswordVerifyReq} message BankPasswordVerifyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordVerifyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.password = "";
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this BankPasswordVerifyReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordVerifyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordVerifyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordVerifyReq;
    })();

    CLPF.BankPasswordVerifyAck = (function() {

        /**
         * Properties of a BankPasswordVerifyAck.
         * @memberof CLPF
         * @interface IBankPasswordVerifyAck
         * @property {number|null} [errcode] BankPasswordVerifyAck errcode
         */

        /**
         * Constructs a new BankPasswordVerifyAck.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordVerifyAck.
         * @implements IBankPasswordVerifyAck
         * @constructor
         * @param {CLPF.IBankPasswordVerifyAck=} [properties] Properties to set
         */
        function BankPasswordVerifyAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordVerifyAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankPasswordVerifyAck
         * @instance
         */
        BankPasswordVerifyAck.prototype.errcode = 0;

        /**
         * Creates a new BankPasswordVerifyAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {CLPF.IBankPasswordVerifyAck=} [properties] Properties to set
         * @returns {CLPF.BankPasswordVerifyAck} BankPasswordVerifyAck instance
         */
        BankPasswordVerifyAck.create = function create(properties) {
            return new BankPasswordVerifyAck(properties);
        };

        /**
         * Encodes the specified BankPasswordVerifyAck message. Does not implicitly {@link CLPF.BankPasswordVerifyAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {CLPF.IBankPasswordVerifyAck} message BankPasswordVerifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordVerifyAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordVerifyAck message, length delimited. Does not implicitly {@link CLPF.BankPasswordVerifyAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {CLPF.IBankPasswordVerifyAck} message BankPasswordVerifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordVerifyAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordVerifyAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordVerifyAck} BankPasswordVerifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordVerifyAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordVerifyAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordVerifyAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordVerifyAck} BankPasswordVerifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordVerifyAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordVerifyAck message.
         * @function verify
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordVerifyAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a BankPasswordVerifyAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordVerifyAck} BankPasswordVerifyAck
         */
        BankPasswordVerifyAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordVerifyAck)
                return object;
            var message = new $root.CLPF.BankPasswordVerifyAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordVerifyAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordVerifyAck
         * @static
         * @param {CLPF.BankPasswordVerifyAck} message BankPasswordVerifyAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordVerifyAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this BankPasswordVerifyAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordVerifyAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordVerifyAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordVerifyAck;
    })();

    CLPF.BankPasswordModifyReq = (function() {

        /**
         * Properties of a BankPasswordModifyReq.
         * @memberof CLPF
         * @interface IBankPasswordModifyReq
         * @property {string|null} [originPassword] BankPasswordModifyReq originPassword
         * @property {string|null} [newPassword] BankPasswordModifyReq newPassword
         */

        /**
         * Constructs a new BankPasswordModifyReq.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordModifyReq.
         * @implements IBankPasswordModifyReq
         * @constructor
         * @param {CLPF.IBankPasswordModifyReq=} [properties] Properties to set
         */
        function BankPasswordModifyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordModifyReq originPassword.
         * @member {string} originPassword
         * @memberof CLPF.BankPasswordModifyReq
         * @instance
         */
        BankPasswordModifyReq.prototype.originPassword = "";

        /**
         * BankPasswordModifyReq newPassword.
         * @member {string} newPassword
         * @memberof CLPF.BankPasswordModifyReq
         * @instance
         */
        BankPasswordModifyReq.prototype.newPassword = "";

        /**
         * Creates a new BankPasswordModifyReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {CLPF.IBankPasswordModifyReq=} [properties] Properties to set
         * @returns {CLPF.BankPasswordModifyReq} BankPasswordModifyReq instance
         */
        BankPasswordModifyReq.create = function create(properties) {
            return new BankPasswordModifyReq(properties);
        };

        /**
         * Encodes the specified BankPasswordModifyReq message. Does not implicitly {@link CLPF.BankPasswordModifyReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {CLPF.IBankPasswordModifyReq} message BankPasswordModifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordModifyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originPassword != null && Object.hasOwnProperty.call(message, "originPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.originPassword);
            if (message.newPassword != null && Object.hasOwnProperty.call(message, "newPassword"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newPassword);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordModifyReq message, length delimited. Does not implicitly {@link CLPF.BankPasswordModifyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {CLPF.IBankPasswordModifyReq} message BankPasswordModifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordModifyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordModifyReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordModifyReq} BankPasswordModifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordModifyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordModifyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.originPassword = reader.string();
                    break;
                case 2:
                    message.newPassword = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordModifyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordModifyReq} BankPasswordModifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordModifyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordModifyReq message.
         * @function verify
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordModifyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originPassword != null && message.hasOwnProperty("originPassword"))
                if (!$util.isString(message.originPassword))
                    return "originPassword: string expected";
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                if (!$util.isString(message.newPassword))
                    return "newPassword: string expected";
            return null;
        };

        /**
         * Creates a BankPasswordModifyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordModifyReq} BankPasswordModifyReq
         */
        BankPasswordModifyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordModifyReq)
                return object;
            var message = new $root.CLPF.BankPasswordModifyReq();
            if (object.originPassword != null)
                message.originPassword = String(object.originPassword);
            if (object.newPassword != null)
                message.newPassword = String(object.newPassword);
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordModifyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordModifyReq
         * @static
         * @param {CLPF.BankPasswordModifyReq} message BankPasswordModifyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordModifyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.originPassword = "";
                object.newPassword = "";
            }
            if (message.originPassword != null && message.hasOwnProperty("originPassword"))
                object.originPassword = message.originPassword;
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                object.newPassword = message.newPassword;
            return object;
        };

        /**
         * Converts this BankPasswordModifyReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordModifyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordModifyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordModifyReq;
    })();

    CLPF.BankPasswordModifyAck = (function() {

        /**
         * Properties of a BankPasswordModifyAck.
         * @memberof CLPF
         * @interface IBankPasswordModifyAck
         * @property {number|null} [errcode] BankPasswordModifyAck errcode
         */

        /**
         * Constructs a new BankPasswordModifyAck.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordModifyAck.
         * @implements IBankPasswordModifyAck
         * @constructor
         * @param {CLPF.IBankPasswordModifyAck=} [properties] Properties to set
         */
        function BankPasswordModifyAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordModifyAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankPasswordModifyAck
         * @instance
         */
        BankPasswordModifyAck.prototype.errcode = 0;

        /**
         * Creates a new BankPasswordModifyAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {CLPF.IBankPasswordModifyAck=} [properties] Properties to set
         * @returns {CLPF.BankPasswordModifyAck} BankPasswordModifyAck instance
         */
        BankPasswordModifyAck.create = function create(properties) {
            return new BankPasswordModifyAck(properties);
        };

        /**
         * Encodes the specified BankPasswordModifyAck message. Does not implicitly {@link CLPF.BankPasswordModifyAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {CLPF.IBankPasswordModifyAck} message BankPasswordModifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordModifyAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordModifyAck message, length delimited. Does not implicitly {@link CLPF.BankPasswordModifyAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {CLPF.IBankPasswordModifyAck} message BankPasswordModifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordModifyAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordModifyAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordModifyAck} BankPasswordModifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordModifyAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordModifyAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordModifyAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordModifyAck} BankPasswordModifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordModifyAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordModifyAck message.
         * @function verify
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordModifyAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a BankPasswordModifyAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordModifyAck} BankPasswordModifyAck
         */
        BankPasswordModifyAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordModifyAck)
                return object;
            var message = new $root.CLPF.BankPasswordModifyAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordModifyAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordModifyAck
         * @static
         * @param {CLPF.BankPasswordModifyAck} message BankPasswordModifyAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordModifyAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this BankPasswordModifyAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordModifyAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordModifyAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordModifyAck;
    })();

    CLPF.BankPasswordResetReq = (function() {

        /**
         * Properties of a BankPasswordResetReq.
         * @memberof CLPF
         * @interface IBankPasswordResetReq
         * @property {string|null} [phone] BankPasswordResetReq phone
         * @property {string|null} [smsAppKey] BankPasswordResetReq smsAppKey
         * @property {string|null} [smsZone] BankPasswordResetReq smsZone
         * @property {string|null} [smsCode] BankPasswordResetReq smsCode
         * @property {string|null} [newPassword] BankPasswordResetReq newPassword
         * @property {number|null} [smsChannel] BankPasswordResetReq smsChannel
         */

        /**
         * Constructs a new BankPasswordResetReq.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordResetReq.
         * @implements IBankPasswordResetReq
         * @constructor
         * @param {CLPF.IBankPasswordResetReq=} [properties] Properties to set
         */
        function BankPasswordResetReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordResetReq phone.
         * @member {string} phone
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.phone = "";

        /**
         * BankPasswordResetReq smsAppKey.
         * @member {string} smsAppKey
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.smsAppKey = "";

        /**
         * BankPasswordResetReq smsZone.
         * @member {string} smsZone
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.smsZone = "";

        /**
         * BankPasswordResetReq smsCode.
         * @member {string} smsCode
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.smsCode = "";

        /**
         * BankPasswordResetReq newPassword.
         * @member {string} newPassword
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.newPassword = "";

        /**
         * BankPasswordResetReq smsChannel.
         * @member {number} smsChannel
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         */
        BankPasswordResetReq.prototype.smsChannel = 0;

        /**
         * Creates a new BankPasswordResetReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {CLPF.IBankPasswordResetReq=} [properties] Properties to set
         * @returns {CLPF.BankPasswordResetReq} BankPasswordResetReq instance
         */
        BankPasswordResetReq.create = function create(properties) {
            return new BankPasswordResetReq(properties);
        };

        /**
         * Encodes the specified BankPasswordResetReq message. Does not implicitly {@link CLPF.BankPasswordResetReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {CLPF.IBankPasswordResetReq} message BankPasswordResetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordResetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.smsAppKey != null && Object.hasOwnProperty.call(message, "smsAppKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.smsAppKey);
            if (message.smsZone != null && Object.hasOwnProperty.call(message, "smsZone"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.smsZone);
            if (message.smsCode != null && Object.hasOwnProperty.call(message, "smsCode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.smsCode);
            if (message.newPassword != null && Object.hasOwnProperty.call(message, "newPassword"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.newPassword);
            if (message.smsChannel != null && Object.hasOwnProperty.call(message, "smsChannel"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.smsChannel);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordResetReq message, length delimited. Does not implicitly {@link CLPF.BankPasswordResetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {CLPF.IBankPasswordResetReq} message BankPasswordResetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordResetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordResetReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordResetReq} BankPasswordResetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordResetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordResetReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.smsAppKey = reader.string();
                    break;
                case 3:
                    message.smsZone = reader.string();
                    break;
                case 4:
                    message.smsCode = reader.string();
                    break;
                case 5:
                    message.newPassword = reader.string();
                    break;
                case 6:
                    message.smsChannel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordResetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordResetReq} BankPasswordResetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordResetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordResetReq message.
         * @function verify
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordResetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.smsAppKey != null && message.hasOwnProperty("smsAppKey"))
                if (!$util.isString(message.smsAppKey))
                    return "smsAppKey: string expected";
            if (message.smsZone != null && message.hasOwnProperty("smsZone"))
                if (!$util.isString(message.smsZone))
                    return "smsZone: string expected";
            if (message.smsCode != null && message.hasOwnProperty("smsCode"))
                if (!$util.isString(message.smsCode))
                    return "smsCode: string expected";
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                if (!$util.isString(message.newPassword))
                    return "newPassword: string expected";
            if (message.smsChannel != null && message.hasOwnProperty("smsChannel"))
                if (!$util.isInteger(message.smsChannel))
                    return "smsChannel: integer expected";
            return null;
        };

        /**
         * Creates a BankPasswordResetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordResetReq} BankPasswordResetReq
         */
        BankPasswordResetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordResetReq)
                return object;
            var message = new $root.CLPF.BankPasswordResetReq();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.smsAppKey != null)
                message.smsAppKey = String(object.smsAppKey);
            if (object.smsZone != null)
                message.smsZone = String(object.smsZone);
            if (object.smsCode != null)
                message.smsCode = String(object.smsCode);
            if (object.newPassword != null)
                message.newPassword = String(object.newPassword);
            if (object.smsChannel != null)
                message.smsChannel = object.smsChannel | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordResetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordResetReq
         * @static
         * @param {CLPF.BankPasswordResetReq} message BankPasswordResetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordResetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.smsAppKey = "";
                object.smsZone = "";
                object.smsCode = "";
                object.newPassword = "";
                object.smsChannel = 0;
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.smsAppKey != null && message.hasOwnProperty("smsAppKey"))
                object.smsAppKey = message.smsAppKey;
            if (message.smsZone != null && message.hasOwnProperty("smsZone"))
                object.smsZone = message.smsZone;
            if (message.smsCode != null && message.hasOwnProperty("smsCode"))
                object.smsCode = message.smsCode;
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                object.newPassword = message.newPassword;
            if (message.smsChannel != null && message.hasOwnProperty("smsChannel"))
                object.smsChannel = message.smsChannel;
            return object;
        };

        /**
         * Converts this BankPasswordResetReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordResetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordResetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordResetReq;
    })();

    CLPF.BankPasswordResetAck = (function() {

        /**
         * Properties of a BankPasswordResetAck.
         * @memberof CLPF
         * @interface IBankPasswordResetAck
         * @property {number|null} [errcode] BankPasswordResetAck errcode
         */

        /**
         * Constructs a new BankPasswordResetAck.
         * @memberof CLPF
         * @classdesc Represents a BankPasswordResetAck.
         * @implements IBankPasswordResetAck
         * @constructor
         * @param {CLPF.IBankPasswordResetAck=} [properties] Properties to set
         */
        function BankPasswordResetAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankPasswordResetAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankPasswordResetAck
         * @instance
         */
        BankPasswordResetAck.prototype.errcode = 0;

        /**
         * Creates a new BankPasswordResetAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {CLPF.IBankPasswordResetAck=} [properties] Properties to set
         * @returns {CLPF.BankPasswordResetAck} BankPasswordResetAck instance
         */
        BankPasswordResetAck.create = function create(properties) {
            return new BankPasswordResetAck(properties);
        };

        /**
         * Encodes the specified BankPasswordResetAck message. Does not implicitly {@link CLPF.BankPasswordResetAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {CLPF.IBankPasswordResetAck} message BankPasswordResetAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordResetAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified BankPasswordResetAck message, length delimited. Does not implicitly {@link CLPF.BankPasswordResetAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {CLPF.IBankPasswordResetAck} message BankPasswordResetAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankPasswordResetAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankPasswordResetAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankPasswordResetAck} BankPasswordResetAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordResetAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankPasswordResetAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankPasswordResetAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankPasswordResetAck} BankPasswordResetAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankPasswordResetAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankPasswordResetAck message.
         * @function verify
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankPasswordResetAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a BankPasswordResetAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankPasswordResetAck} BankPasswordResetAck
         */
        BankPasswordResetAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankPasswordResetAck)
                return object;
            var message = new $root.CLPF.BankPasswordResetAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankPasswordResetAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankPasswordResetAck
         * @static
         * @param {CLPF.BankPasswordResetAck} message BankPasswordResetAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankPasswordResetAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this BankPasswordResetAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankPasswordResetAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankPasswordResetAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankPasswordResetAck;
    })();

    CLPF.BankItemQueryReq = (function() {

        /**
         * Properties of a BankItemQueryReq.
         * @memberof CLPF
         * @interface IBankItemQueryReq
         */

        /**
         * Constructs a new BankItemQueryReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemQueryReq.
         * @implements IBankItemQueryReq
         * @constructor
         * @param {CLPF.IBankItemQueryReq=} [properties] Properties to set
         */
        function BankItemQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BankItemQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {CLPF.IBankItemQueryReq=} [properties] Properties to set
         * @returns {CLPF.BankItemQueryReq} BankItemQueryReq instance
         */
        BankItemQueryReq.create = function create(properties) {
            return new BankItemQueryReq(properties);
        };

        /**
         * Encodes the specified BankItemQueryReq message. Does not implicitly {@link CLPF.BankItemQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {CLPF.IBankItemQueryReq} message BankItemQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BankItemQueryReq message, length delimited. Does not implicitly {@link CLPF.BankItemQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {CLPF.IBankItemQueryReq} message BankItemQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemQueryReq} BankItemQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemQueryReq} BankItemQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemQueryReq message.
         * @function verify
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a BankItemQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemQueryReq} BankItemQueryReq
         */
        BankItemQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemQueryReq)
                return object;
            return new $root.CLPF.BankItemQueryReq();
        };

        /**
         * Creates a plain object from a BankItemQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemQueryReq
         * @static
         * @param {CLPF.BankItemQueryReq} message BankItemQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BankItemQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemQueryReq;
    })();

    CLPF.BankItemQueryAck = (function() {

        /**
         * Properties of a BankItemQueryAck.
         * @memberof CLPF
         * @interface IBankItemQueryAck
         * @property {number|null} [errcode] BankItemQueryAck errcode
         * @property {Array.<CLPF.IItemInfo>|null} [items] BankItemQueryAck items
         */

        /**
         * Constructs a new BankItemQueryAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemQueryAck.
         * @implements IBankItemQueryAck
         * @constructor
         * @param {CLPF.IBankItemQueryAck=} [properties] Properties to set
         */
        function BankItemQueryAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemQueryAck
         * @instance
         */
        BankItemQueryAck.prototype.errcode = 0;

        /**
         * BankItemQueryAck items.
         * @member {Array.<CLPF.IItemInfo>} items
         * @memberof CLPF.BankItemQueryAck
         * @instance
         */
        BankItemQueryAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new BankItemQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {CLPF.IBankItemQueryAck=} [properties] Properties to set
         * @returns {CLPF.BankItemQueryAck} BankItemQueryAck instance
         */
        BankItemQueryAck.create = function create(properties) {
            return new BankItemQueryAck(properties);
        };

        /**
         * Encodes the specified BankItemQueryAck message. Does not implicitly {@link CLPF.BankItemQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {CLPF.IBankItemQueryAck} message BankItemQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.ItemInfo.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemQueryAck message, length delimited. Does not implicitly {@link CLPF.BankItemQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {CLPF.IBankItemQueryAck} message BankItemQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemQueryAck} BankItemQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemQueryAck} BankItemQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemQueryAck message.
         * @function verify
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BankItemQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemQueryAck} BankItemQueryAck
         */
        BankItemQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemQueryAck)
                return object;
            var message = new $root.CLPF.BankItemQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.BankItemQueryAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.BankItemQueryAck.items: object expected");
                    message.items[i] = $root.CLPF.ItemInfo.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemQueryAck
         * @static
         * @param {CLPF.BankItemQueryAck} message BankItemQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.ItemInfo.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this BankItemQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemQueryAck;
    })();

    CLPF.BankItemStoreReq = (function() {

        /**
         * Properties of a BankItemStoreReq.
         * @memberof CLPF
         * @interface IBankItemStoreReq
         * @property {CLPF.IItemInfo|null} [item] BankItemStoreReq item
         */

        /**
         * Constructs a new BankItemStoreReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemStoreReq.
         * @implements IBankItemStoreReq
         * @constructor
         * @param {CLPF.IBankItemStoreReq=} [properties] Properties to set
         */
        function BankItemStoreReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemStoreReq item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.BankItemStoreReq
         * @instance
         */
        BankItemStoreReq.prototype.item = null;

        /**
         * Creates a new BankItemStoreReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {CLPF.IBankItemStoreReq=} [properties] Properties to set
         * @returns {CLPF.BankItemStoreReq} BankItemStoreReq instance
         */
        BankItemStoreReq.create = function create(properties) {
            return new BankItemStoreReq(properties);
        };

        /**
         * Encodes the specified BankItemStoreReq message. Does not implicitly {@link CLPF.BankItemStoreReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {CLPF.IBankItemStoreReq} message BankItemStoreReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemStoreReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemStoreReq message, length delimited. Does not implicitly {@link CLPF.BankItemStoreReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {CLPF.IBankItemStoreReq} message BankItemStoreReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemStoreReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemStoreReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemStoreReq} BankItemStoreReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemStoreReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemStoreReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemStoreReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemStoreReq} BankItemStoreReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemStoreReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemStoreReq message.
         * @function verify
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemStoreReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a BankItemStoreReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemStoreReq} BankItemStoreReq
         */
        BankItemStoreReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemStoreReq)
                return object;
            var message = new $root.CLPF.BankItemStoreReq();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.BankItemStoreReq.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemStoreReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemStoreReq
         * @static
         * @param {CLPF.BankItemStoreReq} message BankItemStoreReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemStoreReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this BankItemStoreReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemStoreReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemStoreReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemStoreReq;
    })();

    CLPF.BankItemStoreAck = (function() {

        /**
         * Properties of a BankItemStoreAck.
         * @memberof CLPF
         * @interface IBankItemStoreAck
         * @property {number|null} [errcode] BankItemStoreAck errcode
         * @property {number|Long|null} [latestAmount] BankItemStoreAck latestAmount
         */

        /**
         * Constructs a new BankItemStoreAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemStoreAck.
         * @implements IBankItemStoreAck
         * @constructor
         * @param {CLPF.IBankItemStoreAck=} [properties] Properties to set
         */
        function BankItemStoreAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemStoreAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemStoreAck
         * @instance
         */
        BankItemStoreAck.prototype.errcode = 0;

        /**
         * BankItemStoreAck latestAmount.
         * @member {number|Long} latestAmount
         * @memberof CLPF.BankItemStoreAck
         * @instance
         */
        BankItemStoreAck.prototype.latestAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BankItemStoreAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {CLPF.IBankItemStoreAck=} [properties] Properties to set
         * @returns {CLPF.BankItemStoreAck} BankItemStoreAck instance
         */
        BankItemStoreAck.create = function create(properties) {
            return new BankItemStoreAck(properties);
        };

        /**
         * Encodes the specified BankItemStoreAck message. Does not implicitly {@link CLPF.BankItemStoreAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {CLPF.IBankItemStoreAck} message BankItemStoreAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemStoreAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.latestAmount != null && Object.hasOwnProperty.call(message, "latestAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.latestAmount);
            return writer;
        };

        /**
         * Encodes the specified BankItemStoreAck message, length delimited. Does not implicitly {@link CLPF.BankItemStoreAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {CLPF.IBankItemStoreAck} message BankItemStoreAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemStoreAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemStoreAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemStoreAck} BankItemStoreAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemStoreAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemStoreAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.latestAmount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemStoreAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemStoreAck} BankItemStoreAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemStoreAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemStoreAck message.
         * @function verify
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemStoreAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (!$util.isInteger(message.latestAmount) && !(message.latestAmount && $util.isInteger(message.latestAmount.low) && $util.isInteger(message.latestAmount.high)))
                    return "latestAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a BankItemStoreAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemStoreAck} BankItemStoreAck
         */
        BankItemStoreAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemStoreAck)
                return object;
            var message = new $root.CLPF.BankItemStoreAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.latestAmount != null)
                if ($util.Long)
                    (message.latestAmount = $util.Long.fromValue(object.latestAmount)).unsigned = false;
                else if (typeof object.latestAmount === "string")
                    message.latestAmount = parseInt(object.latestAmount, 10);
                else if (typeof object.latestAmount === "number")
                    message.latestAmount = object.latestAmount;
                else if (typeof object.latestAmount === "object")
                    message.latestAmount = new $util.LongBits(object.latestAmount.low >>> 0, object.latestAmount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BankItemStoreAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemStoreAck
         * @static
         * @param {CLPF.BankItemStoreAck} message BankItemStoreAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemStoreAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestAmount = options.longs === String ? "0" : 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (typeof message.latestAmount === "number")
                    object.latestAmount = options.longs === String ? String(message.latestAmount) : message.latestAmount;
                else
                    object.latestAmount = options.longs === String ? $util.Long.prototype.toString.call(message.latestAmount) : options.longs === Number ? new $util.LongBits(message.latestAmount.low >>> 0, message.latestAmount.high >>> 0).toNumber() : message.latestAmount;
            return object;
        };

        /**
         * Converts this BankItemStoreAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemStoreAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemStoreAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemStoreAck;
    })();

    CLPF.BankItemFetchReq = (function() {

        /**
         * Properties of a BankItemFetchReq.
         * @memberof CLPF
         * @interface IBankItemFetchReq
         * @property {CLPF.IItemInfo|null} [item] BankItemFetchReq item
         */

        /**
         * Constructs a new BankItemFetchReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemFetchReq.
         * @implements IBankItemFetchReq
         * @constructor
         * @param {CLPF.IBankItemFetchReq=} [properties] Properties to set
         */
        function BankItemFetchReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemFetchReq item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.BankItemFetchReq
         * @instance
         */
        BankItemFetchReq.prototype.item = null;

        /**
         * Creates a new BankItemFetchReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {CLPF.IBankItemFetchReq=} [properties] Properties to set
         * @returns {CLPF.BankItemFetchReq} BankItemFetchReq instance
         */
        BankItemFetchReq.create = function create(properties) {
            return new BankItemFetchReq(properties);
        };

        /**
         * Encodes the specified BankItemFetchReq message. Does not implicitly {@link CLPF.BankItemFetchReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {CLPF.IBankItemFetchReq} message BankItemFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemFetchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemFetchReq message, length delimited. Does not implicitly {@link CLPF.BankItemFetchReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {CLPF.IBankItemFetchReq} message BankItemFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemFetchReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemFetchReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemFetchReq} BankItemFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemFetchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemFetchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemFetchReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemFetchReq} BankItemFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemFetchReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemFetchReq message.
         * @function verify
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemFetchReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a BankItemFetchReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemFetchReq} BankItemFetchReq
         */
        BankItemFetchReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemFetchReq)
                return object;
            var message = new $root.CLPF.BankItemFetchReq();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.BankItemFetchReq.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemFetchReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemFetchReq
         * @static
         * @param {CLPF.BankItemFetchReq} message BankItemFetchReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemFetchReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this BankItemFetchReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemFetchReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemFetchReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemFetchReq;
    })();

    CLPF.BankItemFetchAck = (function() {

        /**
         * Properties of a BankItemFetchAck.
         * @memberof CLPF
         * @interface IBankItemFetchAck
         * @property {number|null} [errcode] BankItemFetchAck errcode
         * @property {number|Long|null} [latestAmount] BankItemFetchAck latestAmount
         */

        /**
         * Constructs a new BankItemFetchAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemFetchAck.
         * @implements IBankItemFetchAck
         * @constructor
         * @param {CLPF.IBankItemFetchAck=} [properties] Properties to set
         */
        function BankItemFetchAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemFetchAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemFetchAck
         * @instance
         */
        BankItemFetchAck.prototype.errcode = 0;

        /**
         * BankItemFetchAck latestAmount.
         * @member {number|Long} latestAmount
         * @memberof CLPF.BankItemFetchAck
         * @instance
         */
        BankItemFetchAck.prototype.latestAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BankItemFetchAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {CLPF.IBankItemFetchAck=} [properties] Properties to set
         * @returns {CLPF.BankItemFetchAck} BankItemFetchAck instance
         */
        BankItemFetchAck.create = function create(properties) {
            return new BankItemFetchAck(properties);
        };

        /**
         * Encodes the specified BankItemFetchAck message. Does not implicitly {@link CLPF.BankItemFetchAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {CLPF.IBankItemFetchAck} message BankItemFetchAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemFetchAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.latestAmount != null && Object.hasOwnProperty.call(message, "latestAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.latestAmount);
            return writer;
        };

        /**
         * Encodes the specified BankItemFetchAck message, length delimited. Does not implicitly {@link CLPF.BankItemFetchAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {CLPF.IBankItemFetchAck} message BankItemFetchAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemFetchAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemFetchAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemFetchAck} BankItemFetchAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemFetchAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemFetchAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.latestAmount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemFetchAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemFetchAck} BankItemFetchAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemFetchAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemFetchAck message.
         * @function verify
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemFetchAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (!$util.isInteger(message.latestAmount) && !(message.latestAmount && $util.isInteger(message.latestAmount.low) && $util.isInteger(message.latestAmount.high)))
                    return "latestAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a BankItemFetchAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemFetchAck} BankItemFetchAck
         */
        BankItemFetchAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemFetchAck)
                return object;
            var message = new $root.CLPF.BankItemFetchAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.latestAmount != null)
                if ($util.Long)
                    (message.latestAmount = $util.Long.fromValue(object.latestAmount)).unsigned = false;
                else if (typeof object.latestAmount === "string")
                    message.latestAmount = parseInt(object.latestAmount, 10);
                else if (typeof object.latestAmount === "number")
                    message.latestAmount = object.latestAmount;
                else if (typeof object.latestAmount === "object")
                    message.latestAmount = new $util.LongBits(object.latestAmount.low >>> 0, object.latestAmount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BankItemFetchAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemFetchAck
         * @static
         * @param {CLPF.BankItemFetchAck} message BankItemFetchAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemFetchAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestAmount = options.longs === String ? "0" : 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (typeof message.latestAmount === "number")
                    object.latestAmount = options.longs === String ? String(message.latestAmount) : message.latestAmount;
                else
                    object.latestAmount = options.longs === String ? $util.Long.prototype.toString.call(message.latestAmount) : options.longs === Number ? new $util.LongBits(message.latestAmount.low >>> 0, message.latestAmount.high >>> 0).toNumber() : message.latestAmount;
            return object;
        };

        /**
         * Converts this BankItemFetchAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemFetchAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemFetchAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemFetchAck;
    })();

    CLPF.BankItemSendReq = (function() {

        /**
         * Properties of a BankItemSendReq.
         * @memberof CLPF
         * @interface IBankItemSendReq
         * @property {number|null} [userId] BankItemSendReq userId
         * @property {CLPF.IItemInfo|null} [item] BankItemSendReq item
         */

        /**
         * Constructs a new BankItemSendReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemSendReq.
         * @implements IBankItemSendReq
         * @constructor
         * @param {CLPF.IBankItemSendReq=} [properties] Properties to set
         */
        function BankItemSendReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemSendReq userId.
         * @member {number} userId
         * @memberof CLPF.BankItemSendReq
         * @instance
         */
        BankItemSendReq.prototype.userId = 0;

        /**
         * BankItemSendReq item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.BankItemSendReq
         * @instance
         */
        BankItemSendReq.prototype.item = null;

        /**
         * Creates a new BankItemSendReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {CLPF.IBankItemSendReq=} [properties] Properties to set
         * @returns {CLPF.BankItemSendReq} BankItemSendReq instance
         */
        BankItemSendReq.create = function create(properties) {
            return new BankItemSendReq(properties);
        };

        /**
         * Encodes the specified BankItemSendReq message. Does not implicitly {@link CLPF.BankItemSendReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {CLPF.IBankItemSendReq} message BankItemSendReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemSendReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemSendReq message, length delimited. Does not implicitly {@link CLPF.BankItemSendReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {CLPF.IBankItemSendReq} message BankItemSendReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemSendReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemSendReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemSendReq} BankItemSendReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemSendReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemSendReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemSendReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemSendReq} BankItemSendReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemSendReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemSendReq message.
         * @function verify
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemSendReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a BankItemSendReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemSendReq} BankItemSendReq
         */
        BankItemSendReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemSendReq)
                return object;
            var message = new $root.CLPF.BankItemSendReq();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.BankItemSendReq.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemSendReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemSendReq
         * @static
         * @param {CLPF.BankItemSendReq} message BankItemSendReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemSendReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.userId = 0;
                object.item = null;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this BankItemSendReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemSendReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemSendReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemSendReq;
    })();

    CLPF.BankItemSendAck = (function() {

        /**
         * Properties of a BankItemSendAck.
         * @memberof CLPF
         * @interface IBankItemSendAck
         * @property {number|null} [errcode] BankItemSendAck errcode
         * @property {number|Long|null} [latestAmount] BankItemSendAck latestAmount
         */

        /**
         * Constructs a new BankItemSendAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemSendAck.
         * @implements IBankItemSendAck
         * @constructor
         * @param {CLPF.IBankItemSendAck=} [properties] Properties to set
         */
        function BankItemSendAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemSendAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemSendAck
         * @instance
         */
        BankItemSendAck.prototype.errcode = 0;

        /**
         * BankItemSendAck latestAmount.
         * @member {number|Long} latestAmount
         * @memberof CLPF.BankItemSendAck
         * @instance
         */
        BankItemSendAck.prototype.latestAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BankItemSendAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {CLPF.IBankItemSendAck=} [properties] Properties to set
         * @returns {CLPF.BankItemSendAck} BankItemSendAck instance
         */
        BankItemSendAck.create = function create(properties) {
            return new BankItemSendAck(properties);
        };

        /**
         * Encodes the specified BankItemSendAck message. Does not implicitly {@link CLPF.BankItemSendAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {CLPF.IBankItemSendAck} message BankItemSendAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemSendAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.latestAmount != null && Object.hasOwnProperty.call(message, "latestAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.latestAmount);
            return writer;
        };

        /**
         * Encodes the specified BankItemSendAck message, length delimited. Does not implicitly {@link CLPF.BankItemSendAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {CLPF.IBankItemSendAck} message BankItemSendAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemSendAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemSendAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemSendAck} BankItemSendAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemSendAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemSendAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.latestAmount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemSendAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemSendAck} BankItemSendAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemSendAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemSendAck message.
         * @function verify
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemSendAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (!$util.isInteger(message.latestAmount) && !(message.latestAmount && $util.isInteger(message.latestAmount.low) && $util.isInteger(message.latestAmount.high)))
                    return "latestAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a BankItemSendAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemSendAck} BankItemSendAck
         */
        BankItemSendAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemSendAck)
                return object;
            var message = new $root.CLPF.BankItemSendAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.latestAmount != null)
                if ($util.Long)
                    (message.latestAmount = $util.Long.fromValue(object.latestAmount)).unsigned = false;
                else if (typeof object.latestAmount === "string")
                    message.latestAmount = parseInt(object.latestAmount, 10);
                else if (typeof object.latestAmount === "number")
                    message.latestAmount = object.latestAmount;
                else if (typeof object.latestAmount === "object")
                    message.latestAmount = new $util.LongBits(object.latestAmount.low >>> 0, object.latestAmount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BankItemSendAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemSendAck
         * @static
         * @param {CLPF.BankItemSendAck} message BankItemSendAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemSendAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestAmount = options.longs === String ? "0" : 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (typeof message.latestAmount === "number")
                    object.latestAmount = options.longs === String ? String(message.latestAmount) : message.latestAmount;
                else
                    object.latestAmount = options.longs === String ? $util.Long.prototype.toString.call(message.latestAmount) : options.longs === Number ? new $util.LongBits(message.latestAmount.low >>> 0, message.latestAmount.high >>> 0).toNumber() : message.latestAmount;
            return object;
        };

        /**
         * Converts this BankItemSendAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemSendAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemSendAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemSendAck;
    })();

    CLPF.BankItemLogInfo = (function() {

        /**
         * Properties of a BankItemLogInfo.
         * @memberof CLPF
         * @interface IBankItemLogInfo
         * @property {number|null} [logType] BankItemLogInfo logType
         * @property {CLPF.IItemInfo|null} [item] BankItemLogInfo item
         * @property {number|null} [referUserId] BankItemLogInfo referUserId
         * @property {string|null} [referNickname] BankItemLogInfo referNickname
         * @property {number|null} [timestamp] BankItemLogInfo timestamp
         * @property {number|null} [uniqueId] BankItemLogInfo uniqueId
         * @property {number|Long|null} [originalAmount] BankItemLogInfo originalAmount
         * @property {number|Long|null} [latestAmount] BankItemLogInfo latestAmount
         */

        /**
         * Constructs a new BankItemLogInfo.
         * @memberof CLPF
         * @classdesc Represents a BankItemLogInfo.
         * @implements IBankItemLogInfo
         * @constructor
         * @param {CLPF.IBankItemLogInfo=} [properties] Properties to set
         */
        function BankItemLogInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemLogInfo logType.
         * @member {number} logType
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.logType = 0;

        /**
         * BankItemLogInfo item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.item = null;

        /**
         * BankItemLogInfo referUserId.
         * @member {number} referUserId
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.referUserId = 0;

        /**
         * BankItemLogInfo referNickname.
         * @member {string} referNickname
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.referNickname = "";

        /**
         * BankItemLogInfo timestamp.
         * @member {number} timestamp
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.timestamp = 0;

        /**
         * BankItemLogInfo uniqueId.
         * @member {number} uniqueId
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.uniqueId = 0;

        /**
         * BankItemLogInfo originalAmount.
         * @member {number|Long} originalAmount
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.originalAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BankItemLogInfo latestAmount.
         * @member {number|Long} latestAmount
         * @memberof CLPF.BankItemLogInfo
         * @instance
         */
        BankItemLogInfo.prototype.latestAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BankItemLogInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {CLPF.IBankItemLogInfo=} [properties] Properties to set
         * @returns {CLPF.BankItemLogInfo} BankItemLogInfo instance
         */
        BankItemLogInfo.create = function create(properties) {
            return new BankItemLogInfo(properties);
        };

        /**
         * Encodes the specified BankItemLogInfo message. Does not implicitly {@link CLPF.BankItemLogInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {CLPF.IBankItemLogInfo} message BankItemLogInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logType != null && Object.hasOwnProperty.call(message, "logType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logType);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.referUserId != null && Object.hasOwnProperty.call(message, "referUserId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.referUserId);
            if (message.referNickname != null && Object.hasOwnProperty.call(message, "referNickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.referNickname);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.timestamp);
            if (message.uniqueId != null && Object.hasOwnProperty.call(message, "uniqueId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.uniqueId);
            if (message.originalAmount != null && Object.hasOwnProperty.call(message, "originalAmount"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.originalAmount);
            if (message.latestAmount != null && Object.hasOwnProperty.call(message, "latestAmount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.latestAmount);
            return writer;
        };

        /**
         * Encodes the specified BankItemLogInfo message, length delimited. Does not implicitly {@link CLPF.BankItemLogInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {CLPF.IBankItemLogInfo} message BankItemLogInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemLogInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemLogInfo} BankItemLogInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemLogInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logType = reader.int32();
                    break;
                case 2:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.referUserId = reader.int32();
                    break;
                case 4:
                    message.referNickname = reader.string();
                    break;
                case 5:
                    message.timestamp = reader.fixed32();
                    break;
                case 6:
                    message.uniqueId = reader.int32();
                    break;
                case 7:
                    message.originalAmount = reader.int64();
                    break;
                case 8:
                    message.latestAmount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemLogInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemLogInfo} BankItemLogInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemLogInfo message.
         * @function verify
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemLogInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logType != null && message.hasOwnProperty("logType"))
                if (!$util.isInteger(message.logType))
                    return "logType: integer expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.referUserId != null && message.hasOwnProperty("referUserId"))
                if (!$util.isInteger(message.referUserId))
                    return "referUserId: integer expected";
            if (message.referNickname != null && message.hasOwnProperty("referNickname"))
                if (!$util.isString(message.referNickname))
                    return "referNickname: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                if (!$util.isInteger(message.uniqueId))
                    return "uniqueId: integer expected";
            if (message.originalAmount != null && message.hasOwnProperty("originalAmount"))
                if (!$util.isInteger(message.originalAmount) && !(message.originalAmount && $util.isInteger(message.originalAmount.low) && $util.isInteger(message.originalAmount.high)))
                    return "originalAmount: integer|Long expected";
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (!$util.isInteger(message.latestAmount) && !(message.latestAmount && $util.isInteger(message.latestAmount.low) && $util.isInteger(message.latestAmount.high)))
                    return "latestAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a BankItemLogInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemLogInfo} BankItemLogInfo
         */
        BankItemLogInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemLogInfo)
                return object;
            var message = new $root.CLPF.BankItemLogInfo();
            if (object.logType != null)
                message.logType = object.logType | 0;
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.BankItemLogInfo.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            if (object.referUserId != null)
                message.referUserId = object.referUserId | 0;
            if (object.referNickname != null)
                message.referNickname = String(object.referNickname);
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.uniqueId != null)
                message.uniqueId = object.uniqueId | 0;
            if (object.originalAmount != null)
                if ($util.Long)
                    (message.originalAmount = $util.Long.fromValue(object.originalAmount)).unsigned = false;
                else if (typeof object.originalAmount === "string")
                    message.originalAmount = parseInt(object.originalAmount, 10);
                else if (typeof object.originalAmount === "number")
                    message.originalAmount = object.originalAmount;
                else if (typeof object.originalAmount === "object")
                    message.originalAmount = new $util.LongBits(object.originalAmount.low >>> 0, object.originalAmount.high >>> 0).toNumber();
            if (object.latestAmount != null)
                if ($util.Long)
                    (message.latestAmount = $util.Long.fromValue(object.latestAmount)).unsigned = false;
                else if (typeof object.latestAmount === "string")
                    message.latestAmount = parseInt(object.latestAmount, 10);
                else if (typeof object.latestAmount === "number")
                    message.latestAmount = object.latestAmount;
                else if (typeof object.latestAmount === "object")
                    message.latestAmount = new $util.LongBits(object.latestAmount.low >>> 0, object.latestAmount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BankItemLogInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemLogInfo
         * @static
         * @param {CLPF.BankItemLogInfo} message BankItemLogInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemLogInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logType = 0;
                object.item = null;
                object.referUserId = 0;
                object.referNickname = "";
                object.timestamp = 0;
                object.uniqueId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originalAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.originalAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestAmount = options.longs === String ? "0" : 0;
            }
            if (message.logType != null && message.hasOwnProperty("logType"))
                object.logType = message.logType;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            if (message.referUserId != null && message.hasOwnProperty("referUserId"))
                object.referUserId = message.referUserId;
            if (message.referNickname != null && message.hasOwnProperty("referNickname"))
                object.referNickname = message.referNickname;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                object.uniqueId = message.uniqueId;
            if (message.originalAmount != null && message.hasOwnProperty("originalAmount"))
                if (typeof message.originalAmount === "number")
                    object.originalAmount = options.longs === String ? String(message.originalAmount) : message.originalAmount;
                else
                    object.originalAmount = options.longs === String ? $util.Long.prototype.toString.call(message.originalAmount) : options.longs === Number ? new $util.LongBits(message.originalAmount.low >>> 0, message.originalAmount.high >>> 0).toNumber() : message.originalAmount;
            if (message.latestAmount != null && message.hasOwnProperty("latestAmount"))
                if (typeof message.latestAmount === "number")
                    object.latestAmount = options.longs === String ? String(message.latestAmount) : message.latestAmount;
                else
                    object.latestAmount = options.longs === String ? $util.Long.prototype.toString.call(message.latestAmount) : options.longs === Number ? new $util.LongBits(message.latestAmount.low >>> 0, message.latestAmount.high >>> 0).toNumber() : message.latestAmount;
            return object;
        };

        /**
         * Converts this BankItemLogInfo to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemLogInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemLogInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemLogInfo;
    })();

    CLPF.BankItemLogQueryReq = (function() {

        /**
         * Properties of a BankItemLogQueryReq.
         * @memberof CLPF
         * @interface IBankItemLogQueryReq
         * @property {number|null} [startTimestamp] BankItemLogQueryReq startTimestamp
         * @property {number|null} [endTimestamp] BankItemLogQueryReq endTimestamp
         */

        /**
         * Constructs a new BankItemLogQueryReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemLogQueryReq.
         * @implements IBankItemLogQueryReq
         * @constructor
         * @param {CLPF.IBankItemLogQueryReq=} [properties] Properties to set
         */
        function BankItemLogQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemLogQueryReq startTimestamp.
         * @member {number} startTimestamp
         * @memberof CLPF.BankItemLogQueryReq
         * @instance
         */
        BankItemLogQueryReq.prototype.startTimestamp = 0;

        /**
         * BankItemLogQueryReq endTimestamp.
         * @member {number} endTimestamp
         * @memberof CLPF.BankItemLogQueryReq
         * @instance
         */
        BankItemLogQueryReq.prototype.endTimestamp = 0;

        /**
         * Creates a new BankItemLogQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {CLPF.IBankItemLogQueryReq=} [properties] Properties to set
         * @returns {CLPF.BankItemLogQueryReq} BankItemLogQueryReq instance
         */
        BankItemLogQueryReq.create = function create(properties) {
            return new BankItemLogQueryReq(properties);
        };

        /**
         * Encodes the specified BankItemLogQueryReq message. Does not implicitly {@link CLPF.BankItemLogQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {CLPF.IBankItemLogQueryReq} message BankItemLogQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimestamp != null && Object.hasOwnProperty.call(message, "startTimestamp"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.startTimestamp);
            if (message.endTimestamp != null && Object.hasOwnProperty.call(message, "endTimestamp"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.endTimestamp);
            return writer;
        };

        /**
         * Encodes the specified BankItemLogQueryReq message, length delimited. Does not implicitly {@link CLPF.BankItemLogQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {CLPF.IBankItemLogQueryReq} message BankItemLogQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemLogQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemLogQueryReq} BankItemLogQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemLogQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTimestamp = reader.fixed32();
                    break;
                case 2:
                    message.endTimestamp = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemLogQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemLogQueryReq} BankItemLogQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemLogQueryReq message.
         * @function verify
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemLogQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimestamp != null && message.hasOwnProperty("startTimestamp"))
                if (!$util.isInteger(message.startTimestamp))
                    return "startTimestamp: integer expected";
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                if (!$util.isInteger(message.endTimestamp))
                    return "endTimestamp: integer expected";
            return null;
        };

        /**
         * Creates a BankItemLogQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemLogQueryReq} BankItemLogQueryReq
         */
        BankItemLogQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemLogQueryReq)
                return object;
            var message = new $root.CLPF.BankItemLogQueryReq();
            if (object.startTimestamp != null)
                message.startTimestamp = object.startTimestamp >>> 0;
            if (object.endTimestamp != null)
                message.endTimestamp = object.endTimestamp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BankItemLogQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemLogQueryReq
         * @static
         * @param {CLPF.BankItemLogQueryReq} message BankItemLogQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemLogQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.startTimestamp = 0;
                object.endTimestamp = 0;
            }
            if (message.startTimestamp != null && message.hasOwnProperty("startTimestamp"))
                object.startTimestamp = message.startTimestamp;
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                object.endTimestamp = message.endTimestamp;
            return object;
        };

        /**
         * Converts this BankItemLogQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemLogQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemLogQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemLogQueryReq;
    })();

    CLPF.BankItemLogQueryAck = (function() {

        /**
         * Properties of a BankItemLogQueryAck.
         * @memberof CLPF
         * @interface IBankItemLogQueryAck
         * @property {number|null} [errcode] BankItemLogQueryAck errcode
         * @property {Array.<CLPF.IBankItemLogInfo>|null} [logArray] BankItemLogQueryAck logArray
         */

        /**
         * Constructs a new BankItemLogQueryAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemLogQueryAck.
         * @implements IBankItemLogQueryAck
         * @constructor
         * @param {CLPF.IBankItemLogQueryAck=} [properties] Properties to set
         */
        function BankItemLogQueryAck(properties) {
            this.logArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemLogQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemLogQueryAck
         * @instance
         */
        BankItemLogQueryAck.prototype.errcode = 0;

        /**
         * BankItemLogQueryAck logArray.
         * @member {Array.<CLPF.IBankItemLogInfo>} logArray
         * @memberof CLPF.BankItemLogQueryAck
         * @instance
         */
        BankItemLogQueryAck.prototype.logArray = $util.emptyArray;

        /**
         * Creates a new BankItemLogQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {CLPF.IBankItemLogQueryAck=} [properties] Properties to set
         * @returns {CLPF.BankItemLogQueryAck} BankItemLogQueryAck instance
         */
        BankItemLogQueryAck.create = function create(properties) {
            return new BankItemLogQueryAck(properties);
        };

        /**
         * Encodes the specified BankItemLogQueryAck message. Does not implicitly {@link CLPF.BankItemLogQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {CLPF.IBankItemLogQueryAck} message BankItemLogQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.logArray != null && message.logArray.length)
                for (var i = 0; i < message.logArray.length; ++i)
                    $root.CLPF.BankItemLogInfo.encode(message.logArray[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemLogQueryAck message, length delimited. Does not implicitly {@link CLPF.BankItemLogQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {CLPF.IBankItemLogQueryAck} message BankItemLogQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemLogQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemLogQueryAck} BankItemLogQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemLogQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.logArray && message.logArray.length))
                        message.logArray = [];
                    message.logArray.push($root.CLPF.BankItemLogInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemLogQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemLogQueryAck} BankItemLogQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemLogQueryAck message.
         * @function verify
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemLogQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.logArray != null && message.hasOwnProperty("logArray")) {
                if (!Array.isArray(message.logArray))
                    return "logArray: array expected";
                for (var i = 0; i < message.logArray.length; ++i) {
                    var error = $root.CLPF.BankItemLogInfo.verify(message.logArray[i]);
                    if (error)
                        return "logArray." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BankItemLogQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemLogQueryAck} BankItemLogQueryAck
         */
        BankItemLogQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemLogQueryAck)
                return object;
            var message = new $root.CLPF.BankItemLogQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.logArray) {
                if (!Array.isArray(object.logArray))
                    throw TypeError(".CLPF.BankItemLogQueryAck.logArray: array expected");
                message.logArray = [];
                for (var i = 0; i < object.logArray.length; ++i) {
                    if (typeof object.logArray[i] !== "object")
                        throw TypeError(".CLPF.BankItemLogQueryAck.logArray: object expected");
                    message.logArray[i] = $root.CLPF.BankItemLogInfo.fromObject(object.logArray[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemLogQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemLogQueryAck
         * @static
         * @param {CLPF.BankItemLogQueryAck} message BankItemLogQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemLogQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logArray = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.logArray && message.logArray.length) {
                object.logArray = [];
                for (var j = 0; j < message.logArray.length; ++j)
                    object.logArray[j] = $root.CLPF.BankItemLogInfo.toObject(message.logArray[j], options);
            }
            return object;
        };

        /**
         * Converts this BankItemLogQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemLogQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemLogQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemLogQueryAck;
    })();

    CLPF.BankItemDailyLogInfo = (function() {

        /**
         * Properties of a BankItemDailyLogInfo.
         * @memberof CLPF
         * @interface IBankItemDailyLogInfo
         * @property {number|null} [dayTimestamp] BankItemDailyLogInfo dayTimestamp
         * @property {number|Long|null} [totalSend] BankItemDailyLogInfo totalSend
         * @property {number|Long|null} [totalRecv] BankItemDailyLogInfo totalRecv
         */

        /**
         * Constructs a new BankItemDailyLogInfo.
         * @memberof CLPF
         * @classdesc Represents a BankItemDailyLogInfo.
         * @implements IBankItemDailyLogInfo
         * @constructor
         * @param {CLPF.IBankItemDailyLogInfo=} [properties] Properties to set
         */
        function BankItemDailyLogInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemDailyLogInfo dayTimestamp.
         * @member {number} dayTimestamp
         * @memberof CLPF.BankItemDailyLogInfo
         * @instance
         */
        BankItemDailyLogInfo.prototype.dayTimestamp = 0;

        /**
         * BankItemDailyLogInfo totalSend.
         * @member {number|Long} totalSend
         * @memberof CLPF.BankItemDailyLogInfo
         * @instance
         */
        BankItemDailyLogInfo.prototype.totalSend = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BankItemDailyLogInfo totalRecv.
         * @member {number|Long} totalRecv
         * @memberof CLPF.BankItemDailyLogInfo
         * @instance
         */
        BankItemDailyLogInfo.prototype.totalRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BankItemDailyLogInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {CLPF.IBankItemDailyLogInfo=} [properties] Properties to set
         * @returns {CLPF.BankItemDailyLogInfo} BankItemDailyLogInfo instance
         */
        BankItemDailyLogInfo.create = function create(properties) {
            return new BankItemDailyLogInfo(properties);
        };

        /**
         * Encodes the specified BankItemDailyLogInfo message. Does not implicitly {@link CLPF.BankItemDailyLogInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {CLPF.IBankItemDailyLogInfo} message BankItemDailyLogInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dayTimestamp != null && Object.hasOwnProperty.call(message, "dayTimestamp"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.dayTimestamp);
            if (message.totalSend != null && Object.hasOwnProperty.call(message, "totalSend"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalSend);
            if (message.totalRecv != null && Object.hasOwnProperty.call(message, "totalRecv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalRecv);
            return writer;
        };

        /**
         * Encodes the specified BankItemDailyLogInfo message, length delimited. Does not implicitly {@link CLPF.BankItemDailyLogInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {CLPF.IBankItemDailyLogInfo} message BankItemDailyLogInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemDailyLogInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemDailyLogInfo} BankItemDailyLogInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemDailyLogInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dayTimestamp = reader.fixed32();
                    break;
                case 2:
                    message.totalSend = reader.int64();
                    break;
                case 3:
                    message.totalRecv = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemDailyLogInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemDailyLogInfo} BankItemDailyLogInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemDailyLogInfo message.
         * @function verify
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemDailyLogInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dayTimestamp != null && message.hasOwnProperty("dayTimestamp"))
                if (!$util.isInteger(message.dayTimestamp))
                    return "dayTimestamp: integer expected";
            if (message.totalSend != null && message.hasOwnProperty("totalSend"))
                if (!$util.isInteger(message.totalSend) && !(message.totalSend && $util.isInteger(message.totalSend.low) && $util.isInteger(message.totalSend.high)))
                    return "totalSend: integer|Long expected";
            if (message.totalRecv != null && message.hasOwnProperty("totalRecv"))
                if (!$util.isInteger(message.totalRecv) && !(message.totalRecv && $util.isInteger(message.totalRecv.low) && $util.isInteger(message.totalRecv.high)))
                    return "totalRecv: integer|Long expected";
            return null;
        };

        /**
         * Creates a BankItemDailyLogInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemDailyLogInfo} BankItemDailyLogInfo
         */
        BankItemDailyLogInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemDailyLogInfo)
                return object;
            var message = new $root.CLPF.BankItemDailyLogInfo();
            if (object.dayTimestamp != null)
                message.dayTimestamp = object.dayTimestamp >>> 0;
            if (object.totalSend != null)
                if ($util.Long)
                    (message.totalSend = $util.Long.fromValue(object.totalSend)).unsigned = false;
                else if (typeof object.totalSend === "string")
                    message.totalSend = parseInt(object.totalSend, 10);
                else if (typeof object.totalSend === "number")
                    message.totalSend = object.totalSend;
                else if (typeof object.totalSend === "object")
                    message.totalSend = new $util.LongBits(object.totalSend.low >>> 0, object.totalSend.high >>> 0).toNumber();
            if (object.totalRecv != null)
                if ($util.Long)
                    (message.totalRecv = $util.Long.fromValue(object.totalRecv)).unsigned = false;
                else if (typeof object.totalRecv === "string")
                    message.totalRecv = parseInt(object.totalRecv, 10);
                else if (typeof object.totalRecv === "number")
                    message.totalRecv = object.totalRecv;
                else if (typeof object.totalRecv === "object")
                    message.totalRecv = new $util.LongBits(object.totalRecv.low >>> 0, object.totalRecv.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BankItemDailyLogInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemDailyLogInfo
         * @static
         * @param {CLPF.BankItemDailyLogInfo} message BankItemDailyLogInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemDailyLogInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dayTimestamp = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalSend = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSend = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalRecv = options.longs === String ? "0" : 0;
            }
            if (message.dayTimestamp != null && message.hasOwnProperty("dayTimestamp"))
                object.dayTimestamp = message.dayTimestamp;
            if (message.totalSend != null && message.hasOwnProperty("totalSend"))
                if (typeof message.totalSend === "number")
                    object.totalSend = options.longs === String ? String(message.totalSend) : message.totalSend;
                else
                    object.totalSend = options.longs === String ? $util.Long.prototype.toString.call(message.totalSend) : options.longs === Number ? new $util.LongBits(message.totalSend.low >>> 0, message.totalSend.high >>> 0).toNumber() : message.totalSend;
            if (message.totalRecv != null && message.hasOwnProperty("totalRecv"))
                if (typeof message.totalRecv === "number")
                    object.totalRecv = options.longs === String ? String(message.totalRecv) : message.totalRecv;
                else
                    object.totalRecv = options.longs === String ? $util.Long.prototype.toString.call(message.totalRecv) : options.longs === Number ? new $util.LongBits(message.totalRecv.low >>> 0, message.totalRecv.high >>> 0).toNumber() : message.totalRecv;
            return object;
        };

        /**
         * Converts this BankItemDailyLogInfo to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemDailyLogInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemDailyLogInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemDailyLogInfo;
    })();

    CLPF.BankItemDailyLogQueryReq = (function() {

        /**
         * Properties of a BankItemDailyLogQueryReq.
         * @memberof CLPF
         * @interface IBankItemDailyLogQueryReq
         * @property {number|null} [startTimestamp] BankItemDailyLogQueryReq startTimestamp
         * @property {number|null} [endTimestamp] BankItemDailyLogQueryReq endTimestamp
         */

        /**
         * Constructs a new BankItemDailyLogQueryReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemDailyLogQueryReq.
         * @implements IBankItemDailyLogQueryReq
         * @constructor
         * @param {CLPF.IBankItemDailyLogQueryReq=} [properties] Properties to set
         */
        function BankItemDailyLogQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemDailyLogQueryReq startTimestamp.
         * @member {number} startTimestamp
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @instance
         */
        BankItemDailyLogQueryReq.prototype.startTimestamp = 0;

        /**
         * BankItemDailyLogQueryReq endTimestamp.
         * @member {number} endTimestamp
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @instance
         */
        BankItemDailyLogQueryReq.prototype.endTimestamp = 0;

        /**
         * Creates a new BankItemDailyLogQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {CLPF.IBankItemDailyLogQueryReq=} [properties] Properties to set
         * @returns {CLPF.BankItemDailyLogQueryReq} BankItemDailyLogQueryReq instance
         */
        BankItemDailyLogQueryReq.create = function create(properties) {
            return new BankItemDailyLogQueryReq(properties);
        };

        /**
         * Encodes the specified BankItemDailyLogQueryReq message. Does not implicitly {@link CLPF.BankItemDailyLogQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {CLPF.IBankItemDailyLogQueryReq} message BankItemDailyLogQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimestamp != null && Object.hasOwnProperty.call(message, "startTimestamp"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.startTimestamp);
            if (message.endTimestamp != null && Object.hasOwnProperty.call(message, "endTimestamp"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.endTimestamp);
            return writer;
        };

        /**
         * Encodes the specified BankItemDailyLogQueryReq message, length delimited. Does not implicitly {@link CLPF.BankItemDailyLogQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {CLPF.IBankItemDailyLogQueryReq} message BankItemDailyLogQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemDailyLogQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemDailyLogQueryReq} BankItemDailyLogQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemDailyLogQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTimestamp = reader.fixed32();
                    break;
                case 2:
                    message.endTimestamp = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemDailyLogQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemDailyLogQueryReq} BankItemDailyLogQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemDailyLogQueryReq message.
         * @function verify
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemDailyLogQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimestamp != null && message.hasOwnProperty("startTimestamp"))
                if (!$util.isInteger(message.startTimestamp))
                    return "startTimestamp: integer expected";
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                if (!$util.isInteger(message.endTimestamp))
                    return "endTimestamp: integer expected";
            return null;
        };

        /**
         * Creates a BankItemDailyLogQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemDailyLogQueryReq} BankItemDailyLogQueryReq
         */
        BankItemDailyLogQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemDailyLogQueryReq)
                return object;
            var message = new $root.CLPF.BankItemDailyLogQueryReq();
            if (object.startTimestamp != null)
                message.startTimestamp = object.startTimestamp >>> 0;
            if (object.endTimestamp != null)
                message.endTimestamp = object.endTimestamp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BankItemDailyLogQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @static
         * @param {CLPF.BankItemDailyLogQueryReq} message BankItemDailyLogQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemDailyLogQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.startTimestamp = 0;
                object.endTimestamp = 0;
            }
            if (message.startTimestamp != null && message.hasOwnProperty("startTimestamp"))
                object.startTimestamp = message.startTimestamp;
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                object.endTimestamp = message.endTimestamp;
            return object;
        };

        /**
         * Converts this BankItemDailyLogQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemDailyLogQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemDailyLogQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemDailyLogQueryReq;
    })();

    CLPF.BankItemDailyLogQueryAck = (function() {

        /**
         * Properties of a BankItemDailyLogQueryAck.
         * @memberof CLPF
         * @interface IBankItemDailyLogQueryAck
         * @property {number|null} [errcode] BankItemDailyLogQueryAck errcode
         * @property {Array.<CLPF.IBankItemDailyLogInfo>|null} [logArray] BankItemDailyLogQueryAck logArray
         */

        /**
         * Constructs a new BankItemDailyLogQueryAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemDailyLogQueryAck.
         * @implements IBankItemDailyLogQueryAck
         * @constructor
         * @param {CLPF.IBankItemDailyLogQueryAck=} [properties] Properties to set
         */
        function BankItemDailyLogQueryAck(properties) {
            this.logArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemDailyLogQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @instance
         */
        BankItemDailyLogQueryAck.prototype.errcode = 0;

        /**
         * BankItemDailyLogQueryAck logArray.
         * @member {Array.<CLPF.IBankItemDailyLogInfo>} logArray
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @instance
         */
        BankItemDailyLogQueryAck.prototype.logArray = $util.emptyArray;

        /**
         * Creates a new BankItemDailyLogQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {CLPF.IBankItemDailyLogQueryAck=} [properties] Properties to set
         * @returns {CLPF.BankItemDailyLogQueryAck} BankItemDailyLogQueryAck instance
         */
        BankItemDailyLogQueryAck.create = function create(properties) {
            return new BankItemDailyLogQueryAck(properties);
        };

        /**
         * Encodes the specified BankItemDailyLogQueryAck message. Does not implicitly {@link CLPF.BankItemDailyLogQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {CLPF.IBankItemDailyLogQueryAck} message BankItemDailyLogQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.logArray != null && message.logArray.length)
                for (var i = 0; i < message.logArray.length; ++i)
                    $root.CLPF.BankItemDailyLogInfo.encode(message.logArray[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemDailyLogQueryAck message, length delimited. Does not implicitly {@link CLPF.BankItemDailyLogQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {CLPF.IBankItemDailyLogQueryAck} message BankItemDailyLogQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemDailyLogQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemDailyLogQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemDailyLogQueryAck} BankItemDailyLogQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemDailyLogQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.logArray && message.logArray.length))
                        message.logArray = [];
                    message.logArray.push($root.CLPF.BankItemDailyLogInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemDailyLogQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemDailyLogQueryAck} BankItemDailyLogQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemDailyLogQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemDailyLogQueryAck message.
         * @function verify
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemDailyLogQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.logArray != null && message.hasOwnProperty("logArray")) {
                if (!Array.isArray(message.logArray))
                    return "logArray: array expected";
                for (var i = 0; i < message.logArray.length; ++i) {
                    var error = $root.CLPF.BankItemDailyLogInfo.verify(message.logArray[i]);
                    if (error)
                        return "logArray." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BankItemDailyLogQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemDailyLogQueryAck} BankItemDailyLogQueryAck
         */
        BankItemDailyLogQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemDailyLogQueryAck)
                return object;
            var message = new $root.CLPF.BankItemDailyLogQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.logArray) {
                if (!Array.isArray(object.logArray))
                    throw TypeError(".CLPF.BankItemDailyLogQueryAck.logArray: array expected");
                message.logArray = [];
                for (var i = 0; i < object.logArray.length; ++i) {
                    if (typeof object.logArray[i] !== "object")
                        throw TypeError(".CLPF.BankItemDailyLogQueryAck.logArray: object expected");
                    message.logArray[i] = $root.CLPF.BankItemDailyLogInfo.fromObject(object.logArray[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemDailyLogQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @static
         * @param {CLPF.BankItemDailyLogQueryAck} message BankItemDailyLogQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemDailyLogQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logArray = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.logArray && message.logArray.length) {
                object.logArray = [];
                for (var j = 0; j < message.logArray.length; ++j)
                    object.logArray[j] = $root.CLPF.BankItemDailyLogInfo.toObject(message.logArray[j], options);
            }
            return object;
        };

        /**
         * Converts this BankItemDailyLogQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemDailyLogQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemDailyLogQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemDailyLogQueryAck;
    })();

    CLPF.BankItemLogDetailQueryReq = (function() {

        /**
         * Properties of a BankItemLogDetailQueryReq.
         * @memberof CLPF
         * @interface IBankItemLogDetailQueryReq
         * @property {number|null} [logType] BankItemLogDetailQueryReq logType
         * @property {number|null} [queryType] BankItemLogDetailQueryReq queryType
         * @property {number|null} [referUniqueId] BankItemLogDetailQueryReq referUniqueId
         * @property {number|null} [orderType] BankItemLogDetailQueryReq orderType
         * @property {number|null} [count] BankItemLogDetailQueryReq count
         */

        /**
         * Constructs a new BankItemLogDetailQueryReq.
         * @memberof CLPF
         * @classdesc Represents a BankItemLogDetailQueryReq.
         * @implements IBankItemLogDetailQueryReq
         * @constructor
         * @param {CLPF.IBankItemLogDetailQueryReq=} [properties] Properties to set
         */
        function BankItemLogDetailQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemLogDetailQueryReq logType.
         * @member {number} logType
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         */
        BankItemLogDetailQueryReq.prototype.logType = 0;

        /**
         * BankItemLogDetailQueryReq queryType.
         * @member {number} queryType
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         */
        BankItemLogDetailQueryReq.prototype.queryType = 0;

        /**
         * BankItemLogDetailQueryReq referUniqueId.
         * @member {number} referUniqueId
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         */
        BankItemLogDetailQueryReq.prototype.referUniqueId = 0;

        /**
         * BankItemLogDetailQueryReq orderType.
         * @member {number} orderType
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         */
        BankItemLogDetailQueryReq.prototype.orderType = 0;

        /**
         * BankItemLogDetailQueryReq count.
         * @member {number} count
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         */
        BankItemLogDetailQueryReq.prototype.count = 0;

        /**
         * Creates a new BankItemLogDetailQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {CLPF.IBankItemLogDetailQueryReq=} [properties] Properties to set
         * @returns {CLPF.BankItemLogDetailQueryReq} BankItemLogDetailQueryReq instance
         */
        BankItemLogDetailQueryReq.create = function create(properties) {
            return new BankItemLogDetailQueryReq(properties);
        };

        /**
         * Encodes the specified BankItemLogDetailQueryReq message. Does not implicitly {@link CLPF.BankItemLogDetailQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {CLPF.IBankItemLogDetailQueryReq} message BankItemLogDetailQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogDetailQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logType != null && Object.hasOwnProperty.call(message, "logType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logType);
            if (message.queryType != null && Object.hasOwnProperty.call(message, "queryType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.queryType);
            if (message.referUniqueId != null && Object.hasOwnProperty.call(message, "referUniqueId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.referUniqueId);
            if (message.orderType != null && Object.hasOwnProperty.call(message, "orderType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.orderType);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified BankItemLogDetailQueryReq message, length delimited. Does not implicitly {@link CLPF.BankItemLogDetailQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {CLPF.IBankItemLogDetailQueryReq} message BankItemLogDetailQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogDetailQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemLogDetailQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemLogDetailQueryReq} BankItemLogDetailQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogDetailQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemLogDetailQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logType = reader.int32();
                    break;
                case 2:
                    message.queryType = reader.int32();
                    break;
                case 3:
                    message.referUniqueId = reader.int32();
                    break;
                case 4:
                    message.orderType = reader.int32();
                    break;
                case 5:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemLogDetailQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemLogDetailQueryReq} BankItemLogDetailQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogDetailQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemLogDetailQueryReq message.
         * @function verify
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemLogDetailQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logType != null && message.hasOwnProperty("logType"))
                if (!$util.isInteger(message.logType))
                    return "logType: integer expected";
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                if (!$util.isInteger(message.queryType))
                    return "queryType: integer expected";
            if (message.referUniqueId != null && message.hasOwnProperty("referUniqueId"))
                if (!$util.isInteger(message.referUniqueId))
                    return "referUniqueId: integer expected";
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                if (!$util.isInteger(message.orderType))
                    return "orderType: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a BankItemLogDetailQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemLogDetailQueryReq} BankItemLogDetailQueryReq
         */
        BankItemLogDetailQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemLogDetailQueryReq)
                return object;
            var message = new $root.CLPF.BankItemLogDetailQueryReq();
            if (object.logType != null)
                message.logType = object.logType | 0;
            if (object.queryType != null)
                message.queryType = object.queryType | 0;
            if (object.referUniqueId != null)
                message.referUniqueId = object.referUniqueId | 0;
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a BankItemLogDetailQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @static
         * @param {CLPF.BankItemLogDetailQueryReq} message BankItemLogDetailQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemLogDetailQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logType = 0;
                object.queryType = 0;
                object.referUniqueId = 0;
                object.orderType = 0;
                object.count = 0;
            }
            if (message.logType != null && message.hasOwnProperty("logType"))
                object.logType = message.logType;
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                object.queryType = message.queryType;
            if (message.referUniqueId != null && message.hasOwnProperty("referUniqueId"))
                object.referUniqueId = message.referUniqueId;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this BankItemLogDetailQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemLogDetailQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemLogDetailQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemLogDetailQueryReq;
    })();

    CLPF.BankItemLogDetailQueryAck = (function() {

        /**
         * Properties of a BankItemLogDetailQueryAck.
         * @memberof CLPF
         * @interface IBankItemLogDetailQueryAck
         * @property {number|null} [errcode] BankItemLogDetailQueryAck errcode
         * @property {Array.<CLPF.IBankItemLogInfo>|null} [logArray] BankItemLogDetailQueryAck logArray
         */

        /**
         * Constructs a new BankItemLogDetailQueryAck.
         * @memberof CLPF
         * @classdesc Represents a BankItemLogDetailQueryAck.
         * @implements IBankItemLogDetailQueryAck
         * @constructor
         * @param {CLPF.IBankItemLogDetailQueryAck=} [properties] Properties to set
         */
        function BankItemLogDetailQueryAck(properties) {
            this.logArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BankItemLogDetailQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @instance
         */
        BankItemLogDetailQueryAck.prototype.errcode = 0;

        /**
         * BankItemLogDetailQueryAck logArray.
         * @member {Array.<CLPF.IBankItemLogInfo>} logArray
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @instance
         */
        BankItemLogDetailQueryAck.prototype.logArray = $util.emptyArray;

        /**
         * Creates a new BankItemLogDetailQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {CLPF.IBankItemLogDetailQueryAck=} [properties] Properties to set
         * @returns {CLPF.BankItemLogDetailQueryAck} BankItemLogDetailQueryAck instance
         */
        BankItemLogDetailQueryAck.create = function create(properties) {
            return new BankItemLogDetailQueryAck(properties);
        };

        /**
         * Encodes the specified BankItemLogDetailQueryAck message. Does not implicitly {@link CLPF.BankItemLogDetailQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {CLPF.IBankItemLogDetailQueryAck} message BankItemLogDetailQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogDetailQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.logArray != null && message.logArray.length)
                for (var i = 0; i < message.logArray.length; ++i)
                    $root.CLPF.BankItemLogInfo.encode(message.logArray[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BankItemLogDetailQueryAck message, length delimited. Does not implicitly {@link CLPF.BankItemLogDetailQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {CLPF.IBankItemLogDetailQueryAck} message BankItemLogDetailQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BankItemLogDetailQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BankItemLogDetailQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.BankItemLogDetailQueryAck} BankItemLogDetailQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogDetailQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.BankItemLogDetailQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.logArray && message.logArray.length))
                        message.logArray = [];
                    message.logArray.push($root.CLPF.BankItemLogInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BankItemLogDetailQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.BankItemLogDetailQueryAck} BankItemLogDetailQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BankItemLogDetailQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BankItemLogDetailQueryAck message.
         * @function verify
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BankItemLogDetailQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.logArray != null && message.hasOwnProperty("logArray")) {
                if (!Array.isArray(message.logArray))
                    return "logArray: array expected";
                for (var i = 0; i < message.logArray.length; ++i) {
                    var error = $root.CLPF.BankItemLogInfo.verify(message.logArray[i]);
                    if (error)
                        return "logArray." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BankItemLogDetailQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.BankItemLogDetailQueryAck} BankItemLogDetailQueryAck
         */
        BankItemLogDetailQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.BankItemLogDetailQueryAck)
                return object;
            var message = new $root.CLPF.BankItemLogDetailQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.logArray) {
                if (!Array.isArray(object.logArray))
                    throw TypeError(".CLPF.BankItemLogDetailQueryAck.logArray: array expected");
                message.logArray = [];
                for (var i = 0; i < object.logArray.length; ++i) {
                    if (typeof object.logArray[i] !== "object")
                        throw TypeError(".CLPF.BankItemLogDetailQueryAck.logArray: object expected");
                    message.logArray[i] = $root.CLPF.BankItemLogInfo.fromObject(object.logArray[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BankItemLogDetailQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @static
         * @param {CLPF.BankItemLogDetailQueryAck} message BankItemLogDetailQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BankItemLogDetailQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logArray = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.logArray && message.logArray.length) {
                object.logArray = [];
                for (var j = 0; j < message.logArray.length; ++j)
                    object.logArray[j] = $root.CLPF.BankItemLogInfo.toObject(message.logArray[j], options);
            }
            return object;
        };

        /**
         * Converts this BankItemLogDetailQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.BankItemLogDetailQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BankItemLogDetailQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BankItemLogDetailQueryAck;
    })();

    CLPF.LastGameQueryReq = (function() {

        /**
         * Properties of a LastGameQueryReq.
         * @memberof CLPF
         * @interface ILastGameQueryReq
         */

        /**
         * Constructs a new LastGameQueryReq.
         * @memberof CLPF
         * @classdesc Represents a LastGameQueryReq.
         * @implements ILastGameQueryReq
         * @constructor
         * @param {CLPF.ILastGameQueryReq=} [properties] Properties to set
         */
        function LastGameQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LastGameQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {CLPF.ILastGameQueryReq=} [properties] Properties to set
         * @returns {CLPF.LastGameQueryReq} LastGameQueryReq instance
         */
        LastGameQueryReq.create = function create(properties) {
            return new LastGameQueryReq(properties);
        };

        /**
         * Encodes the specified LastGameQueryReq message. Does not implicitly {@link CLPF.LastGameQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {CLPF.ILastGameQueryReq} message LastGameQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastGameQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LastGameQueryReq message, length delimited. Does not implicitly {@link CLPF.LastGameQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {CLPF.ILastGameQueryReq} message LastGameQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastGameQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastGameQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LastGameQueryReq} LastGameQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastGameQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LastGameQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastGameQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LastGameQueryReq} LastGameQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastGameQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastGameQueryReq message.
         * @function verify
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastGameQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LastGameQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LastGameQueryReq} LastGameQueryReq
         */
        LastGameQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LastGameQueryReq)
                return object;
            return new $root.CLPF.LastGameQueryReq();
        };

        /**
         * Creates a plain object from a LastGameQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LastGameQueryReq
         * @static
         * @param {CLPF.LastGameQueryReq} message LastGameQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastGameQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LastGameQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.LastGameQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastGameQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastGameQueryReq;
    })();

    CLPF.LastGameQueryAck = (function() {

        /**
         * Properties of a LastGameQueryAck.
         * @memberof CLPF
         * @interface ILastGameQueryAck
         * @property {number|null} [errcode] LastGameQueryAck errcode
         * @property {number|null} [gameId] LastGameQueryAck gameId
         * @property {number|null} [roomId] LastGameQueryAck roomId
         * @property {number|null} [deskId] LastGameQueryAck deskId
         * @property {number|null} [seatId] LastGameQueryAck seatId
         */

        /**
         * Constructs a new LastGameQueryAck.
         * @memberof CLPF
         * @classdesc Represents a LastGameQueryAck.
         * @implements ILastGameQueryAck
         * @constructor
         * @param {CLPF.ILastGameQueryAck=} [properties] Properties to set
         */
        function LastGameQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LastGameQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.LastGameQueryAck
         * @instance
         */
        LastGameQueryAck.prototype.errcode = 0;

        /**
         * LastGameQueryAck gameId.
         * @member {number} gameId
         * @memberof CLPF.LastGameQueryAck
         * @instance
         */
        LastGameQueryAck.prototype.gameId = 0;

        /**
         * LastGameQueryAck roomId.
         * @member {number} roomId
         * @memberof CLPF.LastGameQueryAck
         * @instance
         */
        LastGameQueryAck.prototype.roomId = 0;

        /**
         * LastGameQueryAck deskId.
         * @member {number} deskId
         * @memberof CLPF.LastGameQueryAck
         * @instance
         */
        LastGameQueryAck.prototype.deskId = 0;

        /**
         * LastGameQueryAck seatId.
         * @member {number} seatId
         * @memberof CLPF.LastGameQueryAck
         * @instance
         */
        LastGameQueryAck.prototype.seatId = 0;

        /**
         * Creates a new LastGameQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {CLPF.ILastGameQueryAck=} [properties] Properties to set
         * @returns {CLPF.LastGameQueryAck} LastGameQueryAck instance
         */
        LastGameQueryAck.create = function create(properties) {
            return new LastGameQueryAck(properties);
        };

        /**
         * Encodes the specified LastGameQueryAck message. Does not implicitly {@link CLPF.LastGameQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {CLPF.ILastGameQueryAck} message LastGameQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastGameQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roomId);
            if (message.deskId != null && Object.hasOwnProperty.call(message, "deskId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.deskId);
            if (message.seatId != null && Object.hasOwnProperty.call(message, "seatId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.seatId);
            return writer;
        };

        /**
         * Encodes the specified LastGameQueryAck message, length delimited. Does not implicitly {@link CLPF.LastGameQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {CLPF.ILastGameQueryAck} message LastGameQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastGameQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastGameQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.LastGameQueryAck} LastGameQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastGameQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.LastGameQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    message.roomId = reader.int32();
                    break;
                case 4:
                    message.deskId = reader.int32();
                    break;
                case 5:
                    message.seatId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastGameQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.LastGameQueryAck} LastGameQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastGameQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastGameQueryAck message.
         * @function verify
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastGameQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.deskId != null && message.hasOwnProperty("deskId"))
                if (!$util.isInteger(message.deskId))
                    return "deskId: integer expected";
            if (message.seatId != null && message.hasOwnProperty("seatId"))
                if (!$util.isInteger(message.seatId))
                    return "seatId: integer expected";
            return null;
        };

        /**
         * Creates a LastGameQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.LastGameQueryAck} LastGameQueryAck
         */
        LastGameQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.LastGameQueryAck)
                return object;
            var message = new $root.CLPF.LastGameQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.deskId != null)
                message.deskId = object.deskId | 0;
            if (object.seatId != null)
                message.seatId = object.seatId | 0;
            return message;
        };

        /**
         * Creates a plain object from a LastGameQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.LastGameQueryAck
         * @static
         * @param {CLPF.LastGameQueryAck} message LastGameQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastGameQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.gameId = 0;
                object.roomId = 0;
                object.deskId = 0;
                object.seatId = 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.deskId != null && message.hasOwnProperty("deskId"))
                object.deskId = message.deskId;
            if (message.seatId != null && message.hasOwnProperty("seatId"))
                object.seatId = message.seatId;
            return object;
        };

        /**
         * Converts this LastGameQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.LastGameQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastGameQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastGameQueryAck;
    })();

    CLPF.HeadUrlQueryReq = (function() {

        /**
         * Properties of a HeadUrlQueryReq.
         * @memberof CLPF
         * @interface IHeadUrlQueryReq
         * @property {number|null} [userId] HeadUrlQueryReq userId
         */

        /**
         * Constructs a new HeadUrlQueryReq.
         * @memberof CLPF
         * @classdesc Represents a HeadUrlQueryReq.
         * @implements IHeadUrlQueryReq
         * @constructor
         * @param {CLPF.IHeadUrlQueryReq=} [properties] Properties to set
         */
        function HeadUrlQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeadUrlQueryReq userId.
         * @member {number} userId
         * @memberof CLPF.HeadUrlQueryReq
         * @instance
         */
        HeadUrlQueryReq.prototype.userId = 0;

        /**
         * Creates a new HeadUrlQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {CLPF.IHeadUrlQueryReq=} [properties] Properties to set
         * @returns {CLPF.HeadUrlQueryReq} HeadUrlQueryReq instance
         */
        HeadUrlQueryReq.create = function create(properties) {
            return new HeadUrlQueryReq(properties);
        };

        /**
         * Encodes the specified HeadUrlQueryReq message. Does not implicitly {@link CLPF.HeadUrlQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {CLPF.IHeadUrlQueryReq} message HeadUrlQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadUrlQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            return writer;
        };

        /**
         * Encodes the specified HeadUrlQueryReq message, length delimited. Does not implicitly {@link CLPF.HeadUrlQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {CLPF.IHeadUrlQueryReq} message HeadUrlQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadUrlQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeadUrlQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.HeadUrlQueryReq} HeadUrlQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadUrlQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.HeadUrlQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeadUrlQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.HeadUrlQueryReq} HeadUrlQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadUrlQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeadUrlQueryReq message.
         * @function verify
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeadUrlQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            return null;
        };

        /**
         * Creates a HeadUrlQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.HeadUrlQueryReq} HeadUrlQueryReq
         */
        HeadUrlQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.HeadUrlQueryReq)
                return object;
            var message = new $root.CLPF.HeadUrlQueryReq();
            if (object.userId != null)
                message.userId = object.userId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeadUrlQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.HeadUrlQueryReq
         * @static
         * @param {CLPF.HeadUrlQueryReq} message HeadUrlQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeadUrlQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.userId = 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this HeadUrlQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.HeadUrlQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeadUrlQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeadUrlQueryReq;
    })();

    CLPF.HeadUrlQueryAck = (function() {

        /**
         * Properties of a HeadUrlQueryAck.
         * @memberof CLPF
         * @interface IHeadUrlQueryAck
         * @property {number|null} [errcode] HeadUrlQueryAck errcode
         * @property {string|null} [url] HeadUrlQueryAck url
         */

        /**
         * Constructs a new HeadUrlQueryAck.
         * @memberof CLPF
         * @classdesc Represents a HeadUrlQueryAck.
         * @implements IHeadUrlQueryAck
         * @constructor
         * @param {CLPF.IHeadUrlQueryAck=} [properties] Properties to set
         */
        function HeadUrlQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeadUrlQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.HeadUrlQueryAck
         * @instance
         */
        HeadUrlQueryAck.prototype.errcode = 0;

        /**
         * HeadUrlQueryAck url.
         * @member {string} url
         * @memberof CLPF.HeadUrlQueryAck
         * @instance
         */
        HeadUrlQueryAck.prototype.url = "";

        /**
         * Creates a new HeadUrlQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {CLPF.IHeadUrlQueryAck=} [properties] Properties to set
         * @returns {CLPF.HeadUrlQueryAck} HeadUrlQueryAck instance
         */
        HeadUrlQueryAck.create = function create(properties) {
            return new HeadUrlQueryAck(properties);
        };

        /**
         * Encodes the specified HeadUrlQueryAck message. Does not implicitly {@link CLPF.HeadUrlQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {CLPF.IHeadUrlQueryAck} message HeadUrlQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadUrlQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified HeadUrlQueryAck message, length delimited. Does not implicitly {@link CLPF.HeadUrlQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {CLPF.IHeadUrlQueryAck} message HeadUrlQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadUrlQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeadUrlQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.HeadUrlQueryAck} HeadUrlQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadUrlQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.HeadUrlQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeadUrlQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.HeadUrlQueryAck} HeadUrlQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadUrlQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeadUrlQueryAck message.
         * @function verify
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeadUrlQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a HeadUrlQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.HeadUrlQueryAck} HeadUrlQueryAck
         */
        HeadUrlQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.HeadUrlQueryAck)
                return object;
            var message = new $root.CLPF.HeadUrlQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a HeadUrlQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.HeadUrlQueryAck
         * @static
         * @param {CLPF.HeadUrlQueryAck} message HeadUrlQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeadUrlQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.url = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this HeadUrlQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.HeadUrlQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeadUrlQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeadUrlQueryAck;
    })();

    CLPF.ModifyGenderReq = (function() {

        /**
         * Properties of a ModifyGenderReq.
         * @memberof CLPF
         * @interface IModifyGenderReq
         * @property {number|null} [newGender] ModifyGenderReq newGender
         */

        /**
         * Constructs a new ModifyGenderReq.
         * @memberof CLPF
         * @classdesc Represents a ModifyGenderReq.
         * @implements IModifyGenderReq
         * @constructor
         * @param {CLPF.IModifyGenderReq=} [properties] Properties to set
         */
        function ModifyGenderReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyGenderReq newGender.
         * @member {number} newGender
         * @memberof CLPF.ModifyGenderReq
         * @instance
         */
        ModifyGenderReq.prototype.newGender = 0;

        /**
         * Creates a new ModifyGenderReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {CLPF.IModifyGenderReq=} [properties] Properties to set
         * @returns {CLPF.ModifyGenderReq} ModifyGenderReq instance
         */
        ModifyGenderReq.create = function create(properties) {
            return new ModifyGenderReq(properties);
        };

        /**
         * Encodes the specified ModifyGenderReq message. Does not implicitly {@link CLPF.ModifyGenderReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {CLPF.IModifyGenderReq} message ModifyGenderReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyGenderReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newGender != null && Object.hasOwnProperty.call(message, "newGender"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.newGender);
            return writer;
        };

        /**
         * Encodes the specified ModifyGenderReq message, length delimited. Does not implicitly {@link CLPF.ModifyGenderReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {CLPF.IModifyGenderReq} message ModifyGenderReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyGenderReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyGenderReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyGenderReq} ModifyGenderReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGenderReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyGenderReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newGender = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyGenderReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyGenderReq} ModifyGenderReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGenderReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyGenderReq message.
         * @function verify
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyGenderReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newGender != null && message.hasOwnProperty("newGender"))
                if (!$util.isInteger(message.newGender))
                    return "newGender: integer expected";
            return null;
        };

        /**
         * Creates a ModifyGenderReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyGenderReq} ModifyGenderReq
         */
        ModifyGenderReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyGenderReq)
                return object;
            var message = new $root.CLPF.ModifyGenderReq();
            if (object.newGender != null)
                message.newGender = object.newGender | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyGenderReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyGenderReq
         * @static
         * @param {CLPF.ModifyGenderReq} message ModifyGenderReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyGenderReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.newGender = 0;
            if (message.newGender != null && message.hasOwnProperty("newGender"))
                object.newGender = message.newGender;
            return object;
        };

        /**
         * Converts this ModifyGenderReq to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyGenderReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyGenderReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyGenderReq;
    })();

    CLPF.ModifyGenderAck = (function() {

        /**
         * Properties of a ModifyGenderAck.
         * @memberof CLPF
         * @interface IModifyGenderAck
         * @property {number|null} [errcode] ModifyGenderAck errcode
         */

        /**
         * Constructs a new ModifyGenderAck.
         * @memberof CLPF
         * @classdesc Represents a ModifyGenderAck.
         * @implements IModifyGenderAck
         * @constructor
         * @param {CLPF.IModifyGenderAck=} [properties] Properties to set
         */
        function ModifyGenderAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyGenderAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ModifyGenderAck
         * @instance
         */
        ModifyGenderAck.prototype.errcode = 0;

        /**
         * Creates a new ModifyGenderAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {CLPF.IModifyGenderAck=} [properties] Properties to set
         * @returns {CLPF.ModifyGenderAck} ModifyGenderAck instance
         */
        ModifyGenderAck.create = function create(properties) {
            return new ModifyGenderAck(properties);
        };

        /**
         * Encodes the specified ModifyGenderAck message. Does not implicitly {@link CLPF.ModifyGenderAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {CLPF.IModifyGenderAck} message ModifyGenderAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyGenderAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ModifyGenderAck message, length delimited. Does not implicitly {@link CLPF.ModifyGenderAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {CLPF.IModifyGenderAck} message ModifyGenderAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyGenderAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyGenderAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ModifyGenderAck} ModifyGenderAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGenderAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ModifyGenderAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyGenderAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ModifyGenderAck} ModifyGenderAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGenderAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyGenderAck message.
         * @function verify
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyGenderAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a ModifyGenderAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ModifyGenderAck} ModifyGenderAck
         */
        ModifyGenderAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ModifyGenderAck)
                return object;
            var message = new $root.CLPF.ModifyGenderAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ModifyGenderAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ModifyGenderAck
         * @static
         * @param {CLPF.ModifyGenderAck} message ModifyGenderAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyGenderAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ModifyGenderAck to JSON.
         * @function toJSON
         * @memberof CLPF.ModifyGenderAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyGenderAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyGenderAck;
    })();

    CLPF.WeekSignStateQueryReq = (function() {

        /**
         * Properties of a WeekSignStateQueryReq.
         * @memberof CLPF
         * @interface IWeekSignStateQueryReq
         */

        /**
         * Constructs a new WeekSignStateQueryReq.
         * @memberof CLPF
         * @classdesc Represents a WeekSignStateQueryReq.
         * @implements IWeekSignStateQueryReq
         * @constructor
         * @param {CLPF.IWeekSignStateQueryReq=} [properties] Properties to set
         */
        function WeekSignStateQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WeekSignStateQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {CLPF.IWeekSignStateQueryReq=} [properties] Properties to set
         * @returns {CLPF.WeekSignStateQueryReq} WeekSignStateQueryReq instance
         */
        WeekSignStateQueryReq.create = function create(properties) {
            return new WeekSignStateQueryReq(properties);
        };

        /**
         * Encodes the specified WeekSignStateQueryReq message. Does not implicitly {@link CLPF.WeekSignStateQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {CLPF.IWeekSignStateQueryReq} message WeekSignStateQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignStateQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WeekSignStateQueryReq message, length delimited. Does not implicitly {@link CLPF.WeekSignStateQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {CLPF.IWeekSignStateQueryReq} message WeekSignStateQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignStateQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeekSignStateQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.WeekSignStateQueryReq} WeekSignStateQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignStateQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.WeekSignStateQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WeekSignStateQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.WeekSignStateQueryReq} WeekSignStateQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignStateQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeekSignStateQueryReq message.
         * @function verify
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeekSignStateQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WeekSignStateQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.WeekSignStateQueryReq} WeekSignStateQueryReq
         */
        WeekSignStateQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.WeekSignStateQueryReq)
                return object;
            return new $root.CLPF.WeekSignStateQueryReq();
        };

        /**
         * Creates a plain object from a WeekSignStateQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.WeekSignStateQueryReq
         * @static
         * @param {CLPF.WeekSignStateQueryReq} message WeekSignStateQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeekSignStateQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WeekSignStateQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.WeekSignStateQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeekSignStateQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeekSignStateQueryReq;
    })();

    CLPF.WeekSignStateQueryAck = (function() {

        /**
         * Properties of a WeekSignStateQueryAck.
         * @memberof CLPF
         * @interface IWeekSignStateQueryAck
         * @property {number|null} [errcode] WeekSignStateQueryAck errcode
         * @property {boolean|null} [todaySigned] WeekSignStateQueryAck todaySigned
         * @property {number|null} [signedCount] WeekSignStateQueryAck signedCount
         */

        /**
         * Constructs a new WeekSignStateQueryAck.
         * @memberof CLPF
         * @classdesc Represents a WeekSignStateQueryAck.
         * @implements IWeekSignStateQueryAck
         * @constructor
         * @param {CLPF.IWeekSignStateQueryAck=} [properties] Properties to set
         */
        function WeekSignStateQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WeekSignStateQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.WeekSignStateQueryAck
         * @instance
         */
        WeekSignStateQueryAck.prototype.errcode = 0;

        /**
         * WeekSignStateQueryAck todaySigned.
         * @member {boolean} todaySigned
         * @memberof CLPF.WeekSignStateQueryAck
         * @instance
         */
        WeekSignStateQueryAck.prototype.todaySigned = false;

        /**
         * WeekSignStateQueryAck signedCount.
         * @member {number} signedCount
         * @memberof CLPF.WeekSignStateQueryAck
         * @instance
         */
        WeekSignStateQueryAck.prototype.signedCount = 0;

        /**
         * Creates a new WeekSignStateQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {CLPF.IWeekSignStateQueryAck=} [properties] Properties to set
         * @returns {CLPF.WeekSignStateQueryAck} WeekSignStateQueryAck instance
         */
        WeekSignStateQueryAck.create = function create(properties) {
            return new WeekSignStateQueryAck(properties);
        };

        /**
         * Encodes the specified WeekSignStateQueryAck message. Does not implicitly {@link CLPF.WeekSignStateQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {CLPF.IWeekSignStateQueryAck} message WeekSignStateQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignStateQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.todaySigned != null && Object.hasOwnProperty.call(message, "todaySigned"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.todaySigned);
            if (message.signedCount != null && Object.hasOwnProperty.call(message, "signedCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.signedCount);
            return writer;
        };

        /**
         * Encodes the specified WeekSignStateQueryAck message, length delimited. Does not implicitly {@link CLPF.WeekSignStateQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {CLPF.IWeekSignStateQueryAck} message WeekSignStateQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignStateQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeekSignStateQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.WeekSignStateQueryAck} WeekSignStateQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignStateQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.WeekSignStateQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.todaySigned = reader.bool();
                    break;
                case 3:
                    message.signedCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WeekSignStateQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.WeekSignStateQueryAck} WeekSignStateQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignStateQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeekSignStateQueryAck message.
         * @function verify
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeekSignStateQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                if (typeof message.todaySigned !== "boolean")
                    return "todaySigned: boolean expected";
            if (message.signedCount != null && message.hasOwnProperty("signedCount"))
                if (!$util.isInteger(message.signedCount))
                    return "signedCount: integer expected";
            return null;
        };

        /**
         * Creates a WeekSignStateQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.WeekSignStateQueryAck} WeekSignStateQueryAck
         */
        WeekSignStateQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.WeekSignStateQueryAck)
                return object;
            var message = new $root.CLPF.WeekSignStateQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.todaySigned != null)
                message.todaySigned = Boolean(object.todaySigned);
            if (object.signedCount != null)
                message.signedCount = object.signedCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a WeekSignStateQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.WeekSignStateQueryAck
         * @static
         * @param {CLPF.WeekSignStateQueryAck} message WeekSignStateQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeekSignStateQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.todaySigned = false;
                object.signedCount = 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                object.todaySigned = message.todaySigned;
            if (message.signedCount != null && message.hasOwnProperty("signedCount"))
                object.signedCount = message.signedCount;
            return object;
        };

        /**
         * Converts this WeekSignStateQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.WeekSignStateQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeekSignStateQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeekSignStateQueryAck;
    })();

    CLPF.WeekSignActReq = (function() {

        /**
         * Properties of a WeekSignActReq.
         * @memberof CLPF
         * @interface IWeekSignActReq
         */

        /**
         * Constructs a new WeekSignActReq.
         * @memberof CLPF
         * @classdesc Represents a WeekSignActReq.
         * @implements IWeekSignActReq
         * @constructor
         * @param {CLPF.IWeekSignActReq=} [properties] Properties to set
         */
        function WeekSignActReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WeekSignActReq instance using the specified properties.
         * @function create
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {CLPF.IWeekSignActReq=} [properties] Properties to set
         * @returns {CLPF.WeekSignActReq} WeekSignActReq instance
         */
        WeekSignActReq.create = function create(properties) {
            return new WeekSignActReq(properties);
        };

        /**
         * Encodes the specified WeekSignActReq message. Does not implicitly {@link CLPF.WeekSignActReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {CLPF.IWeekSignActReq} message WeekSignActReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignActReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WeekSignActReq message, length delimited. Does not implicitly {@link CLPF.WeekSignActReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {CLPF.IWeekSignActReq} message WeekSignActReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignActReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeekSignActReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.WeekSignActReq} WeekSignActReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignActReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.WeekSignActReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WeekSignActReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.WeekSignActReq} WeekSignActReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignActReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeekSignActReq message.
         * @function verify
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeekSignActReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WeekSignActReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.WeekSignActReq} WeekSignActReq
         */
        WeekSignActReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.WeekSignActReq)
                return object;
            return new $root.CLPF.WeekSignActReq();
        };

        /**
         * Creates a plain object from a WeekSignActReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.WeekSignActReq
         * @static
         * @param {CLPF.WeekSignActReq} message WeekSignActReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeekSignActReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WeekSignActReq to JSON.
         * @function toJSON
         * @memberof CLPF.WeekSignActReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeekSignActReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeekSignActReq;
    })();

    CLPF.WeekSignActAck = (function() {

        /**
         * Properties of a WeekSignActAck.
         * @memberof CLPF
         * @interface IWeekSignActAck
         * @property {number|null} [errcode] WeekSignActAck errcode
         * @property {number|null} [signedCount] WeekSignActAck signedCount
         * @property {CLPF.IItemInfo|null} [item] WeekSignActAck item
         */

        /**
         * Constructs a new WeekSignActAck.
         * @memberof CLPF
         * @classdesc Represents a WeekSignActAck.
         * @implements IWeekSignActAck
         * @constructor
         * @param {CLPF.IWeekSignActAck=} [properties] Properties to set
         */
        function WeekSignActAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WeekSignActAck errcode.
         * @member {number} errcode
         * @memberof CLPF.WeekSignActAck
         * @instance
         */
        WeekSignActAck.prototype.errcode = 0;

        /**
         * WeekSignActAck signedCount.
         * @member {number} signedCount
         * @memberof CLPF.WeekSignActAck
         * @instance
         */
        WeekSignActAck.prototype.signedCount = 0;

        /**
         * WeekSignActAck item.
         * @member {CLPF.IItemInfo|null|undefined} item
         * @memberof CLPF.WeekSignActAck
         * @instance
         */
        WeekSignActAck.prototype.item = null;

        /**
         * Creates a new WeekSignActAck instance using the specified properties.
         * @function create
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {CLPF.IWeekSignActAck=} [properties] Properties to set
         * @returns {CLPF.WeekSignActAck} WeekSignActAck instance
         */
        WeekSignActAck.create = function create(properties) {
            return new WeekSignActAck(properties);
        };

        /**
         * Encodes the specified WeekSignActAck message. Does not implicitly {@link CLPF.WeekSignActAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {CLPF.IWeekSignActAck} message WeekSignActAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignActAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.signedCount != null && Object.hasOwnProperty.call(message, "signedCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.signedCount);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.ItemInfo.encode(message.item, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WeekSignActAck message, length delimited. Does not implicitly {@link CLPF.WeekSignActAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {CLPF.IWeekSignActAck} message WeekSignActAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeekSignActAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeekSignActAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.WeekSignActAck} WeekSignActAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignActAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.WeekSignActAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.signedCount = reader.int32();
                    break;
                case 3:
                    message.item = $root.CLPF.ItemInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WeekSignActAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.WeekSignActAck} WeekSignActAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeekSignActAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeekSignActAck message.
         * @function verify
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeekSignActAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.signedCount != null && message.hasOwnProperty("signedCount"))
                if (!$util.isInteger(message.signedCount))
                    return "signedCount: integer expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.ItemInfo.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a WeekSignActAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.WeekSignActAck} WeekSignActAck
         */
        WeekSignActAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.WeekSignActAck)
                return object;
            var message = new $root.CLPF.WeekSignActAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.signedCount != null)
                message.signedCount = object.signedCount | 0;
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.WeekSignActAck.item: object expected");
                message.item = $root.CLPF.ItemInfo.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a WeekSignActAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.WeekSignActAck
         * @static
         * @param {CLPF.WeekSignActAck} message WeekSignActAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeekSignActAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.signedCount = 0;
                object.item = null;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.signedCount != null && message.hasOwnProperty("signedCount"))
                object.signedCount = message.signedCount;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.ItemInfo.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this WeekSignActAck to JSON.
         * @function toJSON
         * @memberof CLPF.WeekSignActAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeekSignActAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeekSignActAck;
    })();

    CLPF.FeedbackStateQueryReq = (function() {

        /**
         * Properties of a FeedbackStateQueryReq.
         * @memberof CLPF
         * @interface IFeedbackStateQueryReq
         */

        /**
         * Constructs a new FeedbackStateQueryReq.
         * @memberof CLPF
         * @classdesc Represents a FeedbackStateQueryReq.
         * @implements IFeedbackStateQueryReq
         * @constructor
         * @param {CLPF.IFeedbackStateQueryReq=} [properties] Properties to set
         */
        function FeedbackStateQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeedbackStateQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {CLPF.IFeedbackStateQueryReq=} [properties] Properties to set
         * @returns {CLPF.FeedbackStateQueryReq} FeedbackStateQueryReq instance
         */
        FeedbackStateQueryReq.create = function create(properties) {
            return new FeedbackStateQueryReq(properties);
        };

        /**
         * Encodes the specified FeedbackStateQueryReq message. Does not implicitly {@link CLPF.FeedbackStateQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {CLPF.IFeedbackStateQueryReq} message FeedbackStateQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackStateQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeedbackStateQueryReq message, length delimited. Does not implicitly {@link CLPF.FeedbackStateQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {CLPF.IFeedbackStateQueryReq} message FeedbackStateQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackStateQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackStateQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackStateQueryReq} FeedbackStateQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackStateQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackStateQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackStateQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackStateQueryReq} FeedbackStateQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackStateQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackStateQueryReq message.
         * @function verify
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackStateQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeedbackStateQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackStateQueryReq} FeedbackStateQueryReq
         */
        FeedbackStateQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackStateQueryReq)
                return object;
            return new $root.CLPF.FeedbackStateQueryReq();
        };

        /**
         * Creates a plain object from a FeedbackStateQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackStateQueryReq
         * @static
         * @param {CLPF.FeedbackStateQueryReq} message FeedbackStateQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackStateQueryReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeedbackStateQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackStateQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackStateQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackStateQueryReq;
    })();

    CLPF.FeedbackStateQueryAck = (function() {

        /**
         * Properties of a FeedbackStateQueryAck.
         * @memberof CLPF
         * @interface IFeedbackStateQueryAck
         * @property {number|null} [errcode] FeedbackStateQueryAck errcode
         * @property {number|null} [unreadCount] FeedbackStateQueryAck unreadCount
         * @property {number|null} [totalCount] FeedbackStateQueryAck totalCount
         */

        /**
         * Constructs a new FeedbackStateQueryAck.
         * @memberof CLPF
         * @classdesc Represents a FeedbackStateQueryAck.
         * @implements IFeedbackStateQueryAck
         * @constructor
         * @param {CLPF.IFeedbackStateQueryAck=} [properties] Properties to set
         */
        function FeedbackStateQueryAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackStateQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.FeedbackStateQueryAck
         * @instance
         */
        FeedbackStateQueryAck.prototype.errcode = 0;

        /**
         * FeedbackStateQueryAck unreadCount.
         * @member {number} unreadCount
         * @memberof CLPF.FeedbackStateQueryAck
         * @instance
         */
        FeedbackStateQueryAck.prototype.unreadCount = 0;

        /**
         * FeedbackStateQueryAck totalCount.
         * @member {number} totalCount
         * @memberof CLPF.FeedbackStateQueryAck
         * @instance
         */
        FeedbackStateQueryAck.prototype.totalCount = 0;

        /**
         * Creates a new FeedbackStateQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {CLPF.IFeedbackStateQueryAck=} [properties] Properties to set
         * @returns {CLPF.FeedbackStateQueryAck} FeedbackStateQueryAck instance
         */
        FeedbackStateQueryAck.create = function create(properties) {
            return new FeedbackStateQueryAck(properties);
        };

        /**
         * Encodes the specified FeedbackStateQueryAck message. Does not implicitly {@link CLPF.FeedbackStateQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {CLPF.IFeedbackStateQueryAck} message FeedbackStateQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackStateQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.unreadCount != null && Object.hasOwnProperty.call(message, "unreadCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unreadCount);
            if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.totalCount);
            return writer;
        };

        /**
         * Encodes the specified FeedbackStateQueryAck message, length delimited. Does not implicitly {@link CLPF.FeedbackStateQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {CLPF.IFeedbackStateQueryAck} message FeedbackStateQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackStateQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackStateQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackStateQueryAck} FeedbackStateQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackStateQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackStateQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.unreadCount = reader.int32();
                    break;
                case 3:
                    message.totalCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackStateQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackStateQueryAck} FeedbackStateQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackStateQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackStateQueryAck message.
         * @function verify
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackStateQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                if (!$util.isInteger(message.unreadCount))
                    return "unreadCount: integer expected";
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (!$util.isInteger(message.totalCount))
                    return "totalCount: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackStateQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackStateQueryAck} FeedbackStateQueryAck
         */
        FeedbackStateQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackStateQueryAck)
                return object;
            var message = new $root.CLPF.FeedbackStateQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.unreadCount != null)
                message.unreadCount = object.unreadCount | 0;
            if (object.totalCount != null)
                message.totalCount = object.totalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackStateQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackStateQueryAck
         * @static
         * @param {CLPF.FeedbackStateQueryAck} message FeedbackStateQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackStateQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.unreadCount = 0;
                object.totalCount = 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                object.unreadCount = message.unreadCount;
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                object.totalCount = message.totalCount;
            return object;
        };

        /**
         * Converts this FeedbackStateQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackStateQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackStateQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackStateQueryAck;
    })();

    CLPF.FeedbackSubmitReq = (function() {

        /**
         * Properties of a FeedbackSubmitReq.
         * @memberof CLPF
         * @interface IFeedbackSubmitReq
         * @property {string|null} [content] FeedbackSubmitReq content
         */

        /**
         * Constructs a new FeedbackSubmitReq.
         * @memberof CLPF
         * @classdesc Represents a FeedbackSubmitReq.
         * @implements IFeedbackSubmitReq
         * @constructor
         * @param {CLPF.IFeedbackSubmitReq=} [properties] Properties to set
         */
        function FeedbackSubmitReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackSubmitReq content.
         * @member {string} content
         * @memberof CLPF.FeedbackSubmitReq
         * @instance
         */
        FeedbackSubmitReq.prototype.content = "";

        /**
         * Creates a new FeedbackSubmitReq instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {CLPF.IFeedbackSubmitReq=} [properties] Properties to set
         * @returns {CLPF.FeedbackSubmitReq} FeedbackSubmitReq instance
         */
        FeedbackSubmitReq.create = function create(properties) {
            return new FeedbackSubmitReq(properties);
        };

        /**
         * Encodes the specified FeedbackSubmitReq message. Does not implicitly {@link CLPF.FeedbackSubmitReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {CLPF.IFeedbackSubmitReq} message FeedbackSubmitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackSubmitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified FeedbackSubmitReq message, length delimited. Does not implicitly {@link CLPF.FeedbackSubmitReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {CLPF.IFeedbackSubmitReq} message FeedbackSubmitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackSubmitReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackSubmitReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackSubmitReq} FeedbackSubmitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackSubmitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackSubmitReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackSubmitReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackSubmitReq} FeedbackSubmitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackSubmitReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackSubmitReq message.
         * @function verify
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackSubmitReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a FeedbackSubmitReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackSubmitReq} FeedbackSubmitReq
         */
        FeedbackSubmitReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackSubmitReq)
                return object;
            var message = new $root.CLPF.FeedbackSubmitReq();
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a FeedbackSubmitReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackSubmitReq
         * @static
         * @param {CLPF.FeedbackSubmitReq} message FeedbackSubmitReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackSubmitReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.content = "";
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this FeedbackSubmitReq to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackSubmitReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackSubmitReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackSubmitReq;
    })();

    CLPF.FeedbackSubmitAck = (function() {

        /**
         * Properties of a FeedbackSubmitAck.
         * @memberof CLPF
         * @interface IFeedbackSubmitAck
         * @property {number|null} [errcode] FeedbackSubmitAck errcode
         * @property {number|null} [id] FeedbackSubmitAck id
         * @property {number|null} [timestamp] FeedbackSubmitAck timestamp
         */

        /**
         * Constructs a new FeedbackSubmitAck.
         * @memberof CLPF
         * @classdesc Represents a FeedbackSubmitAck.
         * @implements IFeedbackSubmitAck
         * @constructor
         * @param {CLPF.IFeedbackSubmitAck=} [properties] Properties to set
         */
        function FeedbackSubmitAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackSubmitAck errcode.
         * @member {number} errcode
         * @memberof CLPF.FeedbackSubmitAck
         * @instance
         */
        FeedbackSubmitAck.prototype.errcode = 0;

        /**
         * FeedbackSubmitAck id.
         * @member {number} id
         * @memberof CLPF.FeedbackSubmitAck
         * @instance
         */
        FeedbackSubmitAck.prototype.id = 0;

        /**
         * FeedbackSubmitAck timestamp.
         * @member {number} timestamp
         * @memberof CLPF.FeedbackSubmitAck
         * @instance
         */
        FeedbackSubmitAck.prototype.timestamp = 0;

        /**
         * Creates a new FeedbackSubmitAck instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {CLPF.IFeedbackSubmitAck=} [properties] Properties to set
         * @returns {CLPF.FeedbackSubmitAck} FeedbackSubmitAck instance
         */
        FeedbackSubmitAck.create = function create(properties) {
            return new FeedbackSubmitAck(properties);
        };

        /**
         * Encodes the specified FeedbackSubmitAck message. Does not implicitly {@link CLPF.FeedbackSubmitAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {CLPF.IFeedbackSubmitAck} message FeedbackSubmitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackSubmitAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified FeedbackSubmitAck message, length delimited. Does not implicitly {@link CLPF.FeedbackSubmitAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {CLPF.IFeedbackSubmitAck} message FeedbackSubmitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackSubmitAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackSubmitAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackSubmitAck} FeedbackSubmitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackSubmitAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackSubmitAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.id = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackSubmitAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackSubmitAck} FeedbackSubmitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackSubmitAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackSubmitAck message.
         * @function verify
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackSubmitAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackSubmitAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackSubmitAck} FeedbackSubmitAck
         */
        FeedbackSubmitAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackSubmitAck)
                return object;
            var message = new $root.CLPF.FeedbackSubmitAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackSubmitAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackSubmitAck
         * @static
         * @param {CLPF.FeedbackSubmitAck} message FeedbackSubmitAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackSubmitAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.id = 0;
                object.timestamp = 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };

        /**
         * Converts this FeedbackSubmitAck to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackSubmitAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackSubmitAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackSubmitAck;
    })();

    CLPF.FeedbackItem = (function() {

        /**
         * Properties of a FeedbackItem.
         * @memberof CLPF
         * @interface IFeedbackItem
         * @property {number|null} [id] FeedbackItem id
         * @property {string|null} [submitContent] FeedbackItem submitContent
         * @property {number|null} [submitTime] FeedbackItem submitTime
         * @property {number|null} [state] FeedbackItem state
         * @property {string|null} [replyContent] FeedbackItem replyContent
         * @property {number|null} [replyTime] FeedbackItem replyTime
         */

        /**
         * Constructs a new FeedbackItem.
         * @memberof CLPF
         * @classdesc Represents a FeedbackItem.
         * @implements IFeedbackItem
         * @constructor
         * @param {CLPF.IFeedbackItem=} [properties] Properties to set
         */
        function FeedbackItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackItem id.
         * @member {number} id
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.id = 0;

        /**
         * FeedbackItem submitContent.
         * @member {string} submitContent
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.submitContent = "";

        /**
         * FeedbackItem submitTime.
         * @member {number} submitTime
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.submitTime = 0;

        /**
         * FeedbackItem state.
         * @member {number} state
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.state = 0;

        /**
         * FeedbackItem replyContent.
         * @member {string} replyContent
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.replyContent = "";

        /**
         * FeedbackItem replyTime.
         * @member {number} replyTime
         * @memberof CLPF.FeedbackItem
         * @instance
         */
        FeedbackItem.prototype.replyTime = 0;

        /**
         * Creates a new FeedbackItem instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {CLPF.IFeedbackItem=} [properties] Properties to set
         * @returns {CLPF.FeedbackItem} FeedbackItem instance
         */
        FeedbackItem.create = function create(properties) {
            return new FeedbackItem(properties);
        };

        /**
         * Encodes the specified FeedbackItem message. Does not implicitly {@link CLPF.FeedbackItem.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {CLPF.IFeedbackItem} message FeedbackItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.submitContent != null && Object.hasOwnProperty.call(message, "submitContent"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.submitContent);
            if (message.submitTime != null && Object.hasOwnProperty.call(message, "submitTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.submitTime);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.state);
            if (message.replyContent != null && Object.hasOwnProperty.call(message, "replyContent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.replyContent);
            if (message.replyTime != null && Object.hasOwnProperty.call(message, "replyTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.replyTime);
            return writer;
        };

        /**
         * Encodes the specified FeedbackItem message, length delimited. Does not implicitly {@link CLPF.FeedbackItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {CLPF.IFeedbackItem} message FeedbackItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackItem message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackItem} FeedbackItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.submitContent = reader.string();
                    break;
                case 3:
                    message.submitTime = reader.uint32();
                    break;
                case 4:
                    message.state = reader.int32();
                    break;
                case 5:
                    message.replyContent = reader.string();
                    break;
                case 6:
                    message.replyTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackItem} FeedbackItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackItem message.
         * @function verify
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.submitContent != null && message.hasOwnProperty("submitContent"))
                if (!$util.isString(message.submitContent))
                    return "submitContent: string expected";
            if (message.submitTime != null && message.hasOwnProperty("submitTime"))
                if (!$util.isInteger(message.submitTime))
                    return "submitTime: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.replyContent != null && message.hasOwnProperty("replyContent"))
                if (!$util.isString(message.replyContent))
                    return "replyContent: string expected";
            if (message.replyTime != null && message.hasOwnProperty("replyTime"))
                if (!$util.isInteger(message.replyTime))
                    return "replyTime: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackItem} FeedbackItem
         */
        FeedbackItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackItem)
                return object;
            var message = new $root.CLPF.FeedbackItem();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.submitContent != null)
                message.submitContent = String(object.submitContent);
            if (object.submitTime != null)
                message.submitTime = object.submitTime >>> 0;
            if (object.state != null)
                message.state = object.state | 0;
            if (object.replyContent != null)
                message.replyContent = String(object.replyContent);
            if (object.replyTime != null)
                message.replyTime = object.replyTime >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackItem
         * @static
         * @param {CLPF.FeedbackItem} message FeedbackItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.submitContent = "";
                object.submitTime = 0;
                object.state = 0;
                object.replyContent = "";
                object.replyTime = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.submitContent != null && message.hasOwnProperty("submitContent"))
                object.submitContent = message.submitContent;
            if (message.submitTime != null && message.hasOwnProperty("submitTime"))
                object.submitTime = message.submitTime;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.replyContent != null && message.hasOwnProperty("replyContent"))
                object.replyContent = message.replyContent;
            if (message.replyTime != null && message.hasOwnProperty("replyTime"))
                object.replyTime = message.replyTime;
            return object;
        };

        /**
         * Converts this FeedbackItem to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackItem;
    })();

    CLPF.FeedbackListQueryReq = (function() {

        /**
         * Properties of a FeedbackListQueryReq.
         * @memberof CLPF
         * @interface IFeedbackListQueryReq
         * @property {number|null} [pageIndex] FeedbackListQueryReq pageIndex
         * @property {number|null} [pageCount] FeedbackListQueryReq pageCount
         */

        /**
         * Constructs a new FeedbackListQueryReq.
         * @memberof CLPF
         * @classdesc Represents a FeedbackListQueryReq.
         * @implements IFeedbackListQueryReq
         * @constructor
         * @param {CLPF.IFeedbackListQueryReq=} [properties] Properties to set
         */
        function FeedbackListQueryReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackListQueryReq pageIndex.
         * @member {number} pageIndex
         * @memberof CLPF.FeedbackListQueryReq
         * @instance
         */
        FeedbackListQueryReq.prototype.pageIndex = 0;

        /**
         * FeedbackListQueryReq pageCount.
         * @member {number} pageCount
         * @memberof CLPF.FeedbackListQueryReq
         * @instance
         */
        FeedbackListQueryReq.prototype.pageCount = 0;

        /**
         * Creates a new FeedbackListQueryReq instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {CLPF.IFeedbackListQueryReq=} [properties] Properties to set
         * @returns {CLPF.FeedbackListQueryReq} FeedbackListQueryReq instance
         */
        FeedbackListQueryReq.create = function create(properties) {
            return new FeedbackListQueryReq(properties);
        };

        /**
         * Encodes the specified FeedbackListQueryReq message. Does not implicitly {@link CLPF.FeedbackListQueryReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {CLPF.IFeedbackListQueryReq} message FeedbackListQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackListQueryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pageIndex != null && Object.hasOwnProperty.call(message, "pageIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageIndex);
            if (message.pageCount != null && Object.hasOwnProperty.call(message, "pageCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pageCount);
            return writer;
        };

        /**
         * Encodes the specified FeedbackListQueryReq message, length delimited. Does not implicitly {@link CLPF.FeedbackListQueryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {CLPF.IFeedbackListQueryReq} message FeedbackListQueryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackListQueryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackListQueryReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackListQueryReq} FeedbackListQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackListQueryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackListQueryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pageIndex = reader.int32();
                    break;
                case 2:
                    message.pageCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackListQueryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackListQueryReq} FeedbackListQueryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackListQueryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackListQueryReq message.
         * @function verify
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackListQueryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pageIndex != null && message.hasOwnProperty("pageIndex"))
                if (!$util.isInteger(message.pageIndex))
                    return "pageIndex: integer expected";
            if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                if (!$util.isInteger(message.pageCount))
                    return "pageCount: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackListQueryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackListQueryReq} FeedbackListQueryReq
         */
        FeedbackListQueryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackListQueryReq)
                return object;
            var message = new $root.CLPF.FeedbackListQueryReq();
            if (object.pageIndex != null)
                message.pageIndex = object.pageIndex | 0;
            if (object.pageCount != null)
                message.pageCount = object.pageCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackListQueryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackListQueryReq
         * @static
         * @param {CLPF.FeedbackListQueryReq} message FeedbackListQueryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackListQueryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pageIndex = 0;
                object.pageCount = 0;
            }
            if (message.pageIndex != null && message.hasOwnProperty("pageIndex"))
                object.pageIndex = message.pageIndex;
            if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                object.pageCount = message.pageCount;
            return object;
        };

        /**
         * Converts this FeedbackListQueryReq to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackListQueryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackListQueryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackListQueryReq;
    })();

    CLPF.FeedbackListQueryAck = (function() {

        /**
         * Properties of a FeedbackListQueryAck.
         * @memberof CLPF
         * @interface IFeedbackListQueryAck
         * @property {number|null} [errcode] FeedbackListQueryAck errcode
         * @property {Array.<CLPF.IFeedbackItem>|null} [items] FeedbackListQueryAck items
         */

        /**
         * Constructs a new FeedbackListQueryAck.
         * @memberof CLPF
         * @classdesc Represents a FeedbackListQueryAck.
         * @implements IFeedbackListQueryAck
         * @constructor
         * @param {CLPF.IFeedbackListQueryAck=} [properties] Properties to set
         */
        function FeedbackListQueryAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackListQueryAck errcode.
         * @member {number} errcode
         * @memberof CLPF.FeedbackListQueryAck
         * @instance
         */
        FeedbackListQueryAck.prototype.errcode = 0;

        /**
         * FeedbackListQueryAck items.
         * @member {Array.<CLPF.IFeedbackItem>} items
         * @memberof CLPF.FeedbackListQueryAck
         * @instance
         */
        FeedbackListQueryAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new FeedbackListQueryAck instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {CLPF.IFeedbackListQueryAck=} [properties] Properties to set
         * @returns {CLPF.FeedbackListQueryAck} FeedbackListQueryAck instance
         */
        FeedbackListQueryAck.create = function create(properties) {
            return new FeedbackListQueryAck(properties);
        };

        /**
         * Encodes the specified FeedbackListQueryAck message. Does not implicitly {@link CLPF.FeedbackListQueryAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {CLPF.IFeedbackListQueryAck} message FeedbackListQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackListQueryAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.FeedbackItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedbackListQueryAck message, length delimited. Does not implicitly {@link CLPF.FeedbackListQueryAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {CLPF.IFeedbackListQueryAck} message FeedbackListQueryAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackListQueryAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackListQueryAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackListQueryAck} FeedbackListQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackListQueryAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackListQueryAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.FeedbackItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackListQueryAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackListQueryAck} FeedbackListQueryAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackListQueryAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackListQueryAck message.
         * @function verify
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackListQueryAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.FeedbackItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FeedbackListQueryAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackListQueryAck} FeedbackListQueryAck
         */
        FeedbackListQueryAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackListQueryAck)
                return object;
            var message = new $root.CLPF.FeedbackListQueryAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.FeedbackListQueryAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.FeedbackListQueryAck.items: object expected");
                    message.items[i] = $root.CLPF.FeedbackItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedbackListQueryAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackListQueryAck
         * @static
         * @param {CLPF.FeedbackListQueryAck} message FeedbackListQueryAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackListQueryAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.FeedbackItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this FeedbackListQueryAck to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackListQueryAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackListQueryAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackListQueryAck;
    })();

    CLPF.FeedbackReadReq = (function() {

        /**
         * Properties of a FeedbackReadReq.
         * @memberof CLPF
         * @interface IFeedbackReadReq
         * @property {number|null} [id] FeedbackReadReq id
         */

        /**
         * Constructs a new FeedbackReadReq.
         * @memberof CLPF
         * @classdesc Represents a FeedbackReadReq.
         * @implements IFeedbackReadReq
         * @constructor
         * @param {CLPF.IFeedbackReadReq=} [properties] Properties to set
         */
        function FeedbackReadReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackReadReq id.
         * @member {number} id
         * @memberof CLPF.FeedbackReadReq
         * @instance
         */
        FeedbackReadReq.prototype.id = 0;

        /**
         * Creates a new FeedbackReadReq instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {CLPF.IFeedbackReadReq=} [properties] Properties to set
         * @returns {CLPF.FeedbackReadReq} FeedbackReadReq instance
         */
        FeedbackReadReq.create = function create(properties) {
            return new FeedbackReadReq(properties);
        };

        /**
         * Encodes the specified FeedbackReadReq message. Does not implicitly {@link CLPF.FeedbackReadReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {CLPF.IFeedbackReadReq} message FeedbackReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReadReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified FeedbackReadReq message, length delimited. Does not implicitly {@link CLPF.FeedbackReadReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {CLPF.IFeedbackReadReq} message FeedbackReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReadReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackReadReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackReadReq} FeedbackReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReadReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackReadReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackReadReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackReadReq} FeedbackReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReadReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackReadReq message.
         * @function verify
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackReadReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackReadReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackReadReq} FeedbackReadReq
         */
        FeedbackReadReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackReadReq)
                return object;
            var message = new $root.CLPF.FeedbackReadReq();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackReadReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackReadReq
         * @static
         * @param {CLPF.FeedbackReadReq} message FeedbackReadReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackReadReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this FeedbackReadReq to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackReadReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackReadReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackReadReq;
    })();

    CLPF.FeedbackReadAck = (function() {

        /**
         * Properties of a FeedbackReadAck.
         * @memberof CLPF
         * @interface IFeedbackReadAck
         * @property {number|null} [errcode] FeedbackReadAck errcode
         */

        /**
         * Constructs a new FeedbackReadAck.
         * @memberof CLPF
         * @classdesc Represents a FeedbackReadAck.
         * @implements IFeedbackReadAck
         * @constructor
         * @param {CLPF.IFeedbackReadAck=} [properties] Properties to set
         */
        function FeedbackReadAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackReadAck errcode.
         * @member {number} errcode
         * @memberof CLPF.FeedbackReadAck
         * @instance
         */
        FeedbackReadAck.prototype.errcode = 0;

        /**
         * Creates a new FeedbackReadAck instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {CLPF.IFeedbackReadAck=} [properties] Properties to set
         * @returns {CLPF.FeedbackReadAck} FeedbackReadAck instance
         */
        FeedbackReadAck.create = function create(properties) {
            return new FeedbackReadAck(properties);
        };

        /**
         * Encodes the specified FeedbackReadAck message. Does not implicitly {@link CLPF.FeedbackReadAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {CLPF.IFeedbackReadAck} message FeedbackReadAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReadAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified FeedbackReadAck message, length delimited. Does not implicitly {@link CLPF.FeedbackReadAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {CLPF.IFeedbackReadAck} message FeedbackReadAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReadAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackReadAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackReadAck} FeedbackReadAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReadAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackReadAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackReadAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackReadAck} FeedbackReadAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReadAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackReadAck message.
         * @function verify
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackReadAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a FeedbackReadAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackReadAck} FeedbackReadAck
         */
        FeedbackReadAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackReadAck)
                return object;
            var message = new $root.CLPF.FeedbackReadAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a FeedbackReadAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackReadAck
         * @static
         * @param {CLPF.FeedbackReadAck} message FeedbackReadAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackReadAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this FeedbackReadAck to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackReadAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackReadAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackReadAck;
    })();

    CLPF.FeedbackReplyNtf = (function() {

        /**
         * Properties of a FeedbackReplyNtf.
         * @memberof CLPF
         * @interface IFeedbackReplyNtf
         * @property {CLPF.IFeedbackItem|null} [item] FeedbackReplyNtf item
         */

        /**
         * Constructs a new FeedbackReplyNtf.
         * @memberof CLPF
         * @classdesc Represents a FeedbackReplyNtf.
         * @implements IFeedbackReplyNtf
         * @constructor
         * @param {CLPF.IFeedbackReplyNtf=} [properties] Properties to set
         */
        function FeedbackReplyNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackReplyNtf item.
         * @member {CLPF.IFeedbackItem|null|undefined} item
         * @memberof CLPF.FeedbackReplyNtf
         * @instance
         */
        FeedbackReplyNtf.prototype.item = null;

        /**
         * Creates a new FeedbackReplyNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {CLPF.IFeedbackReplyNtf=} [properties] Properties to set
         * @returns {CLPF.FeedbackReplyNtf} FeedbackReplyNtf instance
         */
        FeedbackReplyNtf.create = function create(properties) {
            return new FeedbackReplyNtf(properties);
        };

        /**
         * Encodes the specified FeedbackReplyNtf message. Does not implicitly {@link CLPF.FeedbackReplyNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {CLPF.IFeedbackReplyNtf} message FeedbackReplyNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReplyNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.CLPF.FeedbackItem.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedbackReplyNtf message, length delimited. Does not implicitly {@link CLPF.FeedbackReplyNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {CLPF.IFeedbackReplyNtf} message FeedbackReplyNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackReplyNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackReplyNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.FeedbackReplyNtf} FeedbackReplyNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReplyNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.FeedbackReplyNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.CLPF.FeedbackItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackReplyNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.FeedbackReplyNtf} FeedbackReplyNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackReplyNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackReplyNtf message.
         * @function verify
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackReplyNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.CLPF.FeedbackItem.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a FeedbackReplyNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.FeedbackReplyNtf} FeedbackReplyNtf
         */
        FeedbackReplyNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.FeedbackReplyNtf)
                return object;
            var message = new $root.CLPF.FeedbackReplyNtf();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".CLPF.FeedbackReplyNtf.item: object expected");
                message.item = $root.CLPF.FeedbackItem.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedbackReplyNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.FeedbackReplyNtf
         * @static
         * @param {CLPF.FeedbackReplyNtf} message FeedbackReplyNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackReplyNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.CLPF.FeedbackItem.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this FeedbackReplyNtf to JSON.
         * @function toJSON
         * @memberof CLPF.FeedbackReplyNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackReplyNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedbackReplyNtf;
    })();

    CLPF.AddOperationLogRpt = (function() {

        /**
         * Properties of an AddOperationLogRpt.
         * @memberof CLPF
         * @interface IAddOperationLogRpt
         * @property {string|null} [operationId] AddOperationLogRpt operationId
         * @property {string|null} [param1] AddOperationLogRpt param1
         * @property {string|null} [param2] AddOperationLogRpt param2
         * @property {string|null} [param3] AddOperationLogRpt param3
         * @property {string|null} [param4] AddOperationLogRpt param4
         */

        /**
         * Constructs a new AddOperationLogRpt.
         * @memberof CLPF
         * @classdesc Represents an AddOperationLogRpt.
         * @implements IAddOperationLogRpt
         * @constructor
         * @param {CLPF.IAddOperationLogRpt=} [properties] Properties to set
         */
        function AddOperationLogRpt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddOperationLogRpt operationId.
         * @member {string} operationId
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         */
        AddOperationLogRpt.prototype.operationId = "";

        /**
         * AddOperationLogRpt param1.
         * @member {string} param1
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         */
        AddOperationLogRpt.prototype.param1 = "";

        /**
         * AddOperationLogRpt param2.
         * @member {string} param2
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         */
        AddOperationLogRpt.prototype.param2 = "";

        /**
         * AddOperationLogRpt param3.
         * @member {string} param3
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         */
        AddOperationLogRpt.prototype.param3 = "";

        /**
         * AddOperationLogRpt param4.
         * @member {string} param4
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         */
        AddOperationLogRpt.prototype.param4 = "";

        /**
         * Creates a new AddOperationLogRpt instance using the specified properties.
         * @function create
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {CLPF.IAddOperationLogRpt=} [properties] Properties to set
         * @returns {CLPF.AddOperationLogRpt} AddOperationLogRpt instance
         */
        AddOperationLogRpt.create = function create(properties) {
            return new AddOperationLogRpt(properties);
        };

        /**
         * Encodes the specified AddOperationLogRpt message. Does not implicitly {@link CLPF.AddOperationLogRpt.verify|verify} messages.
         * @function encode
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {CLPF.IAddOperationLogRpt} message AddOperationLogRpt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOperationLogRpt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operationId != null && Object.hasOwnProperty.call(message, "operationId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.operationId);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.param2);
            if (message.param3 != null && Object.hasOwnProperty.call(message, "param3"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.param3);
            if (message.param4 != null && Object.hasOwnProperty.call(message, "param4"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.param4);
            return writer;
        };

        /**
         * Encodes the specified AddOperationLogRpt message, length delimited. Does not implicitly {@link CLPF.AddOperationLogRpt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {CLPF.IAddOperationLogRpt} message AddOperationLogRpt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOperationLogRpt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddOperationLogRpt message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.AddOperationLogRpt} AddOperationLogRpt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOperationLogRpt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.AddOperationLogRpt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operationId = reader.string();
                    break;
                case 2:
                    message.param1 = reader.string();
                    break;
                case 3:
                    message.param2 = reader.string();
                    break;
                case 4:
                    message.param3 = reader.string();
                    break;
                case 5:
                    message.param4 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddOperationLogRpt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.AddOperationLogRpt} AddOperationLogRpt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOperationLogRpt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddOperationLogRpt message.
         * @function verify
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddOperationLogRpt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operationId != null && message.hasOwnProperty("operationId"))
                if (!$util.isString(message.operationId))
                    return "operationId: string expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isString(message.param1))
                    return "param1: string expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isString(message.param2))
                    return "param2: string expected";
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (!$util.isString(message.param3))
                    return "param3: string expected";
            if (message.param4 != null && message.hasOwnProperty("param4"))
                if (!$util.isString(message.param4))
                    return "param4: string expected";
            return null;
        };

        /**
         * Creates an AddOperationLogRpt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.AddOperationLogRpt} AddOperationLogRpt
         */
        AddOperationLogRpt.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.AddOperationLogRpt)
                return object;
            var message = new $root.CLPF.AddOperationLogRpt();
            if (object.operationId != null)
                message.operationId = String(object.operationId);
            if (object.param1 != null)
                message.param1 = String(object.param1);
            if (object.param2 != null)
                message.param2 = String(object.param2);
            if (object.param3 != null)
                message.param3 = String(object.param3);
            if (object.param4 != null)
                message.param4 = String(object.param4);
            return message;
        };

        /**
         * Creates a plain object from an AddOperationLogRpt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.AddOperationLogRpt
         * @static
         * @param {CLPF.AddOperationLogRpt} message AddOperationLogRpt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddOperationLogRpt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.operationId = "";
                object.param1 = "";
                object.param2 = "";
                object.param3 = "";
                object.param4 = "";
            }
            if (message.operationId != null && message.hasOwnProperty("operationId"))
                object.operationId = message.operationId;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                object.param1 = message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                object.param2 = message.param2;
            if (message.param3 != null && message.hasOwnProperty("param3"))
                object.param3 = message.param3;
            if (message.param4 != null && message.hasOwnProperty("param4"))
                object.param4 = message.param4;
            return object;
        };

        /**
         * Converts this AddOperationLogRpt to JSON.
         * @function toJSON
         * @memberof CLPF.AddOperationLogRpt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddOperationLogRpt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddOperationLogRpt;
    })();

    CLPF.PrivateConfig = (function() {

        /**
         * Properties of a PrivateConfig.
         * @memberof CLPF
         * @interface IPrivateConfig
         * @property {number|null} [playCount] PrivateConfig playCount
         * @property {number|Long|null} [scoreCost] PrivateConfig scoreCost
         */

        /**
         * Constructs a new PrivateConfig.
         * @memberof CLPF
         * @classdesc Represents a PrivateConfig.
         * @implements IPrivateConfig
         * @constructor
         * @param {CLPF.IPrivateConfig=} [properties] Properties to set
         */
        function PrivateConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateConfig playCount.
         * @member {number} playCount
         * @memberof CLPF.PrivateConfig
         * @instance
         */
        PrivateConfig.prototype.playCount = 0;

        /**
         * PrivateConfig scoreCost.
         * @member {number|Long} scoreCost
         * @memberof CLPF.PrivateConfig
         * @instance
         */
        PrivateConfig.prototype.scoreCost = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PrivateConfig instance using the specified properties.
         * @function create
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {CLPF.IPrivateConfig=} [properties] Properties to set
         * @returns {CLPF.PrivateConfig} PrivateConfig instance
         */
        PrivateConfig.create = function create(properties) {
            return new PrivateConfig(properties);
        };

        /**
         * Encodes the specified PrivateConfig message. Does not implicitly {@link CLPF.PrivateConfig.verify|verify} messages.
         * @function encode
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {CLPF.IPrivateConfig} message PrivateConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playCount != null && Object.hasOwnProperty.call(message, "playCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playCount);
            if (message.scoreCost != null && Object.hasOwnProperty.call(message, "scoreCost"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.scoreCost);
            return writer;
        };

        /**
         * Encodes the specified PrivateConfig message, length delimited. Does not implicitly {@link CLPF.PrivateConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {CLPF.IPrivateConfig} message PrivateConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateConfig message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.PrivateConfig} PrivateConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.PrivateConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playCount = reader.int32();
                    break;
                case 2:
                    message.scoreCost = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.PrivateConfig} PrivateConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateConfig message.
         * @function verify
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                if (!$util.isInteger(message.playCount))
                    return "playCount: integer expected";
            if (message.scoreCost != null && message.hasOwnProperty("scoreCost"))
                if (!$util.isInteger(message.scoreCost) && !(message.scoreCost && $util.isInteger(message.scoreCost.low) && $util.isInteger(message.scoreCost.high)))
                    return "scoreCost: integer|Long expected";
            return null;
        };

        /**
         * Creates a PrivateConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.PrivateConfig} PrivateConfig
         */
        PrivateConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.PrivateConfig)
                return object;
            var message = new $root.CLPF.PrivateConfig();
            if (object.playCount != null)
                message.playCount = object.playCount | 0;
            if (object.scoreCost != null)
                if ($util.Long)
                    (message.scoreCost = $util.Long.fromValue(object.scoreCost)).unsigned = false;
                else if (typeof object.scoreCost === "string")
                    message.scoreCost = parseInt(object.scoreCost, 10);
                else if (typeof object.scoreCost === "number")
                    message.scoreCost = object.scoreCost;
                else if (typeof object.scoreCost === "object")
                    message.scoreCost = new $util.LongBits(object.scoreCost.low >>> 0, object.scoreCost.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PrivateConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.PrivateConfig
         * @static
         * @param {CLPF.PrivateConfig} message PrivateConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playCount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.scoreCost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.scoreCost = options.longs === String ? "0" : 0;
            }
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                object.playCount = message.playCount;
            if (message.scoreCost != null && message.hasOwnProperty("scoreCost"))
                if (typeof message.scoreCost === "number")
                    object.scoreCost = options.longs === String ? String(message.scoreCost) : message.scoreCost;
                else
                    object.scoreCost = options.longs === String ? $util.Long.prototype.toString.call(message.scoreCost) : options.longs === Number ? new $util.LongBits(message.scoreCost.low >>> 0, message.scoreCost.high >>> 0).toNumber() : message.scoreCost;
            return object;
        };

        /**
         * Converts this PrivateConfig to JSON.
         * @function toJSON
         * @memberof CLPF.PrivateConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrivateConfig;
    })();

    CLPF.PrivateInfo = (function() {

        /**
         * Properties of a PrivateInfo.
         * @memberof CLPF
         * @interface IPrivateInfo
         * @property {string|null} [createUserName] PrivateInfo createUserName
         * @property {number|null} [roomNum] PrivateInfo roomNum
         * @property {number|null} [gameId] PrivateInfo gameId
         * @property {number|null} [roomId] PrivateInfo roomId
         * @property {number|null} [privateType] PrivateInfo privateType
         * @property {number|null} [playerCount] PrivateInfo playerCount
         * @property {number|null} [gameRule] PrivateInfo gameRule
         * @property {number|null} [playCount] PrivateInfo playCount
         * @property {number|null} [finishPlayCount] PrivateInfo finishPlayCount
         */

        /**
         * Constructs a new PrivateInfo.
         * @memberof CLPF
         * @classdesc Represents a PrivateInfo.
         * @implements IPrivateInfo
         * @constructor
         * @param {CLPF.IPrivateInfo=} [properties] Properties to set
         */
        function PrivateInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateInfo createUserName.
         * @member {string} createUserName
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.createUserName = "";

        /**
         * PrivateInfo roomNum.
         * @member {number} roomNum
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.roomNum = 0;

        /**
         * PrivateInfo gameId.
         * @member {number} gameId
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.gameId = 0;

        /**
         * PrivateInfo roomId.
         * @member {number} roomId
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.roomId = 0;

        /**
         * PrivateInfo privateType.
         * @member {number} privateType
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.privateType = 0;

        /**
         * PrivateInfo playerCount.
         * @member {number} playerCount
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.playerCount = 0;

        /**
         * PrivateInfo gameRule.
         * @member {number} gameRule
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.gameRule = 0;

        /**
         * PrivateInfo playCount.
         * @member {number} playCount
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.playCount = 0;

        /**
         * PrivateInfo finishPlayCount.
         * @member {number} finishPlayCount
         * @memberof CLPF.PrivateInfo
         * @instance
         */
        PrivateInfo.prototype.finishPlayCount = 0;

        /**
         * Creates a new PrivateInfo instance using the specified properties.
         * @function create
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {CLPF.IPrivateInfo=} [properties] Properties to set
         * @returns {CLPF.PrivateInfo} PrivateInfo instance
         */
        PrivateInfo.create = function create(properties) {
            return new PrivateInfo(properties);
        };

        /**
         * Encodes the specified PrivateInfo message. Does not implicitly {@link CLPF.PrivateInfo.verify|verify} messages.
         * @function encode
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {CLPF.IPrivateInfo} message PrivateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createUserName != null && Object.hasOwnProperty.call(message, "createUserName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.createUserName);
            if (message.roomNum != null && Object.hasOwnProperty.call(message, "roomNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roomNum);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.roomId);
            if (message.privateType != null && Object.hasOwnProperty.call(message, "privateType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.privateType);
            if (message.playerCount != null && Object.hasOwnProperty.call(message, "playerCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.playerCount);
            if (message.gameRule != null && Object.hasOwnProperty.call(message, "gameRule"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.gameRule);
            if (message.playCount != null && Object.hasOwnProperty.call(message, "playCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.playCount);
            if (message.finishPlayCount != null && Object.hasOwnProperty.call(message, "finishPlayCount"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.finishPlayCount);
            return writer;
        };

        /**
         * Encodes the specified PrivateInfo message, length delimited. Does not implicitly {@link CLPF.PrivateInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {CLPF.IPrivateInfo} message PrivateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.PrivateInfo} PrivateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.PrivateInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.createUserName = reader.string();
                    break;
                case 2:
                    message.roomNum = reader.int32();
                    break;
                case 3:
                    message.gameId = reader.int32();
                    break;
                case 4:
                    message.roomId = reader.int32();
                    break;
                case 5:
                    message.privateType = reader.int32();
                    break;
                case 6:
                    message.playerCount = reader.int32();
                    break;
                case 7:
                    message.gameRule = reader.int32();
                    break;
                case 8:
                    message.playCount = reader.int32();
                    break;
                case 9:
                    message.finishPlayCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.PrivateInfo} PrivateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateInfo message.
         * @function verify
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.createUserName != null && message.hasOwnProperty("createUserName"))
                if (!$util.isString(message.createUserName))
                    return "createUserName: string expected";
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum))
                    return "roomNum: integer expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.privateType != null && message.hasOwnProperty("privateType"))
                if (!$util.isInteger(message.privateType))
                    return "privateType: integer expected";
            if (message.playerCount != null && message.hasOwnProperty("playerCount"))
                if (!$util.isInteger(message.playerCount))
                    return "playerCount: integer expected";
            if (message.gameRule != null && message.hasOwnProperty("gameRule"))
                if (!$util.isInteger(message.gameRule))
                    return "gameRule: integer expected";
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                if (!$util.isInteger(message.playCount))
                    return "playCount: integer expected";
            if (message.finishPlayCount != null && message.hasOwnProperty("finishPlayCount"))
                if (!$util.isInteger(message.finishPlayCount))
                    return "finishPlayCount: integer expected";
            return null;
        };

        /**
         * Creates a PrivateInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.PrivateInfo} PrivateInfo
         */
        PrivateInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.PrivateInfo)
                return object;
            var message = new $root.CLPF.PrivateInfo();
            if (object.createUserName != null)
                message.createUserName = String(object.createUserName);
            if (object.roomNum != null)
                message.roomNum = object.roomNum | 0;
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.privateType != null)
                message.privateType = object.privateType | 0;
            if (object.playerCount != null)
                message.playerCount = object.playerCount | 0;
            if (object.gameRule != null)
                message.gameRule = object.gameRule | 0;
            if (object.playCount != null)
                message.playCount = object.playCount | 0;
            if (object.finishPlayCount != null)
                message.finishPlayCount = object.finishPlayCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a PrivateInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.PrivateInfo
         * @static
         * @param {CLPF.PrivateInfo} message PrivateInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.createUserName = "";
                object.roomNum = 0;
                object.gameId = 0;
                object.roomId = 0;
                object.privateType = 0;
                object.playerCount = 0;
                object.gameRule = 0;
                object.playCount = 0;
                object.finishPlayCount = 0;
            }
            if (message.createUserName != null && message.hasOwnProperty("createUserName"))
                object.createUserName = message.createUserName;
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                object.roomNum = message.roomNum;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.privateType != null && message.hasOwnProperty("privateType"))
                object.privateType = message.privateType;
            if (message.playerCount != null && message.hasOwnProperty("playerCount"))
                object.playerCount = message.playerCount;
            if (message.gameRule != null && message.hasOwnProperty("gameRule"))
                object.gameRule = message.gameRule;
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                object.playCount = message.playCount;
            if (message.finishPlayCount != null && message.hasOwnProperty("finishPlayCount"))
                object.finishPlayCount = message.finishPlayCount;
            return object;
        };

        /**
         * Converts this PrivateInfo to JSON.
         * @function toJSON
         * @memberof CLPF.PrivateInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrivateInfo;
    })();

    CLPF.GetPrivateConfigReq = (function() {

        /**
         * Properties of a GetPrivateConfigReq.
         * @memberof CLPF
         * @interface IGetPrivateConfigReq
         * @property {number|null} [gameId] GetPrivateConfigReq gameId
         */

        /**
         * Constructs a new GetPrivateConfigReq.
         * @memberof CLPF
         * @classdesc Represents a GetPrivateConfigReq.
         * @implements IGetPrivateConfigReq
         * @constructor
         * @param {CLPF.IGetPrivateConfigReq=} [properties] Properties to set
         */
        function GetPrivateConfigReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPrivateConfigReq gameId.
         * @member {number} gameId
         * @memberof CLPF.GetPrivateConfigReq
         * @instance
         */
        GetPrivateConfigReq.prototype.gameId = 0;

        /**
         * Creates a new GetPrivateConfigReq instance using the specified properties.
         * @function create
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {CLPF.IGetPrivateConfigReq=} [properties] Properties to set
         * @returns {CLPF.GetPrivateConfigReq} GetPrivateConfigReq instance
         */
        GetPrivateConfigReq.create = function create(properties) {
            return new GetPrivateConfigReq(properties);
        };

        /**
         * Encodes the specified GetPrivateConfigReq message. Does not implicitly {@link CLPF.GetPrivateConfigReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {CLPF.IGetPrivateConfigReq} message GetPrivateConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPrivateConfigReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified GetPrivateConfigReq message, length delimited. Does not implicitly {@link CLPF.GetPrivateConfigReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {CLPF.IGetPrivateConfigReq} message GetPrivateConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPrivateConfigReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPrivateConfigReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GetPrivateConfigReq} GetPrivateConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPrivateConfigReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GetPrivateConfigReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPrivateConfigReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GetPrivateConfigReq} GetPrivateConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPrivateConfigReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPrivateConfigReq message.
         * @function verify
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPrivateConfigReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            return null;
        };

        /**
         * Creates a GetPrivateConfigReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GetPrivateConfigReq} GetPrivateConfigReq
         */
        GetPrivateConfigReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GetPrivateConfigReq)
                return object;
            var message = new $root.CLPF.GetPrivateConfigReq();
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetPrivateConfigReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GetPrivateConfigReq
         * @static
         * @param {CLPF.GetPrivateConfigReq} message GetPrivateConfigReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPrivateConfigReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.gameId = 0;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this GetPrivateConfigReq to JSON.
         * @function toJSON
         * @memberof CLPF.GetPrivateConfigReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPrivateConfigReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPrivateConfigReq;
    })();

    CLPF.GetPrivateConfigAck = (function() {

        /**
         * Properties of a GetPrivateConfigAck.
         * @memberof CLPF
         * @interface IGetPrivateConfigAck
         * @property {number|null} [errcode] GetPrivateConfigAck errcode
         * @property {number|null} [gameId] GetPrivateConfigAck gameId
         * @property {Array.<CLPF.IPrivateConfig>|null} [items] GetPrivateConfigAck items
         */

        /**
         * Constructs a new GetPrivateConfigAck.
         * @memberof CLPF
         * @classdesc Represents a GetPrivateConfigAck.
         * @implements IGetPrivateConfigAck
         * @constructor
         * @param {CLPF.IGetPrivateConfigAck=} [properties] Properties to set
         */
        function GetPrivateConfigAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPrivateConfigAck errcode.
         * @member {number} errcode
         * @memberof CLPF.GetPrivateConfigAck
         * @instance
         */
        GetPrivateConfigAck.prototype.errcode = 0;

        /**
         * GetPrivateConfigAck gameId.
         * @member {number} gameId
         * @memberof CLPF.GetPrivateConfigAck
         * @instance
         */
        GetPrivateConfigAck.prototype.gameId = 0;

        /**
         * GetPrivateConfigAck items.
         * @member {Array.<CLPF.IPrivateConfig>} items
         * @memberof CLPF.GetPrivateConfigAck
         * @instance
         */
        GetPrivateConfigAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new GetPrivateConfigAck instance using the specified properties.
         * @function create
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {CLPF.IGetPrivateConfigAck=} [properties] Properties to set
         * @returns {CLPF.GetPrivateConfigAck} GetPrivateConfigAck instance
         */
        GetPrivateConfigAck.create = function create(properties) {
            return new GetPrivateConfigAck(properties);
        };

        /**
         * Encodes the specified GetPrivateConfigAck message. Does not implicitly {@link CLPF.GetPrivateConfigAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {CLPF.IGetPrivateConfigAck} message GetPrivateConfigAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPrivateConfigAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.PrivateConfig.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPrivateConfigAck message, length delimited. Does not implicitly {@link CLPF.GetPrivateConfigAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {CLPF.IGetPrivateConfigAck} message GetPrivateConfigAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPrivateConfigAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPrivateConfigAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.GetPrivateConfigAck} GetPrivateConfigAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPrivateConfigAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.GetPrivateConfigAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.PrivateConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPrivateConfigAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.GetPrivateConfigAck} GetPrivateConfigAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPrivateConfigAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPrivateConfigAck message.
         * @function verify
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPrivateConfigAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.PrivateConfig.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetPrivateConfigAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.GetPrivateConfigAck} GetPrivateConfigAck
         */
        GetPrivateConfigAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.GetPrivateConfigAck)
                return object;
            var message = new $root.CLPF.GetPrivateConfigAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.GetPrivateConfigAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.GetPrivateConfigAck.items: object expected");
                    message.items[i] = $root.CLPF.PrivateConfig.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPrivateConfigAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.GetPrivateConfigAck
         * @static
         * @param {CLPF.GetPrivateConfigAck} message GetPrivateConfigAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPrivateConfigAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.errcode = 0;
                object.gameId = 0;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.PrivateConfig.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GetPrivateConfigAck to JSON.
         * @function toJSON
         * @memberof CLPF.GetPrivateConfigAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPrivateConfigAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPrivateConfigAck;
    })();

    CLPF.CreatePrivateInfoReq = (function() {

        /**
         * Properties of a CreatePrivateInfoReq.
         * @memberof CLPF
         * @interface ICreatePrivateInfoReq
         * @property {number|null} [gameId] CreatePrivateInfoReq gameId
         * @property {number|null} [roomId] CreatePrivateInfoReq roomId
         * @property {number|null} [playerCount] CreatePrivateInfoReq playerCount
         * @property {number|null} [privateType] CreatePrivateInfoReq privateType
         * @property {number|null} [playCount] CreatePrivateInfoReq playCount
         * @property {number|null} [gameRule] CreatePrivateInfoReq gameRule
         * @property {number|Long|null} [scoreCost] CreatePrivateInfoReq scoreCost
         * @property {boolean|null} [helpCreate] CreatePrivateInfoReq helpCreate
         */

        /**
         * Constructs a new CreatePrivateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a CreatePrivateInfoReq.
         * @implements ICreatePrivateInfoReq
         * @constructor
         * @param {CLPF.ICreatePrivateInfoReq=} [properties] Properties to set
         */
        function CreatePrivateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePrivateInfoReq gameId.
         * @member {number} gameId
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.gameId = 0;

        /**
         * CreatePrivateInfoReq roomId.
         * @member {number} roomId
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.roomId = 0;

        /**
         * CreatePrivateInfoReq playerCount.
         * @member {number} playerCount
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.playerCount = 0;

        /**
         * CreatePrivateInfoReq privateType.
         * @member {number} privateType
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.privateType = 0;

        /**
         * CreatePrivateInfoReq playCount.
         * @member {number} playCount
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.playCount = 0;

        /**
         * CreatePrivateInfoReq gameRule.
         * @member {number} gameRule
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.gameRule = 0;

        /**
         * CreatePrivateInfoReq scoreCost.
         * @member {number|Long} scoreCost
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.scoreCost = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreatePrivateInfoReq helpCreate.
         * @member {boolean} helpCreate
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         */
        CreatePrivateInfoReq.prototype.helpCreate = false;

        /**
         * Creates a new CreatePrivateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {CLPF.ICreatePrivateInfoReq=} [properties] Properties to set
         * @returns {CLPF.CreatePrivateInfoReq} CreatePrivateInfoReq instance
         */
        CreatePrivateInfoReq.create = function create(properties) {
            return new CreatePrivateInfoReq(properties);
        };

        /**
         * Encodes the specified CreatePrivateInfoReq message. Does not implicitly {@link CLPF.CreatePrivateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {CLPF.ICreatePrivateInfoReq} message CreatePrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePrivateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roomId);
            if (message.playerCount != null && Object.hasOwnProperty.call(message, "playerCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.playerCount);
            if (message.privateType != null && Object.hasOwnProperty.call(message, "privateType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.privateType);
            if (message.playCount != null && Object.hasOwnProperty.call(message, "playCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.playCount);
            if (message.gameRule != null && Object.hasOwnProperty.call(message, "gameRule"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.gameRule);
            if (message.scoreCost != null && Object.hasOwnProperty.call(message, "scoreCost"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.scoreCost);
            if (message.helpCreate != null && Object.hasOwnProperty.call(message, "helpCreate"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.helpCreate);
            return writer;
        };

        /**
         * Encodes the specified CreatePrivateInfoReq message, length delimited. Does not implicitly {@link CLPF.CreatePrivateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {CLPF.ICreatePrivateInfoReq} message CreatePrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePrivateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePrivateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.CreatePrivateInfoReq} CreatePrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePrivateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.CreatePrivateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameId = reader.int32();
                    break;
                case 2:
                    message.roomId = reader.int32();
                    break;
                case 3:
                    message.playerCount = reader.int32();
                    break;
                case 4:
                    message.privateType = reader.int32();
                    break;
                case 5:
                    message.playCount = reader.int32();
                    break;
                case 6:
                    message.gameRule = reader.int32();
                    break;
                case 7:
                    message.scoreCost = reader.int64();
                    break;
                case 8:
                    message.helpCreate = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePrivateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.CreatePrivateInfoReq} CreatePrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePrivateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePrivateInfoReq message.
         * @function verify
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePrivateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.playerCount != null && message.hasOwnProperty("playerCount"))
                if (!$util.isInteger(message.playerCount))
                    return "playerCount: integer expected";
            if (message.privateType != null && message.hasOwnProperty("privateType"))
                if (!$util.isInteger(message.privateType))
                    return "privateType: integer expected";
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                if (!$util.isInteger(message.playCount))
                    return "playCount: integer expected";
            if (message.gameRule != null && message.hasOwnProperty("gameRule"))
                if (!$util.isInteger(message.gameRule))
                    return "gameRule: integer expected";
            if (message.scoreCost != null && message.hasOwnProperty("scoreCost"))
                if (!$util.isInteger(message.scoreCost) && !(message.scoreCost && $util.isInteger(message.scoreCost.low) && $util.isInteger(message.scoreCost.high)))
                    return "scoreCost: integer|Long expected";
            if (message.helpCreate != null && message.hasOwnProperty("helpCreate"))
                if (typeof message.helpCreate !== "boolean")
                    return "helpCreate: boolean expected";
            return null;
        };

        /**
         * Creates a CreatePrivateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.CreatePrivateInfoReq} CreatePrivateInfoReq
         */
        CreatePrivateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.CreatePrivateInfoReq)
                return object;
            var message = new $root.CLPF.CreatePrivateInfoReq();
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.playerCount != null)
                message.playerCount = object.playerCount | 0;
            if (object.privateType != null)
                message.privateType = object.privateType | 0;
            if (object.playCount != null)
                message.playCount = object.playCount | 0;
            if (object.gameRule != null)
                message.gameRule = object.gameRule | 0;
            if (object.scoreCost != null)
                if ($util.Long)
                    (message.scoreCost = $util.Long.fromValue(object.scoreCost)).unsigned = false;
                else if (typeof object.scoreCost === "string")
                    message.scoreCost = parseInt(object.scoreCost, 10);
                else if (typeof object.scoreCost === "number")
                    message.scoreCost = object.scoreCost;
                else if (typeof object.scoreCost === "object")
                    message.scoreCost = new $util.LongBits(object.scoreCost.low >>> 0, object.scoreCost.high >>> 0).toNumber();
            if (object.helpCreate != null)
                message.helpCreate = Boolean(object.helpCreate);
            return message;
        };

        /**
         * Creates a plain object from a CreatePrivateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.CreatePrivateInfoReq
         * @static
         * @param {CLPF.CreatePrivateInfoReq} message CreatePrivateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePrivateInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gameId = 0;
                object.roomId = 0;
                object.playerCount = 0;
                object.privateType = 0;
                object.playCount = 0;
                object.gameRule = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.scoreCost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.scoreCost = options.longs === String ? "0" : 0;
                object.helpCreate = false;
            }
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.playerCount != null && message.hasOwnProperty("playerCount"))
                object.playerCount = message.playerCount;
            if (message.privateType != null && message.hasOwnProperty("privateType"))
                object.privateType = message.privateType;
            if (message.playCount != null && message.hasOwnProperty("playCount"))
                object.playCount = message.playCount;
            if (message.gameRule != null && message.hasOwnProperty("gameRule"))
                object.gameRule = message.gameRule;
            if (message.scoreCost != null && message.hasOwnProperty("scoreCost"))
                if (typeof message.scoreCost === "number")
                    object.scoreCost = options.longs === String ? String(message.scoreCost) : message.scoreCost;
                else
                    object.scoreCost = options.longs === String ? $util.Long.prototype.toString.call(message.scoreCost) : options.longs === Number ? new $util.LongBits(message.scoreCost.low >>> 0, message.scoreCost.high >>> 0).toNumber() : message.scoreCost;
            if (message.helpCreate != null && message.hasOwnProperty("helpCreate"))
                object.helpCreate = message.helpCreate;
            return object;
        };

        /**
         * Converts this CreatePrivateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.CreatePrivateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePrivateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatePrivateInfoReq;
    })();

    CLPF.CreatePrivateInfoAck = (function() {

        /**
         * Properties of a CreatePrivateInfoAck.
         * @memberof CLPF
         * @interface ICreatePrivateInfoAck
         * @property {number|null} [errcode] CreatePrivateInfoAck errcode
         * @property {number|null} [roomNum] CreatePrivateInfoAck roomNum
         * @property {boolean|null} [helpCreate] CreatePrivateInfoAck helpCreate
         */

        /**
         * Constructs a new CreatePrivateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a CreatePrivateInfoAck.
         * @implements ICreatePrivateInfoAck
         * @constructor
         * @param {CLPF.ICreatePrivateInfoAck=} [properties] Properties to set
         */
        function CreatePrivateInfoAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePrivateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.CreatePrivateInfoAck
         * @instance
         */
        CreatePrivateInfoAck.prototype.errcode = 0;

        /**
         * CreatePrivateInfoAck roomNum.
         * @member {number} roomNum
         * @memberof CLPF.CreatePrivateInfoAck
         * @instance
         */
        CreatePrivateInfoAck.prototype.roomNum = 0;

        /**
         * CreatePrivateInfoAck helpCreate.
         * @member {boolean} helpCreate
         * @memberof CLPF.CreatePrivateInfoAck
         * @instance
         */
        CreatePrivateInfoAck.prototype.helpCreate = false;

        /**
         * Creates a new CreatePrivateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {CLPF.ICreatePrivateInfoAck=} [properties] Properties to set
         * @returns {CLPF.CreatePrivateInfoAck} CreatePrivateInfoAck instance
         */
        CreatePrivateInfoAck.create = function create(properties) {
            return new CreatePrivateInfoAck(properties);
        };

        /**
         * Encodes the specified CreatePrivateInfoAck message. Does not implicitly {@link CLPF.CreatePrivateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {CLPF.ICreatePrivateInfoAck} message CreatePrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePrivateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.roomNum != null && Object.hasOwnProperty.call(message, "roomNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roomNum);
            if (message.helpCreate != null && Object.hasOwnProperty.call(message, "helpCreate"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.helpCreate);
            return writer;
        };

        /**
         * Encodes the specified CreatePrivateInfoAck message, length delimited. Does not implicitly {@link CLPF.CreatePrivateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {CLPF.ICreatePrivateInfoAck} message CreatePrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePrivateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePrivateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.CreatePrivateInfoAck} CreatePrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePrivateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.CreatePrivateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.roomNum = reader.int32();
                    break;
                case 3:
                    message.helpCreate = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePrivateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.CreatePrivateInfoAck} CreatePrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePrivateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePrivateInfoAck message.
         * @function verify
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePrivateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum))
                    return "roomNum: integer expected";
            if (message.helpCreate != null && message.hasOwnProperty("helpCreate"))
                if (typeof message.helpCreate !== "boolean")
                    return "helpCreate: boolean expected";
            return null;
        };

        /**
         * Creates a CreatePrivateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.CreatePrivateInfoAck} CreatePrivateInfoAck
         */
        CreatePrivateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.CreatePrivateInfoAck)
                return object;
            var message = new $root.CLPF.CreatePrivateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.roomNum != null)
                message.roomNum = object.roomNum | 0;
            if (object.helpCreate != null)
                message.helpCreate = Boolean(object.helpCreate);
            return message;
        };

        /**
         * Creates a plain object from a CreatePrivateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.CreatePrivateInfoAck
         * @static
         * @param {CLPF.CreatePrivateInfoAck} message CreatePrivateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePrivateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.roomNum = 0;
                object.helpCreate = false;
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                object.roomNum = message.roomNum;
            if (message.helpCreate != null && message.hasOwnProperty("helpCreate"))
                object.helpCreate = message.helpCreate;
            return object;
        };

        /**
         * Converts this CreatePrivateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.CreatePrivateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePrivateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatePrivateInfoAck;
    })();

    CLPF.JoinPrivateInfoReq = (function() {

        /**
         * Properties of a JoinPrivateInfoReq.
         * @memberof CLPF
         * @interface IJoinPrivateInfoReq
         * @property {number|null} [roomNum] JoinPrivateInfoReq roomNum
         */

        /**
         * Constructs a new JoinPrivateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a JoinPrivateInfoReq.
         * @implements IJoinPrivateInfoReq
         * @constructor
         * @param {CLPF.IJoinPrivateInfoReq=} [properties] Properties to set
         */
        function JoinPrivateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinPrivateInfoReq roomNum.
         * @member {number} roomNum
         * @memberof CLPF.JoinPrivateInfoReq
         * @instance
         */
        JoinPrivateInfoReq.prototype.roomNum = 0;

        /**
         * Creates a new JoinPrivateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {CLPF.IJoinPrivateInfoReq=} [properties] Properties to set
         * @returns {CLPF.JoinPrivateInfoReq} JoinPrivateInfoReq instance
         */
        JoinPrivateInfoReq.create = function create(properties) {
            return new JoinPrivateInfoReq(properties);
        };

        /**
         * Encodes the specified JoinPrivateInfoReq message. Does not implicitly {@link CLPF.JoinPrivateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {CLPF.IJoinPrivateInfoReq} message JoinPrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinPrivateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomNum != null && Object.hasOwnProperty.call(message, "roomNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roomNum);
            return writer;
        };

        /**
         * Encodes the specified JoinPrivateInfoReq message, length delimited. Does not implicitly {@link CLPF.JoinPrivateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {CLPF.IJoinPrivateInfoReq} message JoinPrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinPrivateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinPrivateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.JoinPrivateInfoReq} JoinPrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinPrivateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.JoinPrivateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinPrivateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.JoinPrivateInfoReq} JoinPrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinPrivateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinPrivateInfoReq message.
         * @function verify
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinPrivateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum))
                    return "roomNum: integer expected";
            return null;
        };

        /**
         * Creates a JoinPrivateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.JoinPrivateInfoReq} JoinPrivateInfoReq
         */
        JoinPrivateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.JoinPrivateInfoReq)
                return object;
            var message = new $root.CLPF.JoinPrivateInfoReq();
            if (object.roomNum != null)
                message.roomNum = object.roomNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a JoinPrivateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.JoinPrivateInfoReq
         * @static
         * @param {CLPF.JoinPrivateInfoReq} message JoinPrivateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JoinPrivateInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.roomNum = 0;
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                object.roomNum = message.roomNum;
            return object;
        };

        /**
         * Converts this JoinPrivateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.JoinPrivateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JoinPrivateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return JoinPrivateInfoReq;
    })();

    CLPF.JoinPrivateInfoAck = (function() {

        /**
         * Properties of a JoinPrivateInfoAck.
         * @memberof CLPF
         * @interface IJoinPrivateInfoAck
         * @property {number|null} [errcode] JoinPrivateInfoAck errcode
         * @property {string|null} [errmessage] JoinPrivateInfoAck errmessage
         */

        /**
         * Constructs a new JoinPrivateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a JoinPrivateInfoAck.
         * @implements IJoinPrivateInfoAck
         * @constructor
         * @param {CLPF.IJoinPrivateInfoAck=} [properties] Properties to set
         */
        function JoinPrivateInfoAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinPrivateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.JoinPrivateInfoAck
         * @instance
         */
        JoinPrivateInfoAck.prototype.errcode = 0;

        /**
         * JoinPrivateInfoAck errmessage.
         * @member {string} errmessage
         * @memberof CLPF.JoinPrivateInfoAck
         * @instance
         */
        JoinPrivateInfoAck.prototype.errmessage = "";

        /**
         * Creates a new JoinPrivateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {CLPF.IJoinPrivateInfoAck=} [properties] Properties to set
         * @returns {CLPF.JoinPrivateInfoAck} JoinPrivateInfoAck instance
         */
        JoinPrivateInfoAck.create = function create(properties) {
            return new JoinPrivateInfoAck(properties);
        };

        /**
         * Encodes the specified JoinPrivateInfoAck message. Does not implicitly {@link CLPF.JoinPrivateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {CLPF.IJoinPrivateInfoAck} message JoinPrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinPrivateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.errmessage != null && Object.hasOwnProperty.call(message, "errmessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errmessage);
            return writer;
        };

        /**
         * Encodes the specified JoinPrivateInfoAck message, length delimited. Does not implicitly {@link CLPF.JoinPrivateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {CLPF.IJoinPrivateInfoAck} message JoinPrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinPrivateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinPrivateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.JoinPrivateInfoAck} JoinPrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinPrivateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.JoinPrivateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    message.errmessage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinPrivateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.JoinPrivateInfoAck} JoinPrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinPrivateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinPrivateInfoAck message.
         * @function verify
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinPrivateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                if (!$util.isString(message.errmessage))
                    return "errmessage: string expected";
            return null;
        };

        /**
         * Creates a JoinPrivateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.JoinPrivateInfoAck} JoinPrivateInfoAck
         */
        JoinPrivateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.JoinPrivateInfoAck)
                return object;
            var message = new $root.CLPF.JoinPrivateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.errmessage != null)
                message.errmessage = String(object.errmessage);
            return message;
        };

        /**
         * Creates a plain object from a JoinPrivateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.JoinPrivateInfoAck
         * @static
         * @param {CLPF.JoinPrivateInfoAck} message JoinPrivateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JoinPrivateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.errcode = 0;
                object.errmessage = "";
            }
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.errmessage != null && message.hasOwnProperty("errmessage"))
                object.errmessage = message.errmessage;
            return object;
        };

        /**
         * Converts this JoinPrivateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.JoinPrivateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JoinPrivateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return JoinPrivateInfoAck;
    })();

    CLPF.DismissPirvateInfoReq = (function() {

        /**
         * Properties of a DismissPirvateInfoReq.
         * @memberof CLPF
         * @interface IDismissPirvateInfoReq
         * @property {boolean|null} [bDismiss] DismissPirvateInfoReq bDismiss
         */

        /**
         * Constructs a new DismissPirvateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a DismissPirvateInfoReq.
         * @implements IDismissPirvateInfoReq
         * @constructor
         * @param {CLPF.IDismissPirvateInfoReq=} [properties] Properties to set
         */
        function DismissPirvateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DismissPirvateInfoReq bDismiss.
         * @member {boolean} bDismiss
         * @memberof CLPF.DismissPirvateInfoReq
         * @instance
         */
        DismissPirvateInfoReq.prototype.bDismiss = false;

        /**
         * Creates a new DismissPirvateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {CLPF.IDismissPirvateInfoReq=} [properties] Properties to set
         * @returns {CLPF.DismissPirvateInfoReq} DismissPirvateInfoReq instance
         */
        DismissPirvateInfoReq.create = function create(properties) {
            return new DismissPirvateInfoReq(properties);
        };

        /**
         * Encodes the specified DismissPirvateInfoReq message. Does not implicitly {@link CLPF.DismissPirvateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {CLPF.IDismissPirvateInfoReq} message DismissPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bDismiss != null && Object.hasOwnProperty.call(message, "bDismiss"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bDismiss);
            return writer;
        };

        /**
         * Encodes the specified DismissPirvateInfoReq message, length delimited. Does not implicitly {@link CLPF.DismissPirvateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {CLPF.IDismissPirvateInfoReq} message DismissPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DismissPirvateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.DismissPirvateInfoReq} DismissPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.DismissPirvateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bDismiss = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DismissPirvateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.DismissPirvateInfoReq} DismissPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DismissPirvateInfoReq message.
         * @function verify
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DismissPirvateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bDismiss != null && message.hasOwnProperty("bDismiss"))
                if (typeof message.bDismiss !== "boolean")
                    return "bDismiss: boolean expected";
            return null;
        };

        /**
         * Creates a DismissPirvateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.DismissPirvateInfoReq} DismissPirvateInfoReq
         */
        DismissPirvateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.DismissPirvateInfoReq)
                return object;
            var message = new $root.CLPF.DismissPirvateInfoReq();
            if (object.bDismiss != null)
                message.bDismiss = Boolean(object.bDismiss);
            return message;
        };

        /**
         * Creates a plain object from a DismissPirvateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.DismissPirvateInfoReq
         * @static
         * @param {CLPF.DismissPirvateInfoReq} message DismissPirvateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DismissPirvateInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bDismiss = false;
            if (message.bDismiss != null && message.hasOwnProperty("bDismiss"))
                object.bDismiss = message.bDismiss;
            return object;
        };

        /**
         * Converts this DismissPirvateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.DismissPirvateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DismissPirvateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DismissPirvateInfoReq;
    })();

    CLPF.DismissPirvateInfoAck = (function() {

        /**
         * Properties of a DismissPirvateInfoAck.
         * @memberof CLPF
         * @interface IDismissPirvateInfoAck
         * @property {number|null} [errcode] DismissPirvateInfoAck errcode
         */

        /**
         * Constructs a new DismissPirvateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a DismissPirvateInfoAck.
         * @implements IDismissPirvateInfoAck
         * @constructor
         * @param {CLPF.IDismissPirvateInfoAck=} [properties] Properties to set
         */
        function DismissPirvateInfoAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DismissPirvateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.DismissPirvateInfoAck
         * @instance
         */
        DismissPirvateInfoAck.prototype.errcode = 0;

        /**
         * Creates a new DismissPirvateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {CLPF.IDismissPirvateInfoAck=} [properties] Properties to set
         * @returns {CLPF.DismissPirvateInfoAck} DismissPirvateInfoAck instance
         */
        DismissPirvateInfoAck.create = function create(properties) {
            return new DismissPirvateInfoAck(properties);
        };

        /**
         * Encodes the specified DismissPirvateInfoAck message. Does not implicitly {@link CLPF.DismissPirvateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {CLPF.IDismissPirvateInfoAck} message DismissPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified DismissPirvateInfoAck message, length delimited. Does not implicitly {@link CLPF.DismissPirvateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {CLPF.IDismissPirvateInfoAck} message DismissPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DismissPirvateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.DismissPirvateInfoAck} DismissPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.DismissPirvateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DismissPirvateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.DismissPirvateInfoAck} DismissPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DismissPirvateInfoAck message.
         * @function verify
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DismissPirvateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a DismissPirvateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.DismissPirvateInfoAck} DismissPirvateInfoAck
         */
        DismissPirvateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.DismissPirvateInfoAck)
                return object;
            var message = new $root.CLPF.DismissPirvateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a DismissPirvateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.DismissPirvateInfoAck
         * @static
         * @param {CLPF.DismissPirvateInfoAck} message DismissPirvateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DismissPirvateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this DismissPirvateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.DismissPirvateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DismissPirvateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DismissPirvateInfoAck;
    })();

    CLPF.DismissPirvateInfoNtf = (function() {

        /**
         * Properties of a DismissPirvateInfoNtf.
         * @memberof CLPF
         * @interface IDismissPirvateInfoNtf
         * @property {number|null} [dismissChair] DismissPirvateInfoNtf dismissChair
         * @property {number|null} [leftTime] DismissPirvateInfoNtf leftTime
         * @property {number|null} [agreeCount] DismissPirvateInfoNtf agreeCount
         * @property {Array.<number>|null} [agreeChair] DismissPirvateInfoNtf agreeChair
         * @property {number|null} [notAgreeCount] DismissPirvateInfoNtf notAgreeCount
         * @property {Array.<number>|null} [notAgreeChair] DismissPirvateInfoNtf notAgreeChair
         */

        /**
         * Constructs a new DismissPirvateInfoNtf.
         * @memberof CLPF
         * @classdesc Represents a DismissPirvateInfoNtf.
         * @implements IDismissPirvateInfoNtf
         * @constructor
         * @param {CLPF.IDismissPirvateInfoNtf=} [properties] Properties to set
         */
        function DismissPirvateInfoNtf(properties) {
            this.agreeChair = [];
            this.notAgreeChair = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DismissPirvateInfoNtf dismissChair.
         * @member {number} dismissChair
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.dismissChair = 0;

        /**
         * DismissPirvateInfoNtf leftTime.
         * @member {number} leftTime
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.leftTime = 0;

        /**
         * DismissPirvateInfoNtf agreeCount.
         * @member {number} agreeCount
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.agreeCount = 0;

        /**
         * DismissPirvateInfoNtf agreeChair.
         * @member {Array.<number>} agreeChair
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.agreeChair = $util.emptyArray;

        /**
         * DismissPirvateInfoNtf notAgreeCount.
         * @member {number} notAgreeCount
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.notAgreeCount = 0;

        /**
         * DismissPirvateInfoNtf notAgreeChair.
         * @member {Array.<number>} notAgreeChair
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         */
        DismissPirvateInfoNtf.prototype.notAgreeChair = $util.emptyArray;

        /**
         * Creates a new DismissPirvateInfoNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {CLPF.IDismissPirvateInfoNtf=} [properties] Properties to set
         * @returns {CLPF.DismissPirvateInfoNtf} DismissPirvateInfoNtf instance
         */
        DismissPirvateInfoNtf.create = function create(properties) {
            return new DismissPirvateInfoNtf(properties);
        };

        /**
         * Encodes the specified DismissPirvateInfoNtf message. Does not implicitly {@link CLPF.DismissPirvateInfoNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {CLPF.IDismissPirvateInfoNtf} message DismissPirvateInfoNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dismissChair != null && Object.hasOwnProperty.call(message, "dismissChair"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dismissChair);
            if (message.leftTime != null && Object.hasOwnProperty.call(message, "leftTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.leftTime);
            if (message.agreeCount != null && Object.hasOwnProperty.call(message, "agreeCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.agreeCount);
            if (message.agreeChair != null && message.agreeChair.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.agreeChair.length; ++i)
                    writer.int32(message.agreeChair[i]);
                writer.ldelim();
            }
            if (message.notAgreeCount != null && Object.hasOwnProperty.call(message, "notAgreeCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.notAgreeCount);
            if (message.notAgreeChair != null && message.notAgreeChair.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.notAgreeChair.length; ++i)
                    writer.int32(message.notAgreeChair[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified DismissPirvateInfoNtf message, length delimited. Does not implicitly {@link CLPF.DismissPirvateInfoNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {CLPF.IDismissPirvateInfoNtf} message DismissPirvateInfoNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DismissPirvateInfoNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DismissPirvateInfoNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.DismissPirvateInfoNtf} DismissPirvateInfoNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.DismissPirvateInfoNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dismissChair = reader.int32();
                    break;
                case 2:
                    message.leftTime = reader.int32();
                    break;
                case 3:
                    message.agreeCount = reader.int32();
                    break;
                case 4:
                    if (!(message.agreeChair && message.agreeChair.length))
                        message.agreeChair = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.agreeChair.push(reader.int32());
                    } else
                        message.agreeChair.push(reader.int32());
                    break;
                case 5:
                    message.notAgreeCount = reader.int32();
                    break;
                case 6:
                    if (!(message.notAgreeChair && message.notAgreeChair.length))
                        message.notAgreeChair = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.notAgreeChair.push(reader.int32());
                    } else
                        message.notAgreeChair.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DismissPirvateInfoNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.DismissPirvateInfoNtf} DismissPirvateInfoNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DismissPirvateInfoNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DismissPirvateInfoNtf message.
         * @function verify
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DismissPirvateInfoNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dismissChair != null && message.hasOwnProperty("dismissChair"))
                if (!$util.isInteger(message.dismissChair))
                    return "dismissChair: integer expected";
            if (message.leftTime != null && message.hasOwnProperty("leftTime"))
                if (!$util.isInteger(message.leftTime))
                    return "leftTime: integer expected";
            if (message.agreeCount != null && message.hasOwnProperty("agreeCount"))
                if (!$util.isInteger(message.agreeCount))
                    return "agreeCount: integer expected";
            if (message.agreeChair != null && message.hasOwnProperty("agreeChair")) {
                if (!Array.isArray(message.agreeChair))
                    return "agreeChair: array expected";
                for (var i = 0; i < message.agreeChair.length; ++i)
                    if (!$util.isInteger(message.agreeChair[i]))
                        return "agreeChair: integer[] expected";
            }
            if (message.notAgreeCount != null && message.hasOwnProperty("notAgreeCount"))
                if (!$util.isInteger(message.notAgreeCount))
                    return "notAgreeCount: integer expected";
            if (message.notAgreeChair != null && message.hasOwnProperty("notAgreeChair")) {
                if (!Array.isArray(message.notAgreeChair))
                    return "notAgreeChair: array expected";
                for (var i = 0; i < message.notAgreeChair.length; ++i)
                    if (!$util.isInteger(message.notAgreeChair[i]))
                        return "notAgreeChair: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a DismissPirvateInfoNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.DismissPirvateInfoNtf} DismissPirvateInfoNtf
         */
        DismissPirvateInfoNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.DismissPirvateInfoNtf)
                return object;
            var message = new $root.CLPF.DismissPirvateInfoNtf();
            if (object.dismissChair != null)
                message.dismissChair = object.dismissChair | 0;
            if (object.leftTime != null)
                message.leftTime = object.leftTime | 0;
            if (object.agreeCount != null)
                message.agreeCount = object.agreeCount | 0;
            if (object.agreeChair) {
                if (!Array.isArray(object.agreeChair))
                    throw TypeError(".CLPF.DismissPirvateInfoNtf.agreeChair: array expected");
                message.agreeChair = [];
                for (var i = 0; i < object.agreeChair.length; ++i)
                    message.agreeChair[i] = object.agreeChair[i] | 0;
            }
            if (object.notAgreeCount != null)
                message.notAgreeCount = object.notAgreeCount | 0;
            if (object.notAgreeChair) {
                if (!Array.isArray(object.notAgreeChair))
                    throw TypeError(".CLPF.DismissPirvateInfoNtf.notAgreeChair: array expected");
                message.notAgreeChair = [];
                for (var i = 0; i < object.notAgreeChair.length; ++i)
                    message.notAgreeChair[i] = object.notAgreeChair[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a DismissPirvateInfoNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.DismissPirvateInfoNtf
         * @static
         * @param {CLPF.DismissPirvateInfoNtf} message DismissPirvateInfoNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DismissPirvateInfoNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.agreeChair = [];
                object.notAgreeChair = [];
            }
            if (options.defaults) {
                object.dismissChair = 0;
                object.leftTime = 0;
                object.agreeCount = 0;
                object.notAgreeCount = 0;
            }
            if (message.dismissChair != null && message.hasOwnProperty("dismissChair"))
                object.dismissChair = message.dismissChair;
            if (message.leftTime != null && message.hasOwnProperty("leftTime"))
                object.leftTime = message.leftTime;
            if (message.agreeCount != null && message.hasOwnProperty("agreeCount"))
                object.agreeCount = message.agreeCount;
            if (message.agreeChair && message.agreeChair.length) {
                object.agreeChair = [];
                for (var j = 0; j < message.agreeChair.length; ++j)
                    object.agreeChair[j] = message.agreeChair[j];
            }
            if (message.notAgreeCount != null && message.hasOwnProperty("notAgreeCount"))
                object.notAgreeCount = message.notAgreeCount;
            if (message.notAgreeChair && message.notAgreeChair.length) {
                object.notAgreeChair = [];
                for (var j = 0; j < message.notAgreeChair.length; ++j)
                    object.notAgreeChair[j] = message.notAgreeChair[j];
            }
            return object;
        };

        /**
         * Converts this DismissPirvateInfoNtf to JSON.
         * @function toJSON
         * @memberof CLPF.DismissPirvateInfoNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DismissPirvateInfoNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DismissPirvateInfoNtf;
    })();

    CLPF.PirvateInfoNtf = (function() {

        /**
         * Properties of a PirvateInfoNtf.
         * @memberof CLPF
         * @interface IPirvateInfoNtf
         * @property {CLPF.IPrivateInfo|null} [info] PirvateInfoNtf info
         */

        /**
         * Constructs a new PirvateInfoNtf.
         * @memberof CLPF
         * @classdesc Represents a PirvateInfoNtf.
         * @implements IPirvateInfoNtf
         * @constructor
         * @param {CLPF.IPirvateInfoNtf=} [properties] Properties to set
         */
        function PirvateInfoNtf(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PirvateInfoNtf info.
         * @member {CLPF.IPrivateInfo|null|undefined} info
         * @memberof CLPF.PirvateInfoNtf
         * @instance
         */
        PirvateInfoNtf.prototype.info = null;

        /**
         * Creates a new PirvateInfoNtf instance using the specified properties.
         * @function create
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {CLPF.IPirvateInfoNtf=} [properties] Properties to set
         * @returns {CLPF.PirvateInfoNtf} PirvateInfoNtf instance
         */
        PirvateInfoNtf.create = function create(properties) {
            return new PirvateInfoNtf(properties);
        };

        /**
         * Encodes the specified PirvateInfoNtf message. Does not implicitly {@link CLPF.PirvateInfoNtf.verify|verify} messages.
         * @function encode
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {CLPF.IPirvateInfoNtf} message PirvateInfoNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PirvateInfoNtf.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.CLPF.PrivateInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PirvateInfoNtf message, length delimited. Does not implicitly {@link CLPF.PirvateInfoNtf.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {CLPF.IPirvateInfoNtf} message PirvateInfoNtf message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PirvateInfoNtf.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PirvateInfoNtf message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.PirvateInfoNtf} PirvateInfoNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PirvateInfoNtf.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.PirvateInfoNtf();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.CLPF.PrivateInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PirvateInfoNtf message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.PirvateInfoNtf} PirvateInfoNtf
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PirvateInfoNtf.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PirvateInfoNtf message.
         * @function verify
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PirvateInfoNtf.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.CLPF.PrivateInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            return null;
        };

        /**
         * Creates a PirvateInfoNtf message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.PirvateInfoNtf} PirvateInfoNtf
         */
        PirvateInfoNtf.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.PirvateInfoNtf)
                return object;
            var message = new $root.CLPF.PirvateInfoNtf();
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".CLPF.PirvateInfoNtf.info: object expected");
                message.info = $root.CLPF.PrivateInfo.fromObject(object.info);
            }
            return message;
        };

        /**
         * Creates a plain object from a PirvateInfoNtf message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.PirvateInfoNtf
         * @static
         * @param {CLPF.PirvateInfoNtf} message PirvateInfoNtf
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PirvateInfoNtf.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.info = null;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.CLPF.PrivateInfo.toObject(message.info, options);
            return object;
        };

        /**
         * Converts this PirvateInfoNtf to JSON.
         * @function toJSON
         * @memberof CLPF.PirvateInfoNtf
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PirvateInfoNtf.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PirvateInfoNtf;
    })();

    CLPF.QueryPirvateInfoReq = (function() {

        /**
         * Properties of a QueryPirvateInfoReq.
         * @memberof CLPF
         * @interface IQueryPirvateInfoReq
         */

        /**
         * Constructs a new QueryPirvateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a QueryPirvateInfoReq.
         * @implements IQueryPirvateInfoReq
         * @constructor
         * @param {CLPF.IQueryPirvateInfoReq=} [properties] Properties to set
         */
        function QueryPirvateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new QueryPirvateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {CLPF.IQueryPirvateInfoReq=} [properties] Properties to set
         * @returns {CLPF.QueryPirvateInfoReq} QueryPirvateInfoReq instance
         */
        QueryPirvateInfoReq.create = function create(properties) {
            return new QueryPirvateInfoReq(properties);
        };

        /**
         * Encodes the specified QueryPirvateInfoReq message. Does not implicitly {@link CLPF.QueryPirvateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {CLPF.IQueryPirvateInfoReq} message QueryPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPirvateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified QueryPirvateInfoReq message, length delimited. Does not implicitly {@link CLPF.QueryPirvateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {CLPF.IQueryPirvateInfoReq} message QueryPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPirvateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryPirvateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.QueryPirvateInfoReq} QueryPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPirvateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.QueryPirvateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryPirvateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.QueryPirvateInfoReq} QueryPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPirvateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryPirvateInfoReq message.
         * @function verify
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryPirvateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a QueryPirvateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.QueryPirvateInfoReq} QueryPirvateInfoReq
         */
        QueryPirvateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.QueryPirvateInfoReq)
                return object;
            return new $root.CLPF.QueryPirvateInfoReq();
        };

        /**
         * Creates a plain object from a QueryPirvateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.QueryPirvateInfoReq
         * @static
         * @param {CLPF.QueryPirvateInfoReq} message QueryPirvateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryPirvateInfoReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this QueryPirvateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.QueryPirvateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryPirvateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryPirvateInfoReq;
    })();

    CLPF.QueryPirvateInfoAck = (function() {

        /**
         * Properties of a QueryPirvateInfoAck.
         * @memberof CLPF
         * @interface IQueryPirvateInfoAck
         * @property {number|null} [errcode] QueryPirvateInfoAck errcode
         * @property {Array.<CLPF.IPrivateInfo>|null} [items] QueryPirvateInfoAck items
         */

        /**
         * Constructs a new QueryPirvateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a QueryPirvateInfoAck.
         * @implements IQueryPirvateInfoAck
         * @constructor
         * @param {CLPF.IQueryPirvateInfoAck=} [properties] Properties to set
         */
        function QueryPirvateInfoAck(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryPirvateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.QueryPirvateInfoAck
         * @instance
         */
        QueryPirvateInfoAck.prototype.errcode = 0;

        /**
         * QueryPirvateInfoAck items.
         * @member {Array.<CLPF.IPrivateInfo>} items
         * @memberof CLPF.QueryPirvateInfoAck
         * @instance
         */
        QueryPirvateInfoAck.prototype.items = $util.emptyArray;

        /**
         * Creates a new QueryPirvateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {CLPF.IQueryPirvateInfoAck=} [properties] Properties to set
         * @returns {CLPF.QueryPirvateInfoAck} QueryPirvateInfoAck instance
         */
        QueryPirvateInfoAck.create = function create(properties) {
            return new QueryPirvateInfoAck(properties);
        };

        /**
         * Encodes the specified QueryPirvateInfoAck message. Does not implicitly {@link CLPF.QueryPirvateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {CLPF.IQueryPirvateInfoAck} message QueryPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPirvateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CLPF.PrivateInfo.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryPirvateInfoAck message, length delimited. Does not implicitly {@link CLPF.QueryPirvateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {CLPF.IQueryPirvateInfoAck} message QueryPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPirvateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryPirvateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.QueryPirvateInfoAck} QueryPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPirvateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.QueryPirvateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CLPF.PrivateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryPirvateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.QueryPirvateInfoAck} QueryPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPirvateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryPirvateInfoAck message.
         * @function verify
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryPirvateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CLPF.PrivateInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryPirvateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.QueryPirvateInfoAck} QueryPirvateInfoAck
         */
        QueryPirvateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.QueryPirvateInfoAck)
                return object;
            var message = new $root.CLPF.QueryPirvateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CLPF.QueryPirvateInfoAck.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CLPF.QueryPirvateInfoAck.items: object expected");
                    message.items[i] = $root.CLPF.PrivateInfo.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryPirvateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.QueryPirvateInfoAck
         * @static
         * @param {CLPF.QueryPirvateInfoAck} message QueryPirvateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryPirvateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CLPF.PrivateInfo.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryPirvateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.QueryPirvateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryPirvateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryPirvateInfoAck;
    })();

    CLPF.HelpCreaterDismissPirvateInfoReq = (function() {

        /**
         * Properties of a HelpCreaterDismissPirvateInfoReq.
         * @memberof CLPF
         * @interface IHelpCreaterDismissPirvateInfoReq
         * @property {number|null} [roomNum] HelpCreaterDismissPirvateInfoReq roomNum
         */

        /**
         * Constructs a new HelpCreaterDismissPirvateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a HelpCreaterDismissPirvateInfoReq.
         * @implements IHelpCreaterDismissPirvateInfoReq
         * @constructor
         * @param {CLPF.IHelpCreaterDismissPirvateInfoReq=} [properties] Properties to set
         */
        function HelpCreaterDismissPirvateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelpCreaterDismissPirvateInfoReq roomNum.
         * @member {number} roomNum
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @instance
         */
        HelpCreaterDismissPirvateInfoReq.prototype.roomNum = 0;

        /**
         * Creates a new HelpCreaterDismissPirvateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoReq=} [properties] Properties to set
         * @returns {CLPF.HelpCreaterDismissPirvateInfoReq} HelpCreaterDismissPirvateInfoReq instance
         */
        HelpCreaterDismissPirvateInfoReq.create = function create(properties) {
            return new HelpCreaterDismissPirvateInfoReq(properties);
        };

        /**
         * Encodes the specified HelpCreaterDismissPirvateInfoReq message. Does not implicitly {@link CLPF.HelpCreaterDismissPirvateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoReq} message HelpCreaterDismissPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpCreaterDismissPirvateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomNum != null && Object.hasOwnProperty.call(message, "roomNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roomNum);
            return writer;
        };

        /**
         * Encodes the specified HelpCreaterDismissPirvateInfoReq message, length delimited. Does not implicitly {@link CLPF.HelpCreaterDismissPirvateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoReq} message HelpCreaterDismissPirvateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpCreaterDismissPirvateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelpCreaterDismissPirvateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.HelpCreaterDismissPirvateInfoReq} HelpCreaterDismissPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpCreaterDismissPirvateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.HelpCreaterDismissPirvateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelpCreaterDismissPirvateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.HelpCreaterDismissPirvateInfoReq} HelpCreaterDismissPirvateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpCreaterDismissPirvateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelpCreaterDismissPirvateInfoReq message.
         * @function verify
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelpCreaterDismissPirvateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum))
                    return "roomNum: integer expected";
            return null;
        };

        /**
         * Creates a HelpCreaterDismissPirvateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.HelpCreaterDismissPirvateInfoReq} HelpCreaterDismissPirvateInfoReq
         */
        HelpCreaterDismissPirvateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.HelpCreaterDismissPirvateInfoReq)
                return object;
            var message = new $root.CLPF.HelpCreaterDismissPirvateInfoReq();
            if (object.roomNum != null)
                message.roomNum = object.roomNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a HelpCreaterDismissPirvateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @static
         * @param {CLPF.HelpCreaterDismissPirvateInfoReq} message HelpCreaterDismissPirvateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HelpCreaterDismissPirvateInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.roomNum = 0;
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                object.roomNum = message.roomNum;
            return object;
        };

        /**
         * Converts this HelpCreaterDismissPirvateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.HelpCreaterDismissPirvateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HelpCreaterDismissPirvateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HelpCreaterDismissPirvateInfoReq;
    })();

    CLPF.HelpCreaterDismissPirvateInfoAck = (function() {

        /**
         * Properties of a HelpCreaterDismissPirvateInfoAck.
         * @memberof CLPF
         * @interface IHelpCreaterDismissPirvateInfoAck
         * @property {number|null} [errcode] HelpCreaterDismissPirvateInfoAck errcode
         */

        /**
         * Constructs a new HelpCreaterDismissPirvateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a HelpCreaterDismissPirvateInfoAck.
         * @implements IHelpCreaterDismissPirvateInfoAck
         * @constructor
         * @param {CLPF.IHelpCreaterDismissPirvateInfoAck=} [properties] Properties to set
         */
        function HelpCreaterDismissPirvateInfoAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelpCreaterDismissPirvateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @instance
         */
        HelpCreaterDismissPirvateInfoAck.prototype.errcode = 0;

        /**
         * Creates a new HelpCreaterDismissPirvateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoAck=} [properties] Properties to set
         * @returns {CLPF.HelpCreaterDismissPirvateInfoAck} HelpCreaterDismissPirvateInfoAck instance
         */
        HelpCreaterDismissPirvateInfoAck.create = function create(properties) {
            return new HelpCreaterDismissPirvateInfoAck(properties);
        };

        /**
         * Encodes the specified HelpCreaterDismissPirvateInfoAck message. Does not implicitly {@link CLPF.HelpCreaterDismissPirvateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoAck} message HelpCreaterDismissPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpCreaterDismissPirvateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified HelpCreaterDismissPirvateInfoAck message, length delimited. Does not implicitly {@link CLPF.HelpCreaterDismissPirvateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {CLPF.IHelpCreaterDismissPirvateInfoAck} message HelpCreaterDismissPirvateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpCreaterDismissPirvateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelpCreaterDismissPirvateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.HelpCreaterDismissPirvateInfoAck} HelpCreaterDismissPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpCreaterDismissPirvateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.HelpCreaterDismissPirvateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelpCreaterDismissPirvateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.HelpCreaterDismissPirvateInfoAck} HelpCreaterDismissPirvateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpCreaterDismissPirvateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelpCreaterDismissPirvateInfoAck message.
         * @function verify
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelpCreaterDismissPirvateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a HelpCreaterDismissPirvateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.HelpCreaterDismissPirvateInfoAck} HelpCreaterDismissPirvateInfoAck
         */
        HelpCreaterDismissPirvateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.HelpCreaterDismissPirvateInfoAck)
                return object;
            var message = new $root.CLPF.HelpCreaterDismissPirvateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a HelpCreaterDismissPirvateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @static
         * @param {CLPF.HelpCreaterDismissPirvateInfoAck} message HelpCreaterDismissPirvateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HelpCreaterDismissPirvateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this HelpCreaterDismissPirvateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.HelpCreaterDismissPirvateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HelpCreaterDismissPirvateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HelpCreaterDismissPirvateInfoAck;
    })();

    CLPF.ContinuePrivateInfoReq = (function() {

        /**
         * Properties of a ContinuePrivateInfoReq.
         * @memberof CLPF
         * @interface IContinuePrivateInfoReq
         * @property {boolean|null} ["continue"] ContinuePrivateInfoReq continue
         * @property {number|null} [roomNum] ContinuePrivateInfoReq roomNum
         */

        /**
         * Constructs a new ContinuePrivateInfoReq.
         * @memberof CLPF
         * @classdesc Represents a ContinuePrivateInfoReq.
         * @implements IContinuePrivateInfoReq
         * @constructor
         * @param {CLPF.IContinuePrivateInfoReq=} [properties] Properties to set
         */
        function ContinuePrivateInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinuePrivateInfoReq continue.
         * @member {boolean} continue
         * @memberof CLPF.ContinuePrivateInfoReq
         * @instance
         */
        ContinuePrivateInfoReq.prototype["continue"] = false;

        /**
         * ContinuePrivateInfoReq roomNum.
         * @member {number} roomNum
         * @memberof CLPF.ContinuePrivateInfoReq
         * @instance
         */
        ContinuePrivateInfoReq.prototype.roomNum = 0;

        /**
         * Creates a new ContinuePrivateInfoReq instance using the specified properties.
         * @function create
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {CLPF.IContinuePrivateInfoReq=} [properties] Properties to set
         * @returns {CLPF.ContinuePrivateInfoReq} ContinuePrivateInfoReq instance
         */
        ContinuePrivateInfoReq.create = function create(properties) {
            return new ContinuePrivateInfoReq(properties);
        };

        /**
         * Encodes the specified ContinuePrivateInfoReq message. Does not implicitly {@link CLPF.ContinuePrivateInfoReq.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {CLPF.IContinuePrivateInfoReq} message ContinuePrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuePrivateInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["continue"] != null && Object.hasOwnProperty.call(message, "continue"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message["continue"]);
            if (message.roomNum != null && Object.hasOwnProperty.call(message, "roomNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roomNum);
            return writer;
        };

        /**
         * Encodes the specified ContinuePrivateInfoReq message, length delimited. Does not implicitly {@link CLPF.ContinuePrivateInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {CLPF.IContinuePrivateInfoReq} message ContinuePrivateInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuePrivateInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinuePrivateInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ContinuePrivateInfoReq} ContinuePrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuePrivateInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ContinuePrivateInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message["continue"] = reader.bool();
                    break;
                case 2:
                    message.roomNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinuePrivateInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ContinuePrivateInfoReq} ContinuePrivateInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuePrivateInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinuePrivateInfoReq message.
         * @function verify
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinuePrivateInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["continue"] != null && message.hasOwnProperty("continue"))
                if (typeof message["continue"] !== "boolean")
                    return "continue: boolean expected";
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum))
                    return "roomNum: integer expected";
            return null;
        };

        /**
         * Creates a ContinuePrivateInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ContinuePrivateInfoReq} ContinuePrivateInfoReq
         */
        ContinuePrivateInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ContinuePrivateInfoReq)
                return object;
            var message = new $root.CLPF.ContinuePrivateInfoReq();
            if (object["continue"] != null)
                message["continue"] = Boolean(object["continue"]);
            if (object.roomNum != null)
                message.roomNum = object.roomNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContinuePrivateInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ContinuePrivateInfoReq
         * @static
         * @param {CLPF.ContinuePrivateInfoReq} message ContinuePrivateInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinuePrivateInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object["continue"] = false;
                object.roomNum = 0;
            }
            if (message["continue"] != null && message.hasOwnProperty("continue"))
                object["continue"] = message["continue"];
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                object.roomNum = message.roomNum;
            return object;
        };

        /**
         * Converts this ContinuePrivateInfoReq to JSON.
         * @function toJSON
         * @memberof CLPF.ContinuePrivateInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinuePrivateInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContinuePrivateInfoReq;
    })();

    CLPF.ContinuePrivateInfoAck = (function() {

        /**
         * Properties of a ContinuePrivateInfoAck.
         * @memberof CLPF
         * @interface IContinuePrivateInfoAck
         * @property {number|null} [errcode] ContinuePrivateInfoAck errcode
         */

        /**
         * Constructs a new ContinuePrivateInfoAck.
         * @memberof CLPF
         * @classdesc Represents a ContinuePrivateInfoAck.
         * @implements IContinuePrivateInfoAck
         * @constructor
         * @param {CLPF.IContinuePrivateInfoAck=} [properties] Properties to set
         */
        function ContinuePrivateInfoAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinuePrivateInfoAck errcode.
         * @member {number} errcode
         * @memberof CLPF.ContinuePrivateInfoAck
         * @instance
         */
        ContinuePrivateInfoAck.prototype.errcode = 0;

        /**
         * Creates a new ContinuePrivateInfoAck instance using the specified properties.
         * @function create
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {CLPF.IContinuePrivateInfoAck=} [properties] Properties to set
         * @returns {CLPF.ContinuePrivateInfoAck} ContinuePrivateInfoAck instance
         */
        ContinuePrivateInfoAck.create = function create(properties) {
            return new ContinuePrivateInfoAck(properties);
        };

        /**
         * Encodes the specified ContinuePrivateInfoAck message. Does not implicitly {@link CLPF.ContinuePrivateInfoAck.verify|verify} messages.
         * @function encode
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {CLPF.IContinuePrivateInfoAck} message ContinuePrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuePrivateInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errcode != null && Object.hasOwnProperty.call(message, "errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errcode);
            return writer;
        };

        /**
         * Encodes the specified ContinuePrivateInfoAck message, length delimited. Does not implicitly {@link CLPF.ContinuePrivateInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {CLPF.IContinuePrivateInfoAck} message ContinuePrivateInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuePrivateInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinuePrivateInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CLPF.ContinuePrivateInfoAck} ContinuePrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuePrivateInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CLPF.ContinuePrivateInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errcode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinuePrivateInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CLPF.ContinuePrivateInfoAck} ContinuePrivateInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuePrivateInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinuePrivateInfoAck message.
         * @function verify
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinuePrivateInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                if (!$util.isInteger(message.errcode))
                    return "errcode: integer expected";
            return null;
        };

        /**
         * Creates a ContinuePrivateInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CLPF.ContinuePrivateInfoAck} ContinuePrivateInfoAck
         */
        ContinuePrivateInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CLPF.ContinuePrivateInfoAck)
                return object;
            var message = new $root.CLPF.ContinuePrivateInfoAck();
            if (object.errcode != null)
                message.errcode = object.errcode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContinuePrivateInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CLPF.ContinuePrivateInfoAck
         * @static
         * @param {CLPF.ContinuePrivateInfoAck} message ContinuePrivateInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinuePrivateInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errcode = 0;
            if (message.errcode != null && message.hasOwnProperty("errcode"))
                object.errcode = message.errcode;
            return object;
        };

        /**
         * Converts this ContinuePrivateInfoAck to JSON.
         * @function toJSON
         * @memberof CLPF.ContinuePrivateInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinuePrivateInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContinuePrivateInfoAck;
    })();

    return CLPF;
})();

module.exports = $root;
